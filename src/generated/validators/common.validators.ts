/**
 * Auto-generated validation classes for Common models
 * DO NOT EDIT MANUALLY
 */

import type { AccountDeployment, AndFilter, ApiConfig, AvailableTeam, BaseDeployment, BaseEntityGet, BaseEntityList, BetweenFilter, BucketCreate, BucketInfo, BucketList, CodeAbilityBase, CodeAbilityLink, CodeAbilityMeta, CodeAbilityMetaProperties, CodeAbilityMetaProperty, CodeAbilityPerson, CodeAbilityReleaseMeta, CodeAbilityReport, CodeAbilityReportMain, CodeAbilityReportProperties, CodeAbilityReportSub, CodeAbilityReportSummary, CodeAbilitySpecification, CodeAbilityTest, CodeAbilityTestCollection, CodeAbilityTestCollectionCommon, CodeAbilityTestCommon, CodeAbilityTestProperty, CodeAbilityTestSuite, CodeAbilityUnitMeta, CommentCreate, CommentUpdate, ComputorDeploymentConfig, ContainsFilter, ContentValidationCreate, ContentValidationGet, ContentValidationItem, ContentValidationResult, CourseContentDeploymentCreate, CourseContentDeploymentList, CourseContentDeploymentQuery, CourseContentDeploymentUpdate, CourseMemberDeployment, CourseMemberGitLabConfig, DeploymentGet, DeploymentHistoryCreate, DeploymentHistoryList, DeploymentList, DeploymentMetadata, DeploymentSummary, EndswithFilter, EqualsFilter, ExecutionBackendConfig, ExecutionBackendCreate, ExecutionBackendGet, ExecutionBackendList, ExecutionBackendQuery, ExecutionBackendReference, ExecutionBackendUpdate, ExtensionMetadata, ExtensionPublishRequest, ExtensionPublishResponse, ExtensionUploadConfig, ExtensionVersionBase, ExtensionVersionDetail, ExtensionVersionListItem, ExtensionVersionListResponse, ExtensionVersionYankRequest, FileSourceConfig, FilterBase, GenerateAssignmentsRequest, GenerateAssignmentsResponse, GenerateTemplateRequest, GenerateTemplateResponse, GitCommit, GitHubConfig, GitLabConfig, GitLabConfigGet, GitLabCredentials, GitlabGroupProjectConfig, GradedArtifactInfo, GradingStudentView, GradingSummary, GreaterFilter, GroupClaimCreate, GroupClaimGet, GroupClaimList, GroupClaimQuery, GroupClaimUpdate, GroupCreate, GroupGet, GroupList, GroupQuery, GroupUpdate, ILikeFilter, InFilter, IsNullFilter, JoinTeamRequest, JoinTeamResponse, LanguageCreate, LanguageGet, LanguageList, LanguageQuery, LanguageUpdate, LeaveTeamResponse, LikeFilter, ListQuery, LogoutRequest, LogoutResponse, LowerFilter, NotEqualsFilter, NotInFilter, NotNullFilter, OrFilter, PendingChange, PendingChangesResponse, PresignedUrlRequest, PresignedUrlResponse, ProfileCreate, ProfileGet, ProfileList, ProfileQuery, ProfileUpdate, ReleaseOverride, ReleaseSelection, ReleaseStudentsCreate, ReleaseValidationError, Repository, RepositoryConfig, ResultArtifactCreate, ResultArtifactListItem, ResultArtifactQuery, ResultCreate, ResultGet, ResultList, ResultQuery, ResultStudentList, ResultUpdate, ResultWithGrading, SemanticVersion, SessionCreate, SessionGet, SessionList, SessionQuery, SessionUpdate, StartswithFilter, StatusQuery, StorageObjectCreate, StorageObjectGet, StorageObjectList, StorageObjectMetadata, StorageObjectQuery, StorageObjectUpdate, StorageUsageStats, StudentCreate, StudentProfileCreate, StudentProfileGet, StudentProfileList, StudentProfileQuery, StudentProfileUpdate, StudentTemplateSettings, SubmissionArtifactCreate, SubmissionArtifactGet, SubmissionArtifactList, SubmissionArtifactQuery, SubmissionArtifactUpdate, SubmissionCreate, SubmissionGradeCreate, SubmissionGradeDetail, SubmissionGradeListItem, SubmissionGradeQuery, SubmissionGradeUpdate, SubmissionGroupCreate, SubmissionGroupDetailed, SubmissionGroupGet, SubmissionGroupGradingCreate, SubmissionGroupGradingGet, SubmissionGroupGradingList, SubmissionGroupGradingQuery, SubmissionGroupGradingUpdate, SubmissionGroupList, SubmissionGroupMemberBasic, SubmissionGroupMemberCreate, SubmissionGroupMemberGet, SubmissionGroupMemberList, SubmissionGroupMemberProperties, SubmissionGroupMemberQuery, SubmissionGroupMemberUpdate, SubmissionGroupProperties, SubmissionGroupQuery, SubmissionGroupRepository, SubmissionGroupStudentGet, SubmissionGroupStudentList, SubmissionGroupStudentQuery, SubmissionGroupUpdate, SubmissionGroupWithGrading, SubmissionListItem, SubmissionQuery, SubmissionReviewCreate, SubmissionReviewDetail, SubmissionReviewListItem, SubmissionReviewQuery, SubmissionReviewUpdate, SubmissionUploadResponseModel, SubmissionUploadedFile, TUGStudentExport, TeamCreate, TeamFormationRules, TeamLockRequest, TeamLockResponse, TeamMemberInfo, TeamResponse, TestCreate, TestDependency, TutorGradeCreate, TutorGradeResponse, TutorSubmissionGroupGet, TutorSubmissionGroupList, TutorSubmissionGroupMember, TutorSubmissionGroupQuery, TypeConfig, UserAccountDeployment, UserDeployment, UsersDeploymentConfig, ValidationError, VersionValidationResult, VsixMetadata } from '../types/common';
import { GradingStatus, GroupType, LanguageEnum, MergeMethod, MetaTypeEnum, QualificationEnum, ResultEnum, StatusEnum, TypeEnum } from '../types/common';
import { BaseValidator, ValidationError } from './BaseValidator';

export function validateGroupType(value: any): GroupType {
  const validValues = ['fixed', 'dynamic'];
  if (!validValues.includes(value)) {
    throw new ValidationError('GroupType', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as GroupType;
}

export function validateMergeMethod(value: any): MergeMethod {
  const validValues = ['rebase_merge', 'merge', 'ff'];
  if (!validValues.includes(value)) {
    throw new ValidationError('MergeMethod', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as MergeMethod;
}

export function validateStatusEnum(value: any): StatusEnum {
  const validValues = ['SCHEDULED', 'COMPLETED', 'TIMEDOUT', 'CRASHED', 'CANCELLED', 'SKIPPED', 'FAILED'];
  if (!validValues.includes(value)) {
    throw new ValidationError('StatusEnum', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as StatusEnum;
}

export function validateResultEnum(value: any): ResultEnum {
  const validValues = ['PASSED', 'FAILED', 'SKIPPED'];
  if (!validValues.includes(value)) {
    throw new ValidationError('ResultEnum', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as ResultEnum;
}

export function validateQualificationEnum(value: any): QualificationEnum {
  const validValues = ['verifyEqual', 'matches', 'contains', 'startsWith', 'endsWith', 'count', 'regexp'];
  if (!validValues.includes(value)) {
    throw new ValidationError('QualificationEnum', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as QualificationEnum;
}

export function validateTypeEnum(value: any): TypeEnum {
  const validValues = ['variable', 'graphics', 'structural', 'linting', 'exist', 'error', 'warning', 'help', 'stdout'];
  if (!validValues.includes(value)) {
    throw new ValidationError('TypeEnum', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as TypeEnum;
}

export function validateLanguageEnum(value: any): LanguageEnum {
  const validValues = ['de', 'en'];
  if (!validValues.includes(value)) {
    throw new ValidationError('LanguageEnum', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as LanguageEnum;
}

export function validateMetaTypeEnum(value: any): MetaTypeEnum {
  const validValues = ['course', 'unit', 'assignment'];
  if (!validValues.includes(value)) {
    throw new ValidationError('MetaTypeEnum', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as MetaTypeEnum;
}

export function validateGradingStatus(value: any): GradingStatus {
  const validValues = [0, 1, 2, 3];
  if (!validValues.includes(value)) {
    throw new ValidationError('GradingStatus', `Invalid value: ${value}. Expected one of: ${validValues.join(', ')}`);
  }
  return value as GradingStatus;
}

/**
 * Validator for StudentProfileCreate
 */
export class StudentProfileCreateValidator extends BaseValidator<StudentProfileCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "student_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Id"
    },
    "student_email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Email"
    },
    "user_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "User Id"
    },
    "organization_id": {
      "title": "Organization Id",
      "type": "string"
    }
  },
  "required": [
    "organization_id"
  ],
  "title": "StudentProfileCreate",
  "type": "object",
  "x-model-name": "StudentProfileCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StudentProfileCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StudentProfileCreate', 'Expected an object');
    }

    // Optional field: student_id
    if ('student_id' in data && data.student_id !== undefined && data.student_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: student_email
    if ('student_email' in data && data.student_email !== undefined && data.student_email !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: user_id
    if ('user_id' in data && data.user_id !== undefined && data.user_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: organization_id
    if (!('organization_id' in data)) {
      errors.push('Missing required field: organization_id');
    } else {
      if (typeof data.organization_id !== 'string') {
        errors.push('Field organization_id must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('StudentProfileCreate', errors.join('; '));
    }

    return data as StudentProfileCreate;
  }

  safeValidate(data: any): { success: true; data: StudentProfileCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StudentProfileCreate', String(error)) };
    }
  }
}

/**
 * Validator for StudentProfileGet
 */
export class StudentProfileGetValidator extends BaseValidator<StudentProfileGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfigGet": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        }
      },
      "title": "GitLabConfigGet",
      "type": "object"
    },
    "OrganizationGet": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "description": "Organization unique identifier",
          "title": "Id",
          "type": "string"
        },
        "path": {
          "description": "Hierarchical path",
          "title": "Path",
          "type": "string"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization title",
          "title": "Title"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization description",
          "title": "Description"
        },
        "organization_type": {
          "$ref": "#/$defs/OrganizationType",
          "description": "Type of organization"
        },
        "user_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Associated user ID",
          "title": "User Id"
        },
        "properties": {
          "anyOf": [
            {
              "$ref": "#/$defs/OrganizationPropertiesGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Additional properties"
        },
        "number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization number",
          "title": "Number"
        },
        "email": {
          "anyOf": [
            {
              "format": "email",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Contact email",
          "title": "Email"
        },
        "telephone": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Phone number",
          "title": "Telephone"
        },
        "fax_number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Fax number",
          "title": "Fax Number"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Website URL",
          "title": "Url"
        },
        "postal_code": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Postal code",
          "title": "Postal Code"
        },
        "street_address": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Street address",
          "title": "Street Address"
        },
        "locality": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "City/locality",
          "title": "Locality"
        },
        "region": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "State/region",
          "title": "Region"
        },
        "country": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Country",
          "title": "Country"
        }
      },
      "required": [
        "id",
        "path",
        "organization_type"
      ],
      "title": "OrganizationGet",
      "type": "object"
    },
    "OrganizationPropertiesGet": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfigGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "OrganizationPropertiesGet",
      "type": "object"
    },
    "OrganizationType": {
      "enum": [
        "user",
        "community",
        "organization"
      ],
      "title": "OrganizationType",
      "type": "string"
    }
  },
  "properties": {
    "student_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Id"
    },
    "student_email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Email"
    },
    "user_id": {
      "title": "User Id",
      "type": "string"
    },
    "organization_id": {
      "title": "Organization Id",
      "type": "string"
    },
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "organization": {
      "anyOf": [
        {
          "$ref": "#/$defs/OrganizationGet"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "user_id",
    "organization_id",
    "id"
  ],
  "title": "StudentProfileGet",
  "type": "object",
  "x-model-name": "StudentProfileGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StudentProfileGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StudentProfileGet', 'Expected an object');
    }

    // Optional field: student_id
    if ('student_id' in data && data.student_id !== undefined && data.student_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: student_email
    if ('student_email' in data && data.student_email !== undefined && data.student_email !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Required field: organization_id
    if (!('organization_id' in data)) {
      errors.push('Missing required field: organization_id');
    } else {
      if (typeof data.organization_id !== 'string') {
        errors.push('Field organization_id must be a string');
      }
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Optional field: organization
    if ('organization' in data && data.organization !== undefined && data.organization !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StudentProfileGet', errors.join('; '));
    }

    return data as StudentProfileGet;
  }

  safeValidate(data: any): { success: true; data: StudentProfileGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StudentProfileGet', String(error)) };
    }
  }
}

/**
 * Validator for StudentProfileList
 */
export class StudentProfileListValidator extends BaseValidator<StudentProfileList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "student_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Id"
    },
    "student_email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Email"
    },
    "user_id": {
      "title": "User Id",
      "type": "string"
    },
    "organization_id": {
      "title": "Organization Id",
      "type": "string"
    }
  },
  "required": [
    "id",
    "user_id",
    "organization_id"
  ],
  "title": "StudentProfileList",
  "type": "object",
  "x-model-name": "StudentProfileList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StudentProfileList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StudentProfileList', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Optional field: student_id
    if ('student_id' in data && data.student_id !== undefined && data.student_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: student_email
    if ('student_email' in data && data.student_email !== undefined && data.student_email !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Required field: organization_id
    if (!('organization_id' in data)) {
      errors.push('Missing required field: organization_id');
    } else {
      if (typeof data.organization_id !== 'string') {
        errors.push('Field organization_id must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('StudentProfileList', errors.join('; '));
    }

    return data as StudentProfileList;
  }

  safeValidate(data: any): { success: true; data: StudentProfileList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StudentProfileList', String(error)) };
    }
  }
}

/**
 * Validator for StudentProfileUpdate
 */
export class StudentProfileUpdateValidator extends BaseValidator<StudentProfileUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "student_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Id"
    },
    "student_email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Email"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "organization_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Organization Id"
    }
  },
  "title": "StudentProfileUpdate",
  "type": "object",
  "x-model-name": "StudentProfileUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StudentProfileUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StudentProfileUpdate', 'Expected an object');
    }

    // Optional field: student_id
    if ('student_id' in data && data.student_id !== undefined && data.student_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: student_email
    if ('student_email' in data && data.student_email !== undefined && data.student_email !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: organization_id
    if ('organization_id' in data && data.organization_id !== undefined && data.organization_id !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StudentProfileUpdate', errors.join('; '));
    }

    return data as StudentProfileUpdate;
  }

  safeValidate(data: any): { success: true; data: StudentProfileUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StudentProfileUpdate', String(error)) };
    }
  }
}

/**
 * Validator for StudentProfileQuery
 */
export class StudentProfileQueryValidator extends BaseValidator<StudentProfileQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "student_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Id"
    },
    "student_email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Student Email"
    },
    "user_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "User Id"
    },
    "organization_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Organization Id"
    }
  },
  "title": "StudentProfileQuery",
  "type": "object",
  "x-model-name": "StudentProfileQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StudentProfileQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StudentProfileQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: student_id
    if ('student_id' in data && data.student_id !== undefined && data.student_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: student_email
    if ('student_email' in data && data.student_email !== undefined && data.student_email !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: user_id
    if ('user_id' in data && data.user_id !== undefined && data.user_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: organization_id
    if ('organization_id' in data && data.organization_id !== undefined && data.organization_id !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StudentProfileQuery', errors.join('; '));
    }

    return data as StudentProfileQuery;
  }

  safeValidate(data: any): { success: true; data: StudentProfileQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StudentProfileQuery', String(error)) };
    }
  }
}

/**
 * Validator for GroupCreate
 */
export class GroupCreateValidator extends BaseValidator<GroupCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GroupType": {
      "enum": [
        "fixed",
        "dynamic"
      ],
      "title": "GroupType",
      "type": "string"
    }
  },
  "properties": {
    "name": {
      "description": "Group name",
      "maxLength": 255,
      "minLength": 1,
      "title": "Name",
      "type": "string"
    },
    "description": {
      "anyOf": [
        {
          "maxLength": 1024,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Group description",
      "title": "Description"
    },
    "group_type": {
      "$ref": "#/$defs/GroupType",
      "description": "Type of group (fixed or dynamic)"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional group properties",
      "title": "Properties"
    }
  },
  "required": [
    "name",
    "group_type"
  ],
  "title": "GroupCreate",
  "type": "object",
  "x-model-name": "GroupCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupCreate', 'Expected an object');
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: group_type
    if (!('group_type' in data)) {
      errors.push('Missing required field: group_type');
    } else {
      // Reference field - basic object check
      if (typeof data.group_type !== 'object') {
        errors.push('Field group_type must be an object');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupCreate', errors.join('; '));
    }

    return data as GroupCreate;
  }

  safeValidate(data: any): { success: true; data: GroupCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupCreate', String(error)) };
    }
  }
}

/**
 * Validator for GroupGet
 */
export class GroupGetValidator extends BaseValidator<GroupGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GroupType": {
      "enum": [
        "fixed",
        "dynamic"
      ],
      "title": "GroupType",
      "type": "string"
    }
  },
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "description": "Group unique identifier",
      "title": "Id",
      "type": "string"
    },
    "name": {
      "description": "Group name",
      "title": "Name",
      "type": "string"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Group description",
      "title": "Description"
    },
    "group_type": {
      "$ref": "#/$defs/GroupType",
      "description": "Type of group"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional properties",
      "title": "Properties"
    }
  },
  "required": [
    "id",
    "name",
    "group_type"
  ],
  "title": "GroupGet",
  "type": "object",
  "x-model-name": "GroupGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupGet', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: group_type
    if (!('group_type' in data)) {
      errors.push('Missing required field: group_type');
    } else {
      // Reference field - basic object check
      if (typeof data.group_type !== 'object') {
        errors.push('Field group_type must be an object');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupGet', errors.join('; '));
    }

    return data as GroupGet;
  }

  safeValidate(data: any): { success: true; data: GroupGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupGet', String(error)) };
    }
  }
}

/**
 * Validator for GroupList
 */
export class GroupListValidator extends BaseValidator<GroupList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GroupType": {
      "enum": [
        "fixed",
        "dynamic"
      ],
      "title": "GroupType",
      "type": "string"
    }
  },
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "description": "Group unique identifier",
      "title": "Id",
      "type": "string"
    },
    "name": {
      "description": "Group name",
      "title": "Name",
      "type": "string"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Group description",
      "title": "Description"
    },
    "group_type": {
      "$ref": "#/$defs/GroupType",
      "description": "Type of group"
    }
  },
  "required": [
    "id",
    "name",
    "group_type"
  ],
  "title": "GroupList",
  "type": "object",
  "x-model-name": "GroupList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupList', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: group_type
    if (!('group_type' in data)) {
      errors.push('Missing required field: group_type');
    } else {
      // Reference field - basic object check
      if (typeof data.group_type !== 'object') {
        errors.push('Field group_type must be an object');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupList', errors.join('; '));
    }

    return data as GroupList;
  }

  safeValidate(data: any): { success: true; data: GroupList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupList', String(error)) };
    }
  }
}

/**
 * Validator for GroupUpdate
 */
export class GroupUpdateValidator extends BaseValidator<GroupUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GroupType": {
      "enum": [
        "fixed",
        "dynamic"
      ],
      "title": "GroupType",
      "type": "string"
    }
  },
  "properties": {
    "name": {
      "anyOf": [
        {
          "maxLength": 255,
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Group name",
      "title": "Name"
    },
    "description": {
      "anyOf": [
        {
          "maxLength": 1024,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Group description",
      "title": "Description"
    },
    "group_type": {
      "anyOf": [
        {
          "$ref": "#/$defs/GroupType"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Type of group"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional properties",
      "title": "Properties"
    }
  },
  "title": "GroupUpdate",
  "type": "object",
  "x-model-name": "GroupUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupUpdate', 'Expected an object');
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: group_type
    if ('group_type' in data && data.group_type !== undefined && data.group_type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupUpdate', errors.join('; '));
    }

    return data as GroupUpdate;
  }

  safeValidate(data: any): { success: true; data: GroupUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupUpdate', String(error)) };
    }
  }
}

/**
 * Validator for GroupQuery
 */
export class GroupQueryValidator extends BaseValidator<GroupQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GroupType": {
      "enum": [
        "fixed",
        "dynamic"
      ],
      "title": "GroupType",
      "type": "string"
    }
  },
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by group ID",
      "title": "Id"
    },
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by group name",
      "title": "Name"
    },
    "group_type": {
      "anyOf": [
        {
          "$ref": "#/$defs/GroupType"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by group type"
    },
    "archived": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by archived status",
      "title": "Archived"
    }
  },
  "title": "GroupQuery",
  "type": "object",
  "x-model-name": "GroupQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: group_type
    if ('group_type' in data && data.group_type !== undefined && data.group_type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: archived
    if ('archived' in data && data.archived !== undefined && data.archived !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupQuery', errors.join('; '));
    }

    return data as GroupQuery;
  }

  safeValidate(data: any): { success: true; data: GroupQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupQuery', String(error)) };
    }
  }
}

/**
 * Validator for FilterBase
 */
export class FilterBaseValidator extends BaseValidator<FilterBase> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {},
  "title": "FilterBase",
  "type": "object",
  "x-model-name": "FilterBase"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): FilterBase {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('FilterBase', 'Expected an object');
    }

    if (errors.length > 0) {
      throw new ValidationError('FilterBase', errors.join('; '));
    }

    return data as FilterBase;
  }

  safeValidate(data: any): { success: true; data: FilterBase } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('FilterBase', String(error)) };
    }
  }
}

/**
 * Validator for EqualsFilter
 */
export class EqualsFilterValidator extends BaseValidator<EqualsFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "eq": {
      "title": "Eq"
    }
  },
  "required": [
    "eq"
  ],
  "title": "EqualsFilter",
  "type": "object",
  "x-model-name": "EqualsFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): EqualsFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('EqualsFilter', 'Expected an object');
    }

    // Required field: eq
    if (!('eq' in data)) {
      errors.push('Missing required field: eq');
    } else {
      // Type validation for eq skipped
    }

    if (errors.length > 0) {
      throw new ValidationError('EqualsFilter', errors.join('; '));
    }

    return data as EqualsFilter;
  }

  safeValidate(data: any): { success: true; data: EqualsFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('EqualsFilter', String(error)) };
    }
  }
}

/**
 * Validator for GreaterFilter
 */
export class GreaterFilterValidator extends BaseValidator<GreaterFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "gt": {
      "title": "Gt"
    }
  },
  "required": [
    "gt"
  ],
  "title": "GreaterFilter",
  "type": "object",
  "x-model-name": "GreaterFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GreaterFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GreaterFilter', 'Expected an object');
    }

    // Required field: gt
    if (!('gt' in data)) {
      errors.push('Missing required field: gt');
    } else {
      // Type validation for gt skipped
    }

    if (errors.length > 0) {
      throw new ValidationError('GreaterFilter', errors.join('; '));
    }

    return data as GreaterFilter;
  }

  safeValidate(data: any): { success: true; data: GreaterFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GreaterFilter', String(error)) };
    }
  }
}

/**
 * Validator for LowerFilter
 */
export class LowerFilterValidator extends BaseValidator<LowerFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "lt": {
      "title": "Lt"
    }
  },
  "required": [
    "lt"
  ],
  "title": "LowerFilter",
  "type": "object",
  "x-model-name": "LowerFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LowerFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LowerFilter', 'Expected an object');
    }

    // Required field: lt
    if (!('lt' in data)) {
      errors.push('Missing required field: lt');
    } else {
      // Type validation for lt skipped
    }

    if (errors.length > 0) {
      throw new ValidationError('LowerFilter', errors.join('; '));
    }

    return data as LowerFilter;
  }

  safeValidate(data: any): { success: true; data: LowerFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LowerFilter', String(error)) };
    }
  }
}

/**
 * Validator for NotEqualsFilter
 */
export class NotEqualsFilterValidator extends BaseValidator<NotEqualsFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "ne": {
      "title": "Ne"
    }
  },
  "required": [
    "ne"
  ],
  "title": "NotEqualsFilter",
  "type": "object",
  "x-model-name": "NotEqualsFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): NotEqualsFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('NotEqualsFilter', 'Expected an object');
    }

    // Required field: ne
    if (!('ne' in data)) {
      errors.push('Missing required field: ne');
    } else {
      // Type validation for ne skipped
    }

    if (errors.length > 0) {
      throw new ValidationError('NotEqualsFilter', errors.join('; '));
    }

    return data as NotEqualsFilter;
  }

  safeValidate(data: any): { success: true; data: NotEqualsFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('NotEqualsFilter', String(error)) };
    }
  }
}

/**
 * Validator for InFilter
 */
export class InFilterValidator extends BaseValidator<InFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "in": {
      "items": {},
      "title": "In",
      "type": "array"
    }
  },
  "required": [
    "in"
  ],
  "title": "InFilter",
  "type": "object",
  "x-model-name": "InFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): InFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('InFilter', 'Expected an object');
    }

    // Required field: in
    if (!('in' in data)) {
      errors.push('Missing required field: in');
    } else {
      if (!Array.isArray(data.in)) {
        errors.push('Field in must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('InFilter', errors.join('; '));
    }

    return data as InFilter;
  }

  safeValidate(data: any): { success: true; data: InFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('InFilter', String(error)) };
    }
  }
}

/**
 * Validator for NotInFilter
 */
export class NotInFilterValidator extends BaseValidator<NotInFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "not_in": {
      "items": {},
      "title": "Not In",
      "type": "array"
    }
  },
  "required": [
    "not_in"
  ],
  "title": "NotInFilter",
  "type": "object",
  "x-model-name": "NotInFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): NotInFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('NotInFilter', 'Expected an object');
    }

    // Required field: not_in
    if (!('not_in' in data)) {
      errors.push('Missing required field: not_in');
    } else {
      if (!Array.isArray(data.not_in)) {
        errors.push('Field not_in must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('NotInFilter', errors.join('; '));
    }

    return data as NotInFilter;
  }

  safeValidate(data: any): { success: true; data: NotInFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('NotInFilter', String(error)) };
    }
  }
}

/**
 * Validator for LikeFilter
 */
export class LikeFilterValidator extends BaseValidator<LikeFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "like": {
      "title": "Like",
      "type": "string"
    }
  },
  "required": [
    "like"
  ],
  "title": "LikeFilter",
  "type": "object",
  "x-model-name": "LikeFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LikeFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LikeFilter', 'Expected an object');
    }

    // Required field: like
    if (!('like' in data)) {
      errors.push('Missing required field: like');
    } else {
      if (typeof data.like !== 'string') {
        errors.push('Field like must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('LikeFilter', errors.join('; '));
    }

    return data as LikeFilter;
  }

  safeValidate(data: any): { success: true; data: LikeFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LikeFilter', String(error)) };
    }
  }
}

/**
 * Validator for ILikeFilter
 */
export class ILikeFilterValidator extends BaseValidator<ILikeFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "ilike": {
      "title": "Ilike",
      "type": "string"
    }
  },
  "required": [
    "ilike"
  ],
  "title": "ILikeFilter",
  "type": "object",
  "x-model-name": "ILikeFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ILikeFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ILikeFilter', 'Expected an object');
    }

    // Required field: ilike
    if (!('ilike' in data)) {
      errors.push('Missing required field: ilike');
    } else {
      if (typeof data.ilike !== 'string') {
        errors.push('Field ilike must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ILikeFilter', errors.join('; '));
    }

    return data as ILikeFilter;
  }

  safeValidate(data: any): { success: true; data: ILikeFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ILikeFilter', String(error)) };
    }
  }
}

/**
 * Validator for BetweenFilter
 */
export class BetweenFilterValidator extends BaseValidator<BetweenFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "between": {
      "items": {},
      "title": "Between",
      "type": "array"
    }
  },
  "required": [
    "between"
  ],
  "title": "BetweenFilter",
  "type": "object",
  "x-model-name": "BetweenFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): BetweenFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('BetweenFilter', 'Expected an object');
    }

    // Required field: between
    if (!('between' in data)) {
      errors.push('Missing required field: between');
    } else {
      if (!Array.isArray(data.between)) {
        errors.push('Field between must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('BetweenFilter', errors.join('; '));
    }

    return data as BetweenFilter;
  }

  safeValidate(data: any): { success: true; data: BetweenFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('BetweenFilter', String(error)) };
    }
  }
}

/**
 * Validator for IsNullFilter
 */
export class IsNullFilterValidator extends BaseValidator<IsNullFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "is_null": {
      "title": "Is Null",
      "type": "boolean"
    }
  },
  "required": [
    "is_null"
  ],
  "title": "IsNullFilter",
  "type": "object",
  "x-model-name": "IsNullFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): IsNullFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('IsNullFilter', 'Expected an object');
    }

    // Required field: is_null
    if (!('is_null' in data)) {
      errors.push('Missing required field: is_null');
    } else {
      if (typeof data.is_null !== 'boolean') {
        errors.push('Field is_null must be a boolean');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('IsNullFilter', errors.join('; '));
    }

    return data as IsNullFilter;
  }

  safeValidate(data: any): { success: true; data: IsNullFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('IsNullFilter', String(error)) };
    }
  }
}

/**
 * Validator for NotNullFilter
 */
export class NotNullFilterValidator extends BaseValidator<NotNullFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "not_null": {
      "title": "Not Null",
      "type": "boolean"
    }
  },
  "required": [
    "not_null"
  ],
  "title": "NotNullFilter",
  "type": "object",
  "x-model-name": "NotNullFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): NotNullFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('NotNullFilter', 'Expected an object');
    }

    // Required field: not_null
    if (!('not_null' in data)) {
      errors.push('Missing required field: not_null');
    } else {
      if (typeof data.not_null !== 'boolean') {
        errors.push('Field not_null must be a boolean');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('NotNullFilter', errors.join('; '));
    }

    return data as NotNullFilter;
  }

  safeValidate(data: any): { success: true; data: NotNullFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('NotNullFilter', String(error)) };
    }
  }
}

/**
 * Validator for StartswithFilter
 */
export class StartswithFilterValidator extends BaseValidator<StartswithFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "startswith": {
      "title": "Startswith",
      "type": "string"
    }
  },
  "required": [
    "startswith"
  ],
  "title": "StartswithFilter",
  "type": "object",
  "x-model-name": "StartswithFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StartswithFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StartswithFilter', 'Expected an object');
    }

    // Required field: startswith
    if (!('startswith' in data)) {
      errors.push('Missing required field: startswith');
    } else {
      if (typeof data.startswith !== 'string') {
        errors.push('Field startswith must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('StartswithFilter', errors.join('; '));
    }

    return data as StartswithFilter;
  }

  safeValidate(data: any): { success: true; data: StartswithFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StartswithFilter', String(error)) };
    }
  }
}

/**
 * Validator for EndswithFilter
 */
export class EndswithFilterValidator extends BaseValidator<EndswithFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "endswith": {
      "title": "Endswith",
      "type": "string"
    }
  },
  "required": [
    "endswith"
  ],
  "title": "EndswithFilter",
  "type": "object",
  "x-model-name": "EndswithFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): EndswithFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('EndswithFilter', 'Expected an object');
    }

    // Required field: endswith
    if (!('endswith' in data)) {
      errors.push('Missing required field: endswith');
    } else {
      if (typeof data.endswith !== 'string') {
        errors.push('Field endswith must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('EndswithFilter', errors.join('; '));
    }

    return data as EndswithFilter;
  }

  safeValidate(data: any): { success: true; data: EndswithFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('EndswithFilter', String(error)) };
    }
  }
}

/**
 * Validator for ContainsFilter
 */
export class ContainsFilterValidator extends BaseValidator<ContainsFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "contains": {
      "title": "Contains",
      "type": "string"
    }
  },
  "required": [
    "contains"
  ],
  "title": "ContainsFilter",
  "type": "object",
  "x-model-name": "ContainsFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ContainsFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ContainsFilter', 'Expected an object');
    }

    // Required field: contains
    if (!('contains' in data)) {
      errors.push('Missing required field: contains');
    } else {
      if (typeof data.contains !== 'string') {
        errors.push('Field contains must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ContainsFilter', errors.join('; '));
    }

    return data as ContainsFilter;
  }

  safeValidate(data: any): { success: true; data: ContainsFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ContainsFilter', String(error)) };
    }
  }
}

/**
 * Validator for AndFilter
 */
export class AndFilterValidator extends BaseValidator<AndFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "AndFilter": {
      "properties": {
        "and_": {
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/EqualsFilter"
              },
              {
                "$ref": "#/$defs/GreaterFilter"
              },
              {
                "$ref": "#/$defs/LowerFilter"
              },
              {
                "$ref": "#/$defs/NotEqualsFilter"
              },
              {
                "$ref": "#/$defs/InFilter"
              },
              {
                "$ref": "#/$defs/NotInFilter"
              },
              {
                "$ref": "#/$defs/LikeFilter"
              },
              {
                "$ref": "#/$defs/ILikeFilter"
              },
              {
                "$ref": "#/$defs/BetweenFilter"
              },
              {
                "$ref": "#/$defs/IsNullFilter"
              },
              {
                "$ref": "#/$defs/NotNullFilter"
              },
              {
                "$ref": "#/$defs/StartswithFilter"
              },
              {
                "$ref": "#/$defs/EndswithFilter"
              },
              {
                "$ref": "#/$defs/ContainsFilter"
              },
              {
                "$ref": "#/$defs/AndFilter"
              },
              {
                "$ref": "#/$defs/OrFilter"
              }
            ]
          },
          "title": "And",
          "type": "array"
        }
      },
      "required": [
        "and_"
      ],
      "title": "AndFilter",
      "type": "object"
    },
    "BetweenFilter": {
      "properties": {
        "between": {
          "items": {},
          "title": "Between",
          "type": "array"
        }
      },
      "required": [
        "between"
      ],
      "title": "BetweenFilter",
      "type": "object"
    },
    "ContainsFilter": {
      "properties": {
        "contains": {
          "title": "Contains",
          "type": "string"
        }
      },
      "required": [
        "contains"
      ],
      "title": "ContainsFilter",
      "type": "object"
    },
    "EndswithFilter": {
      "properties": {
        "endswith": {
          "title": "Endswith",
          "type": "string"
        }
      },
      "required": [
        "endswith"
      ],
      "title": "EndswithFilter",
      "type": "object"
    },
    "EqualsFilter": {
      "properties": {
        "eq": {
          "title": "Eq"
        }
      },
      "required": [
        "eq"
      ],
      "title": "EqualsFilter",
      "type": "object"
    },
    "GreaterFilter": {
      "properties": {
        "gt": {
          "title": "Gt"
        }
      },
      "required": [
        "gt"
      ],
      "title": "GreaterFilter",
      "type": "object"
    },
    "ILikeFilter": {
      "properties": {
        "ilike": {
          "title": "Ilike",
          "type": "string"
        }
      },
      "required": [
        "ilike"
      ],
      "title": "ILikeFilter",
      "type": "object"
    },
    "InFilter": {
      "properties": {
        "in": {
          "items": {},
          "title": "In",
          "type": "array"
        }
      },
      "required": [
        "in"
      ],
      "title": "InFilter",
      "type": "object"
    },
    "IsNullFilter": {
      "properties": {
        "is_null": {
          "title": "Is Null",
          "type": "boolean"
        }
      },
      "required": [
        "is_null"
      ],
      "title": "IsNullFilter",
      "type": "object"
    },
    "LikeFilter": {
      "properties": {
        "like": {
          "title": "Like",
          "type": "string"
        }
      },
      "required": [
        "like"
      ],
      "title": "LikeFilter",
      "type": "object"
    },
    "LowerFilter": {
      "properties": {
        "lt": {
          "title": "Lt"
        }
      },
      "required": [
        "lt"
      ],
      "title": "LowerFilter",
      "type": "object"
    },
    "NotEqualsFilter": {
      "properties": {
        "ne": {
          "title": "Ne"
        }
      },
      "required": [
        "ne"
      ],
      "title": "NotEqualsFilter",
      "type": "object"
    },
    "NotInFilter": {
      "properties": {
        "not_in": {
          "items": {},
          "title": "Not In",
          "type": "array"
        }
      },
      "required": [
        "not_in"
      ],
      "title": "NotInFilter",
      "type": "object"
    },
    "NotNullFilter": {
      "properties": {
        "not_null": {
          "title": "Not Null",
          "type": "boolean"
        }
      },
      "required": [
        "not_null"
      ],
      "title": "NotNullFilter",
      "type": "object"
    },
    "OrFilter": {
      "properties": {
        "or_": {
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/EqualsFilter"
              },
              {
                "$ref": "#/$defs/GreaterFilter"
              },
              {
                "$ref": "#/$defs/LowerFilter"
              },
              {
                "$ref": "#/$defs/NotEqualsFilter"
              },
              {
                "$ref": "#/$defs/InFilter"
              },
              {
                "$ref": "#/$defs/NotInFilter"
              },
              {
                "$ref": "#/$defs/LikeFilter"
              },
              {
                "$ref": "#/$defs/ILikeFilter"
              },
              {
                "$ref": "#/$defs/BetweenFilter"
              },
              {
                "$ref": "#/$defs/IsNullFilter"
              },
              {
                "$ref": "#/$defs/NotNullFilter"
              },
              {
                "$ref": "#/$defs/StartswithFilter"
              },
              {
                "$ref": "#/$defs/EndswithFilter"
              },
              {
                "$ref": "#/$defs/ContainsFilter"
              },
              {
                "$ref": "#/$defs/AndFilter"
              },
              {
                "$ref": "#/$defs/OrFilter"
              }
            ]
          },
          "title": "Or",
          "type": "array"
        }
      },
      "required": [
        "or_"
      ],
      "title": "OrFilter",
      "type": "object"
    },
    "StartswithFilter": {
      "properties": {
        "startswith": {
          "title": "Startswith",
          "type": "string"
        }
      },
      "required": [
        "startswith"
      ],
      "title": "StartswithFilter",
      "type": "object"
    }
  },
  "$ref": "#/$defs/AndFilter",
  "x-model-name": "AndFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): AndFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('AndFilter', 'Expected an object');
    }

    if (errors.length > 0) {
      throw new ValidationError('AndFilter', errors.join('; '));
    }

    return data as AndFilter;
  }

  safeValidate(data: any): { success: true; data: AndFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('AndFilter', String(error)) };
    }
  }
}

/**
 * Validator for OrFilter
 */
export class OrFilterValidator extends BaseValidator<OrFilter> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "AndFilter": {
      "properties": {
        "and_": {
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/EqualsFilter"
              },
              {
                "$ref": "#/$defs/GreaterFilter"
              },
              {
                "$ref": "#/$defs/LowerFilter"
              },
              {
                "$ref": "#/$defs/NotEqualsFilter"
              },
              {
                "$ref": "#/$defs/InFilter"
              },
              {
                "$ref": "#/$defs/NotInFilter"
              },
              {
                "$ref": "#/$defs/LikeFilter"
              },
              {
                "$ref": "#/$defs/ILikeFilter"
              },
              {
                "$ref": "#/$defs/BetweenFilter"
              },
              {
                "$ref": "#/$defs/IsNullFilter"
              },
              {
                "$ref": "#/$defs/NotNullFilter"
              },
              {
                "$ref": "#/$defs/StartswithFilter"
              },
              {
                "$ref": "#/$defs/EndswithFilter"
              },
              {
                "$ref": "#/$defs/ContainsFilter"
              },
              {
                "$ref": "#/$defs/AndFilter"
              },
              {
                "$ref": "#/$defs/OrFilter"
              }
            ]
          },
          "title": "And",
          "type": "array"
        }
      },
      "required": [
        "and_"
      ],
      "title": "AndFilter",
      "type": "object"
    },
    "BetweenFilter": {
      "properties": {
        "between": {
          "items": {},
          "title": "Between",
          "type": "array"
        }
      },
      "required": [
        "between"
      ],
      "title": "BetweenFilter",
      "type": "object"
    },
    "ContainsFilter": {
      "properties": {
        "contains": {
          "title": "Contains",
          "type": "string"
        }
      },
      "required": [
        "contains"
      ],
      "title": "ContainsFilter",
      "type": "object"
    },
    "EndswithFilter": {
      "properties": {
        "endswith": {
          "title": "Endswith",
          "type": "string"
        }
      },
      "required": [
        "endswith"
      ],
      "title": "EndswithFilter",
      "type": "object"
    },
    "EqualsFilter": {
      "properties": {
        "eq": {
          "title": "Eq"
        }
      },
      "required": [
        "eq"
      ],
      "title": "EqualsFilter",
      "type": "object"
    },
    "GreaterFilter": {
      "properties": {
        "gt": {
          "title": "Gt"
        }
      },
      "required": [
        "gt"
      ],
      "title": "GreaterFilter",
      "type": "object"
    },
    "ILikeFilter": {
      "properties": {
        "ilike": {
          "title": "Ilike",
          "type": "string"
        }
      },
      "required": [
        "ilike"
      ],
      "title": "ILikeFilter",
      "type": "object"
    },
    "InFilter": {
      "properties": {
        "in": {
          "items": {},
          "title": "In",
          "type": "array"
        }
      },
      "required": [
        "in"
      ],
      "title": "InFilter",
      "type": "object"
    },
    "IsNullFilter": {
      "properties": {
        "is_null": {
          "title": "Is Null",
          "type": "boolean"
        }
      },
      "required": [
        "is_null"
      ],
      "title": "IsNullFilter",
      "type": "object"
    },
    "LikeFilter": {
      "properties": {
        "like": {
          "title": "Like",
          "type": "string"
        }
      },
      "required": [
        "like"
      ],
      "title": "LikeFilter",
      "type": "object"
    },
    "LowerFilter": {
      "properties": {
        "lt": {
          "title": "Lt"
        }
      },
      "required": [
        "lt"
      ],
      "title": "LowerFilter",
      "type": "object"
    },
    "NotEqualsFilter": {
      "properties": {
        "ne": {
          "title": "Ne"
        }
      },
      "required": [
        "ne"
      ],
      "title": "NotEqualsFilter",
      "type": "object"
    },
    "NotInFilter": {
      "properties": {
        "not_in": {
          "items": {},
          "title": "Not In",
          "type": "array"
        }
      },
      "required": [
        "not_in"
      ],
      "title": "NotInFilter",
      "type": "object"
    },
    "NotNullFilter": {
      "properties": {
        "not_null": {
          "title": "Not Null",
          "type": "boolean"
        }
      },
      "required": [
        "not_null"
      ],
      "title": "NotNullFilter",
      "type": "object"
    },
    "OrFilter": {
      "properties": {
        "or_": {
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/EqualsFilter"
              },
              {
                "$ref": "#/$defs/GreaterFilter"
              },
              {
                "$ref": "#/$defs/LowerFilter"
              },
              {
                "$ref": "#/$defs/NotEqualsFilter"
              },
              {
                "$ref": "#/$defs/InFilter"
              },
              {
                "$ref": "#/$defs/NotInFilter"
              },
              {
                "$ref": "#/$defs/LikeFilter"
              },
              {
                "$ref": "#/$defs/ILikeFilter"
              },
              {
                "$ref": "#/$defs/BetweenFilter"
              },
              {
                "$ref": "#/$defs/IsNullFilter"
              },
              {
                "$ref": "#/$defs/NotNullFilter"
              },
              {
                "$ref": "#/$defs/StartswithFilter"
              },
              {
                "$ref": "#/$defs/EndswithFilter"
              },
              {
                "$ref": "#/$defs/ContainsFilter"
              },
              {
                "$ref": "#/$defs/AndFilter"
              },
              {
                "$ref": "#/$defs/OrFilter"
              }
            ]
          },
          "title": "Or",
          "type": "array"
        }
      },
      "required": [
        "or_"
      ],
      "title": "OrFilter",
      "type": "object"
    },
    "StartswithFilter": {
      "properties": {
        "startswith": {
          "title": "Startswith",
          "type": "string"
        }
      },
      "required": [
        "startswith"
      ],
      "title": "StartswithFilter",
      "type": "object"
    }
  },
  "$ref": "#/$defs/OrFilter",
  "x-model-name": "OrFilter"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): OrFilter {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('OrFilter', 'Expected an object');
    }

    if (errors.length > 0) {
      throw new ValidationError('OrFilter', errors.join('; '));
    }

    return data as OrFilter;
  }

  safeValidate(data: any): { success: true; data: OrFilter } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('OrFilter', String(error)) };
    }
  }
}

/**
 * Base class for all deployment configurations.
 */
export class BaseDeploymentValidator extends BaseValidator<BaseDeployment> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Base class for all deployment configurations.",
  "properties": {},
  "title": "BaseDeployment",
  "type": "object",
  "x-model-name": "BaseDeployment"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): BaseDeployment {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('BaseDeployment', 'Expected an object');
    }

    if (errors.length > 0) {
      throw new ValidationError('BaseDeployment', errors.join('; '));
    }

    return data as BaseDeployment;
  }

  safeValidate(data: any): { success: true; data: BaseDeployment } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('BaseDeployment', String(error)) };
    }
  }
}

/**
 * User deployment configuration for creating users in the system.
 */
export class UserDeploymentValidator extends BaseValidator<UserDeployment> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "User deployment configuration for creating users in the system.",
  "properties": {
    "given_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User's given name",
      "title": "Given Name"
    },
    "family_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User's family name",
      "title": "Family Name"
    },
    "email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User's email address",
      "title": "Email"
    },
    "number": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User number/identifier (student ID)",
      "title": "Number"
    },
    "username": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Unique username",
      "title": "Username"
    },
    "user_type": {
      "default": "user",
      "description": "Type of user account (user or token)",
      "title": "User Type",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "description": "Additional user properties",
      "title": "Properties"
    },
    "password": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Initial password for the user",
      "title": "Password"
    },
    "roles": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "System roles to assign to the user",
      "title": "Roles"
    },
    "gitlab_username": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitLab username (if different from username)",
      "title": "Gitlab Username"
    },
    "gitlab_email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitLab email (if different from email)",
      "title": "Gitlab Email"
    }
  },
  "title": "UserDeployment",
  "type": "object",
  "x-model-name": "UserDeployment"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): UserDeployment {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('UserDeployment', 'Expected an object');
    }

    // Optional field: given_name
    if ('given_name' in data && data.given_name !== undefined && data.given_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: family_name
    if ('family_name' in data && data.family_name !== undefined && data.family_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: email
    if ('email' in data && data.email !== undefined && data.email !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: number
    if ('number' in data && data.number !== undefined && data.number !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: username
    if ('username' in data && data.username !== undefined && data.username !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: user_type
    if ('user_type' in data && data.user_type !== undefined && data.user_type !== null) {
      if (typeof data.user_type !== 'string') {
        errors.push('Field user_type must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: password
    if ('password' in data && data.password !== undefined && data.password !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: roles
    if ('roles' in data && data.roles !== undefined && data.roles !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: gitlab_username
    if ('gitlab_username' in data && data.gitlab_username !== undefined && data.gitlab_username !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: gitlab_email
    if ('gitlab_email' in data && data.gitlab_email !== undefined && data.gitlab_email !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('UserDeployment', errors.join('; '));
    }

    return data as UserDeployment;
  }

  safeValidate(data: any): { success: true; data: UserDeployment } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('UserDeployment', String(error)) };
    }
  }
}

/**
 * Account deployment configuration for external service accounts (e.g., GitLab).
 */
export class AccountDeploymentValidator extends BaseValidator<AccountDeployment> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Account deployment configuration for external service accounts (e.g., GitLab).",
  "properties": {
    "provider": {
      "description": "Account provider (e.g., 'gitlab', 'github')",
      "title": "Provider",
      "type": "string"
    },
    "type": {
      "description": "Account type (e.g., 'oauth', 'api_token')",
      "title": "Type",
      "type": "string"
    },
    "provider_account_id": {
      "description": "Account ID in the provider system",
      "title": "Provider Account Id",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "description": "Provider-specific account properties",
      "title": "Properties"
    },
    "access_token": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Access token for API access",
      "title": "Access Token"
    },
    "refresh_token": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Refresh token for token renewal",
      "title": "Refresh Token"
    },
    "gitlab_username": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitLab username",
      "title": "Gitlab Username"
    },
    "gitlab_email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitLab email",
      "title": "Gitlab Email"
    },
    "gitlab_user_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitLab user ID",
      "title": "Gitlab User Id"
    },
    "is_admin": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": false,
      "description": "Whether the GitLab user has admin privileges",
      "title": "Is Admin"
    },
    "can_create_group": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": true,
      "description": "Whether the user can create GitLab groups",
      "title": "Can Create Group"
    }
  },
  "required": [
    "provider",
    "type",
    "provider_account_id"
  ],
  "title": "AccountDeployment",
  "type": "object",
  "x-model-name": "AccountDeployment"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): AccountDeployment {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('AccountDeployment', 'Expected an object');
    }

    // Required field: provider
    if (!('provider' in data)) {
      errors.push('Missing required field: provider');
    } else {
      if (typeof data.provider !== 'string') {
        errors.push('Field provider must be a string');
      }
    }

    // Required field: type
    if (!('type' in data)) {
      errors.push('Missing required field: type');
    } else {
      if (typeof data.type !== 'string') {
        errors.push('Field type must be a string');
      }
    }

    // Required field: provider_account_id
    if (!('provider_account_id' in data)) {
      errors.push('Missing required field: provider_account_id');
    } else {
      if (typeof data.provider_account_id !== 'string') {
        errors.push('Field provider_account_id must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: access_token
    if ('access_token' in data && data.access_token !== undefined && data.access_token !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: refresh_token
    if ('refresh_token' in data && data.refresh_token !== undefined && data.refresh_token !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: gitlab_username
    if ('gitlab_username' in data && data.gitlab_username !== undefined && data.gitlab_username !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: gitlab_email
    if ('gitlab_email' in data && data.gitlab_email !== undefined && data.gitlab_email !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: gitlab_user_id
    if ('gitlab_user_id' in data && data.gitlab_user_id !== undefined && data.gitlab_user_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: is_admin
    if ('is_admin' in data && data.is_admin !== undefined && data.is_admin !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: can_create_group
    if ('can_create_group' in data && data.can_create_group !== undefined && data.can_create_group !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('AccountDeployment', errors.join('; '));
    }

    return data as AccountDeployment;
  }

  safeValidate(data: any): { success: true; data: AccountDeployment } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('AccountDeployment', String(error)) };
    }
  }
}

/**
 * Course member deployment configuration for assigning users to courses.
 */
export class CourseMemberDeploymentValidator extends BaseValidator<CourseMemberDeployment> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Course member deployment configuration for assigning users to courses.",
  "properties": {
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Direct course ID",
      "title": "Id"
    },
    "organization": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Organization path (e.g., 'kit')",
      "title": "Organization"
    },
    "course_family": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Course family path (e.g., 'prog')",
      "title": "Course Family"
    },
    "course": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Course path (e.g., 'prog1')",
      "title": "Course"
    },
    "role": {
      "default": "_student",
      "description": "Course role ID (e.g., '_student', '_tutor', '_lecturer')",
      "title": "Role",
      "type": "string"
    },
    "group": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Course group name or ID (required for students)",
      "title": "Group"
    }
  },
  "title": "CourseMemberDeployment",
  "type": "object",
  "x-model-name": "CourseMemberDeployment"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CourseMemberDeployment {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CourseMemberDeployment', 'Expected an object');
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: organization
    if ('organization' in data && data.organization !== undefined && data.organization !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_family
    if ('course_family' in data && data.course_family !== undefined && data.course_family !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course
    if ('course' in data && data.course !== undefined && data.course !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: role
    if ('role' in data && data.role !== undefined && data.role !== null) {
      if (typeof data.role !== 'string') {
        errors.push('Field role must be a string');
      }
    }

    // Optional field: group
    if ('group' in data && data.group !== undefined && data.group !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CourseMemberDeployment', errors.join('; '));
    }

    return data as CourseMemberDeployment;
  }

  safeValidate(data: any): { success: true; data: CourseMemberDeployment } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CourseMemberDeployment', String(error)) };
    }
  }
}

/**
 * Combined user and account deployment configuration.
 */
export class UserAccountDeploymentValidator extends BaseValidator<UserAccountDeployment> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "AccountDeployment": {
      "description": "Account deployment configuration for external service accounts (e.g., GitLab).",
      "properties": {
        "provider": {
          "description": "Account provider (e.g., 'gitlab', 'github')",
          "title": "Provider",
          "type": "string"
        },
        "type": {
          "description": "Account type (e.g., 'oauth', 'api_token')",
          "title": "Type",
          "type": "string"
        },
        "provider_account_id": {
          "description": "Account ID in the provider system",
          "title": "Provider Account Id",
          "type": "string"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Provider-specific account properties",
          "title": "Properties"
        },
        "access_token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Access token for API access",
          "title": "Access Token"
        },
        "refresh_token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Refresh token for token renewal",
          "title": "Refresh Token"
        },
        "gitlab_username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab username",
          "title": "Gitlab Username"
        },
        "gitlab_email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab email",
          "title": "Gitlab Email"
        },
        "gitlab_user_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab user ID",
          "title": "Gitlab User Id"
        },
        "is_admin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": false,
          "description": "Whether the GitLab user has admin privileges",
          "title": "Is Admin"
        },
        "can_create_group": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": true,
          "description": "Whether the user can create GitLab groups",
          "title": "Can Create Group"
        }
      },
      "required": [
        "provider",
        "type",
        "provider_account_id"
      ],
      "title": "AccountDeployment",
      "type": "object"
    },
    "CourseMemberDeployment": {
      "description": "Course member deployment configuration for assigning users to courses.",
      "properties": {
        "id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Direct course ID",
          "title": "Id"
        },
        "organization": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization path (e.g., 'kit')",
          "title": "Organization"
        },
        "course_family": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course family path (e.g., 'prog')",
          "title": "Course Family"
        },
        "course": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course path (e.g., 'prog1')",
          "title": "Course"
        },
        "role": {
          "default": "_student",
          "description": "Course role ID (e.g., '_student', '_tutor', '_lecturer')",
          "title": "Role",
          "type": "string"
        },
        "group": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course group name or ID (required for students)",
          "title": "Group"
        }
      },
      "title": "CourseMemberDeployment",
      "type": "object"
    },
    "UserDeployment": {
      "description": "User deployment configuration for creating users in the system.",
      "properties": {
        "given_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's family name",
          "title": "Family Name"
        },
        "email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's email address",
          "title": "Email"
        },
        "number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User number/identifier (student ID)",
          "title": "Number"
        },
        "username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Unique username",
          "title": "Username"
        },
        "user_type": {
          "default": "user",
          "description": "Type of user account (user or token)",
          "title": "User Type",
          "type": "string"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Additional user properties",
          "title": "Properties"
        },
        "password": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Initial password for the user",
          "title": "Password"
        },
        "roles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "System roles to assign to the user",
          "title": "Roles"
        },
        "gitlab_username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab username (if different from username)",
          "title": "Gitlab Username"
        },
        "gitlab_email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab email (if different from email)",
          "title": "Gitlab Email"
        }
      },
      "title": "UserDeployment",
      "type": "object"
    }
  },
  "description": "Combined user and account deployment configuration.",
  "properties": {
    "user": {
      "$ref": "#/$defs/UserDeployment",
      "description": "User configuration"
    },
    "accounts": {
      "description": "Associated external accounts",
      "items": {
        "$ref": "#/$defs/AccountDeployment"
      },
      "title": "Accounts",
      "type": "array"
    },
    "course_members": {
      "description": "Course memberships for this user",
      "items": {
        "$ref": "#/$defs/CourseMemberDeployment"
      },
      "title": "Course Members",
      "type": "array"
    }
  },
  "required": [
    "user"
  ],
  "title": "UserAccountDeployment",
  "type": "object",
  "x-model-name": "UserAccountDeployment"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): UserAccountDeployment {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('UserAccountDeployment', 'Expected an object');
    }

    // Required field: user
    if (!('user' in data)) {
      errors.push('Missing required field: user');
    } else {
      // Reference field - basic object check
      if (typeof data.user !== 'object') {
        errors.push('Field user must be an object');
      }
    }

    // Optional field: accounts
    if ('accounts' in data && data.accounts !== undefined && data.accounts !== null) {
      if (!Array.isArray(data.accounts)) {
        errors.push('Field accounts must be an array');
      }
    }

    // Optional field: course_members
    if ('course_members' in data && data.course_members !== undefined && data.course_members !== null) {
      if (!Array.isArray(data.course_members)) {
        errors.push('Field course_members must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('UserAccountDeployment', errors.join('; '));
    }

    return data as UserAccountDeployment;
  }

  safeValidate(data: any): { success: true; data: UserAccountDeployment } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('UserAccountDeployment', String(error)) };
    }
  }
}

/**
 * Configuration for deploying multiple users and their accounts.
 */
export class UsersDeploymentConfigValidator extends BaseValidator<UsersDeploymentConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "AccountDeployment": {
      "description": "Account deployment configuration for external service accounts (e.g., GitLab).",
      "properties": {
        "provider": {
          "description": "Account provider (e.g., 'gitlab', 'github')",
          "title": "Provider",
          "type": "string"
        },
        "type": {
          "description": "Account type (e.g., 'oauth', 'api_token')",
          "title": "Type",
          "type": "string"
        },
        "provider_account_id": {
          "description": "Account ID in the provider system",
          "title": "Provider Account Id",
          "type": "string"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Provider-specific account properties",
          "title": "Properties"
        },
        "access_token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Access token for API access",
          "title": "Access Token"
        },
        "refresh_token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Refresh token for token renewal",
          "title": "Refresh Token"
        },
        "gitlab_username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab username",
          "title": "Gitlab Username"
        },
        "gitlab_email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab email",
          "title": "Gitlab Email"
        },
        "gitlab_user_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab user ID",
          "title": "Gitlab User Id"
        },
        "is_admin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": false,
          "description": "Whether the GitLab user has admin privileges",
          "title": "Is Admin"
        },
        "can_create_group": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": true,
          "description": "Whether the user can create GitLab groups",
          "title": "Can Create Group"
        }
      },
      "required": [
        "provider",
        "type",
        "provider_account_id"
      ],
      "title": "AccountDeployment",
      "type": "object"
    },
    "CourseMemberDeployment": {
      "description": "Course member deployment configuration for assigning users to courses.",
      "properties": {
        "id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Direct course ID",
          "title": "Id"
        },
        "organization": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization path (e.g., 'kit')",
          "title": "Organization"
        },
        "course_family": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course family path (e.g., 'prog')",
          "title": "Course Family"
        },
        "course": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course path (e.g., 'prog1')",
          "title": "Course"
        },
        "role": {
          "default": "_student",
          "description": "Course role ID (e.g., '_student', '_tutor', '_lecturer')",
          "title": "Role",
          "type": "string"
        },
        "group": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course group name or ID (required for students)",
          "title": "Group"
        }
      },
      "title": "CourseMemberDeployment",
      "type": "object"
    },
    "UserAccountDeployment": {
      "description": "Combined user and account deployment configuration.",
      "properties": {
        "user": {
          "$ref": "#/$defs/UserDeployment",
          "description": "User configuration"
        },
        "accounts": {
          "description": "Associated external accounts",
          "items": {
            "$ref": "#/$defs/AccountDeployment"
          },
          "title": "Accounts",
          "type": "array"
        },
        "course_members": {
          "description": "Course memberships for this user",
          "items": {
            "$ref": "#/$defs/CourseMemberDeployment"
          },
          "title": "Course Members",
          "type": "array"
        }
      },
      "required": [
        "user"
      ],
      "title": "UserAccountDeployment",
      "type": "object"
    },
    "UserDeployment": {
      "description": "User deployment configuration for creating users in the system.",
      "properties": {
        "given_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's family name",
          "title": "Family Name"
        },
        "email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's email address",
          "title": "Email"
        },
        "number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User number/identifier (student ID)",
          "title": "Number"
        },
        "username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Unique username",
          "title": "Username"
        },
        "user_type": {
          "default": "user",
          "description": "Type of user account (user or token)",
          "title": "User Type",
          "type": "string"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Additional user properties",
          "title": "Properties"
        },
        "password": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Initial password for the user",
          "title": "Password"
        },
        "roles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "System roles to assign to the user",
          "title": "Roles"
        },
        "gitlab_username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab username (if different from username)",
          "title": "Gitlab Username"
        },
        "gitlab_email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab email (if different from email)",
          "title": "Gitlab Email"
        }
      },
      "title": "UserDeployment",
      "type": "object"
    }
  },
  "description": "Configuration for deploying multiple users and their accounts.",
  "properties": {
    "users": {
      "description": "List of users to deploy",
      "items": {
        "$ref": "#/$defs/UserAccountDeployment"
      },
      "title": "Users",
      "type": "array"
    }
  },
  "required": [
    "users"
  ],
  "title": "UsersDeploymentConfig",
  "type": "object",
  "x-model-name": "UsersDeploymentConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): UsersDeploymentConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('UsersDeploymentConfig', 'Expected an object');
    }

    // Required field: users
    if (!('users' in data)) {
      errors.push('Missing required field: users');
    } else {
      if (!Array.isArray(data.users)) {
        errors.push('Field users must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('UsersDeploymentConfig', errors.join('; '));
    }

    return data as UsersDeploymentConfig;
  }

  safeValidate(data: any): { success: true; data: UsersDeploymentConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('UsersDeploymentConfig', String(error)) };
    }
  }
}

/**
 * GitLab repository configuration.
 */
export class GitLabConfigValidator extends BaseValidator<GitLabConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "GitLab repository configuration.",
  "properties": {
    "url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitLab instance URL",
      "title": "Url"
    },
    "token": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitLab API token",
      "title": "Token"
    },
    "parent": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Parent group ID",
      "title": "Parent"
    },
    "full_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Full path in GitLab",
      "title": "Full Path"
    },
    "group_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitLab group ID",
      "title": "Group Id"
    },
    "parent_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Parent group ID",
      "title": "Parent Id"
    },
    "namespace_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Namespace ID",
      "title": "Namespace Id"
    },
    "namespace_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Namespace path",
      "title": "Namespace Path"
    },
    "web_url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Web URL",
      "title": "Web Url"
    },
    "visibility": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Visibility level",
      "title": "Visibility"
    },
    "last_synced_at": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Last sync timestamp",
      "title": "Last Synced At"
    }
  },
  "title": "GitLabConfig",
  "type": "object",
  "x-model-name": "GitLabConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GitLabConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GitLabConfig', 'Expected an object');
    }

    // Optional field: url
    if ('url' in data && data.url !== undefined && data.url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: token
    if ('token' in data && data.token !== undefined && data.token !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: parent
    if ('parent' in data && data.parent !== undefined && data.parent !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: full_path
    if ('full_path' in data && data.full_path !== undefined && data.full_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: group_id
    if ('group_id' in data && data.group_id !== undefined && data.group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: parent_id
    if ('parent_id' in data && data.parent_id !== undefined && data.parent_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: namespace_id
    if ('namespace_id' in data && data.namespace_id !== undefined && data.namespace_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: namespace_path
    if ('namespace_path' in data && data.namespace_path !== undefined && data.namespace_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: web_url
    if ('web_url' in data && data.web_url !== undefined && data.web_url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: visibility
    if ('visibility' in data && data.visibility !== undefined && data.visibility !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: last_synced_at
    if ('last_synced_at' in data && data.last_synced_at !== undefined && data.last_synced_at !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GitLabConfig', errors.join('; '));
    }

    return data as GitLabConfig;
  }

  safeValidate(data: any): { success: true; data: GitLabConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GitLabConfig', String(error)) };
    }
  }
}

/**
 * GitHub repository configuration (future support).
 */
export class GitHubConfigValidator extends BaseValidator<GitHubConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "GitHub repository configuration (future support).",
  "properties": {
    "url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitHub instance URL",
      "title": "Url"
    },
    "token": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitHub API token",
      "title": "Token"
    },
    "organization": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "GitHub organization",
      "title": "Organization"
    }
  },
  "title": "GitHubConfig",
  "type": "object",
  "x-model-name": "GitHubConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GitHubConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GitHubConfig', 'Expected an object');
    }

    // Optional field: url
    if ('url' in data && data.url !== undefined && data.url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: token
    if ('token' in data && data.token !== undefined && data.token !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: organization
    if ('organization' in data && data.organization !== undefined && data.organization !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GitHubConfig', errors.join('; '));
    }

    return data as GitHubConfig;
  }

  safeValidate(data: any): { success: true; data: GitHubConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GitHubConfig', String(error)) };
    }
  }
}

/**
 * Full execution backend configuration for defining backends at root level.
 */
export class ExecutionBackendConfigValidator extends BaseValidator<ExecutionBackendConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Full execution backend configuration for defining backends at root level.",
  "properties": {
    "slug": {
      "description": "Unique identifier for the backend",
      "title": "Slug",
      "type": "string"
    },
    "type": {
      "description": "Type of execution backend (e.g., temporal, prefect)",
      "title": "Type",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "description": "Backend-specific properties (e.g., task_queue, namespace, timeout settings)",
      "title": "Properties"
    }
  },
  "required": [
    "slug",
    "type"
  ],
  "title": "ExecutionBackendConfig",
  "type": "object",
  "x-model-name": "ExecutionBackendConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExecutionBackendConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExecutionBackendConfig', 'Expected an object');
    }

    // Required field: slug
    if (!('slug' in data)) {
      errors.push('Missing required field: slug');
    } else {
      if (typeof data.slug !== 'string') {
        errors.push('Field slug must be a string');
      }
    }

    // Required field: type
    if (!('type' in data)) {
      errors.push('Missing required field: type');
    } else {
      if (typeof data.type !== 'string') {
        errors.push('Field type must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExecutionBackendConfig', errors.join('; '));
    }

    return data as ExecutionBackendConfig;
  }

  safeValidate(data: any): { success: true; data: ExecutionBackendConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExecutionBackendConfig', String(error)) };
    }
  }
}

/**
 * Reference to an execution backend by slug for linking to courses.
 */
export class ExecutionBackendReferenceValidator extends BaseValidator<ExecutionBackendReference> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Reference to an execution backend by slug for linking to courses.",
  "properties": {
    "slug": {
      "description": "Slug of the execution backend to link",
      "title": "Slug",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "description": "Course-specific overrides for this backend (optional)",
      "title": "Properties"
    }
  },
  "required": [
    "slug"
  ],
  "title": "ExecutionBackendReference",
  "type": "object",
  "x-model-name": "ExecutionBackendReference"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExecutionBackendReference {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExecutionBackendReference', 'Expected an object');
    }

    // Required field: slug
    if (!('slug' in data)) {
      errors.push('Missing required field: slug');
    } else {
      if (typeof data.slug !== 'string') {
        errors.push('Field slug must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExecutionBackendReference', errors.join('; '));
    }

    return data as ExecutionBackendReference;
  }

  safeValidate(data: any): { success: true; data: ExecutionBackendReference } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExecutionBackendReference', String(error)) };
    }
  }
}

/**
 * Hierarchical deployment configuration for creating organization -> course family -> course structures.
    
    Supports deploying multiple organizations, each with multiple course families and courses.
 */
export class ComputorDeploymentConfigValidator extends BaseValidator<ComputorDeploymentConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "AccountDeployment": {
      "description": "Account deployment configuration for external service accounts (e.g., GitLab).",
      "properties": {
        "provider": {
          "description": "Account provider (e.g., 'gitlab', 'github')",
          "title": "Provider",
          "type": "string"
        },
        "type": {
          "description": "Account type (e.g., 'oauth', 'api_token')",
          "title": "Type",
          "type": "string"
        },
        "provider_account_id": {
          "description": "Account ID in the provider system",
          "title": "Provider Account Id",
          "type": "string"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Provider-specific account properties",
          "title": "Properties"
        },
        "access_token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Access token for API access",
          "title": "Access Token"
        },
        "refresh_token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Refresh token for token renewal",
          "title": "Refresh Token"
        },
        "gitlab_username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab username",
          "title": "Gitlab Username"
        },
        "gitlab_email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab email",
          "title": "Gitlab Email"
        },
        "gitlab_user_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab user ID",
          "title": "Gitlab User Id"
        },
        "is_admin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": false,
          "description": "Whether the GitLab user has admin privileges",
          "title": "Is Admin"
        },
        "can_create_group": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": true,
          "description": "Whether the user can create GitLab groups",
          "title": "Can Create Group"
        }
      },
      "required": [
        "provider",
        "type",
        "provider_account_id"
      ],
      "title": "AccountDeployment",
      "type": "object"
    },
    "CourseContentConfig": {
      "description": "Configuration for course content (assignments, units, etc.).",
      "properties": {
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Title of the course content (defaults from example if submittable)",
          "title": "Title"
        },
        "path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Hierarchical path using dots (optional; generated when omitted)",
          "title": "Path"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Description of the content",
          "title": "Description"
        },
        "content_type": {
          "description": "Slug of the course content type (must match a defined content_type)",
          "title": "Content Type",
          "type": "string"
        },
        "position": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Position for ordering (defaults to auto-increment)",
          "title": "Position"
        },
        "max_group_size": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Maximum group size for submissions",
          "title": "Max Group Size"
        },
        "max_test_runs": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Maximum test runs allowed",
          "title": "Max Test Runs"
        },
        "max_submissions": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Maximum submissions allowed",
          "title": "Max Submissions"
        },
        "example_identifier": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Example identifier (e.g., 'week1.fibonacci') - required for submittable content",
          "title": "Example Identifier"
        },
        "example_version_tag": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Version tag of the example (e.g., 'v1.0', 'latest') - defaults to latest",
          "title": "Example Version Tag"
        },
        "execution_backend": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Override execution backend slug for this content",
          "title": "Execution Backend"
        },
        "contents": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/CourseContentConfig"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "Nested course contents (for units containing assignments)",
          "title": "Contents"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Additional properties for the content",
          "title": "Properties"
        }
      },
      "required": [
        "content_type"
      ],
      "title": "CourseContentConfig",
      "type": "object"
    },
    "CourseContentTypeConfig": {
      "description": "Course content type configuration for deployment.",
      "properties": {
        "slug": {
          "description": "Unique identifier for the content type",
          "title": "Slug",
          "type": "string"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Display title for the content type",
          "title": "Title"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Description of the content type",
          "title": "Description"
        },
        "color": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "green",
          "description": "Display color (hex, rgb, hsl, or named color)",
          "title": "Color"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Additional properties",
          "title": "Properties"
        },
        "kind": {
          "description": "ID of the course content kind (e.g., 'assignment', 'unit')",
          "title": "Kind",
          "type": "string"
        }
      },
      "required": [
        "slug",
        "kind"
      ],
      "title": "CourseContentTypeConfig",
      "type": "object"
    },
    "CourseMemberDeployment": {
      "description": "Course member deployment configuration for assigning users to courses.",
      "properties": {
        "id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Direct course ID",
          "title": "Id"
        },
        "organization": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization path (e.g., 'kit')",
          "title": "Organization"
        },
        "course_family": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course family path (e.g., 'prog')",
          "title": "Course Family"
        },
        "course": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course path (e.g., 'prog1')",
          "title": "Course"
        },
        "role": {
          "default": "_student",
          "description": "Course role ID (e.g., '_student', '_tutor', '_lecturer')",
          "title": "Role",
          "type": "string"
        },
        "group": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course group name or ID (required for students)",
          "title": "Group"
        }
      },
      "title": "CourseMemberDeployment",
      "type": "object"
    },
    "CourseProjects": {
      "description": "Configuration for course-related GitLab projects.",
      "properties": {
        "tests": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "tests",
          "description": "Path for tests project",
          "title": "Tests"
        },
        "student_template": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "student-template",
          "description": "Path for student template project",
          "title": "Student Template"
        },
        "reference": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "reference",
          "description": "Path for reference solution project",
          "title": "Reference"
        },
        "examples": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "examples",
          "description": "Path for examples project",
          "title": "Examples"
        },
        "documents": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "documents",
          "description": "Path for documents project",
          "title": "Documents"
        }
      },
      "title": "CourseProjects",
      "type": "object"
    },
    "ExamplesUploadConfig": {
      "properties": {
        "repository": {
          "description": "Name of the Example Repository to use/create",
          "title": "Repository",
          "type": "string"
        },
        "path": {
          "description": "Relative path to directory containing example subdirectories",
          "title": "Path",
          "type": "string"
        }
      },
      "required": [
        "repository",
        "path"
      ],
      "title": "ExamplesUploadConfig",
      "type": "object"
    },
    "ExecutionBackendConfig": {
      "description": "Full execution backend configuration for defining backends at root level.",
      "properties": {
        "slug": {
          "description": "Unique identifier for the backend",
          "title": "Slug",
          "type": "string"
        },
        "type": {
          "description": "Type of execution backend (e.g., temporal, prefect)",
          "title": "Type",
          "type": "string"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Backend-specific properties (e.g., task_queue, namespace, timeout settings)",
          "title": "Properties"
        }
      },
      "required": [
        "slug",
        "type"
      ],
      "title": "ExecutionBackendConfig",
      "type": "object"
    },
    "ExecutionBackendReference": {
      "description": "Reference to an execution backend by slug for linking to courses.",
      "properties": {
        "slug": {
          "description": "Slug of the execution backend to link",
          "title": "Slug",
          "type": "string"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Course-specific overrides for this backend (optional)",
          "title": "Properties"
        }
      },
      "required": [
        "slug"
      ],
      "title": "ExecutionBackendReference",
      "type": "object"
    },
    "ExtensionUploadConfig": {
      "properties": {
        "path": {
          "description": "Relative path to the .vsix package to upload",
          "title": "Path",
          "type": "string"
        },
        "publisher": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Override publisher (defaults to manifest)",
          "title": "Publisher"
        },
        "name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Override extension name (defaults to manifest)",
          "title": "Name"
        },
        "display_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Override display name stored in metadata",
          "title": "Display Name"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Override description stored in metadata",
          "title": "Description"
        },
        "engine_range": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Override VS Code engine compatibility range",
          "title": "Engine Range"
        }
      },
      "required": [
        "path"
      ],
      "title": "ExtensionUploadConfig",
      "type": "object"
    },
    "GitHubConfig": {
      "description": "GitHub repository configuration (future support).",
      "properties": {
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitHub instance URL",
          "title": "Url"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitHub API token",
          "title": "Token"
        },
        "organization": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitHub organization",
          "title": "Organization"
        }
      },
      "title": "GitHubConfig",
      "type": "object"
    },
    "GitLabConfig": {
      "description": "GitLab repository configuration.",
      "properties": {
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab instance URL",
          "title": "Url"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab API token",
          "title": "Token"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Parent group ID",
          "title": "Parent"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Full path in GitLab",
          "title": "Full Path"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab group ID",
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Parent group ID",
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Namespace ID",
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Namespace path",
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Web URL",
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Visibility level",
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Last sync timestamp",
          "title": "Last Synced At"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "HierarchicalCourseConfig": {
      "description": "Course configuration for hierarchical deployment.",
      "properties": {
        "name": {
          "description": "Course display name",
          "title": "Name",
          "type": "string"
        },
        "path": {
          "description": "Course path/slug",
          "title": "Path",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course description",
          "title": "Description"
        },
        "projects": {
          "anyOf": [
            {
              "$ref": "#/$defs/CourseProjects"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course project structure"
        },
        "execution_backends": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/ExecutionBackendReference"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "References to execution backends to link to this course (by slug)",
          "title": "Execution Backends"
        },
        "content_types": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/CourseContentTypeConfig"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "Course content types to be created (assignments, units, etc.)",
          "title": "Content Types"
        },
        "contents": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/CourseContentConfig"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "Course contents hierarchy (assignments, units, etc.)",
          "title": "Contents"
        },
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Course-specific settings",
          "title": "Settings"
        }
      },
      "required": [
        "name",
        "path"
      ],
      "title": "HierarchicalCourseConfig",
      "type": "object"
    },
    "HierarchicalCourseFamilyConfig": {
      "description": "Course family configuration with nested courses.",
      "properties": {
        "name": {
          "description": "Course family display name",
          "title": "Name",
          "type": "string"
        },
        "path": {
          "description": "Course family path/slug",
          "title": "Path",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Course family description",
          "title": "Description"
        },
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Course family-specific settings",
          "title": "Settings"
        },
        "courses": {
          "description": "List of courses in this course family",
          "items": {
            "$ref": "#/$defs/HierarchicalCourseConfig"
          },
          "title": "Courses",
          "type": "array"
        }
      },
      "required": [
        "name",
        "path"
      ],
      "title": "HierarchicalCourseFamilyConfig",
      "type": "object"
    },
    "HierarchicalOrganizationConfig": {
      "description": "Organization configuration with nested course families.",
      "properties": {
        "name": {
          "description": "Organization display name",
          "title": "Name",
          "type": "string"
        },
        "path": {
          "description": "Organization path/slug",
          "title": "Path",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization description",
          "title": "Description"
        },
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Organization-specific settings",
          "title": "Settings"
        },
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab configuration"
        },
        "github": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitHubConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitHub configuration (future)"
        },
        "course_families": {
          "description": "List of course families in this organization",
          "items": {
            "$ref": "#/$defs/HierarchicalCourseFamilyConfig"
          },
          "title": "Course Families",
          "type": "array"
        }
      },
      "required": [
        "name",
        "path"
      ],
      "title": "HierarchicalOrganizationConfig",
      "type": "object"
    },
    "UserAccountDeployment": {
      "description": "Combined user and account deployment configuration.",
      "properties": {
        "user": {
          "$ref": "#/$defs/UserDeployment",
          "description": "User configuration"
        },
        "accounts": {
          "description": "Associated external accounts",
          "items": {
            "$ref": "#/$defs/AccountDeployment"
          },
          "title": "Accounts",
          "type": "array"
        },
        "course_members": {
          "description": "Course memberships for this user",
          "items": {
            "$ref": "#/$defs/CourseMemberDeployment"
          },
          "title": "Course Members",
          "type": "array"
        }
      },
      "required": [
        "user"
      ],
      "title": "UserAccountDeployment",
      "type": "object"
    },
    "UserDeployment": {
      "description": "User deployment configuration for creating users in the system.",
      "properties": {
        "given_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's family name",
          "title": "Family Name"
        },
        "email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's email address",
          "title": "Email"
        },
        "number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User number/identifier (student ID)",
          "title": "Number"
        },
        "username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Unique username",
          "title": "Username"
        },
        "user_type": {
          "default": "user",
          "description": "Type of user account (user or token)",
          "title": "User Type",
          "type": "string"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "description": "Additional user properties",
          "title": "Properties"
        },
        "password": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Initial password for the user",
          "title": "Password"
        },
        "roles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "System roles to assign to the user",
          "title": "Roles"
        },
        "gitlab_username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab username (if different from username)",
          "title": "Gitlab Username"
        },
        "gitlab_email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "GitLab email (if different from email)",
          "title": "Gitlab Email"
        }
      },
      "title": "UserDeployment",
      "type": "object"
    }
  },
  "description": "Hierarchical deployment configuration for creating organization -> course family -> course structures.\\n    \\n    Supports deploying multiple organizations, each with multiple course families and courses.",
  "properties": {
    "execution_backends": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/ExecutionBackendConfig"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "List of execution backends to create or ensure exist in the system",
      "title": "Execution Backends"
    },
    "organizations": {
      "description": "List of organizations with nested course families and courses",
      "items": {
        "$ref": "#/$defs/HierarchicalOrganizationConfig"
      },
      "title": "Organizations",
      "type": "array"
    },
    "users": {
      "description": "List of users with their accounts and course memberships",
      "items": {
        "$ref": "#/$defs/UserAccountDeployment"
      },
      "title": "Users",
      "type": "array"
    },
    "settings": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "description": "Global deployment settings",
      "title": "Settings"
    },
    "extensions_upload": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/ExtensionUploadConfig"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Optional list of VSIX packages to upload before deployment",
      "title": "Extensions Upload"
    },
    "examples_upload": {
      "anyOf": [
        {
          "$ref": "#/$defs/ExamplesUploadConfig"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "If provided, uploads examples before hierarchy deployment"
    }
  },
  "title": "ComputorDeploymentConfig",
  "type": "object",
  "x-model-name": "ComputorDeploymentConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ComputorDeploymentConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ComputorDeploymentConfig', 'Expected an object');
    }

    // Optional field: execution_backends
    if ('execution_backends' in data && data.execution_backends !== undefined && data.execution_backends !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: organizations
    if ('organizations' in data && data.organizations !== undefined && data.organizations !== null) {
      if (!Array.isArray(data.organizations)) {
        errors.push('Field organizations must be an array');
      }
    }

    // Optional field: users
    if ('users' in data && data.users !== undefined && data.users !== null) {
      if (!Array.isArray(data.users)) {
        errors.push('Field users must be an array');
      }
    }

    // Optional field: settings
    if ('settings' in data && data.settings !== undefined && data.settings !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: extensions_upload
    if ('extensions_upload' in data && data.extensions_upload !== undefined && data.extensions_upload !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: examples_upload
    if ('examples_upload' in data && data.examples_upload !== undefined && data.examples_upload !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ComputorDeploymentConfig', errors.join('; '));
    }

    return data as ComputorDeploymentConfig;
  }

  safeValidate(data: any): { success: true; data: ComputorDeploymentConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ComputorDeploymentConfig', String(error)) };
    }
  }
}

/**
 * Validator for ExtensionUploadConfig
 */
export class ExtensionUploadConfigValidator extends BaseValidator<ExtensionUploadConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "path": {
      "description": "Relative path to the .vsix package to upload",
      "title": "Path",
      "type": "string"
    },
    "publisher": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Override publisher (defaults to manifest)",
      "title": "Publisher"
    },
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Override extension name (defaults to manifest)",
      "title": "Name"
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Override display name stored in metadata",
      "title": "Display Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Override description stored in metadata",
      "title": "Description"
    },
    "engine_range": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Override VS Code engine compatibility range",
      "title": "Engine Range"
    }
  },
  "required": [
    "path"
  ],
  "title": "ExtensionUploadConfig",
  "type": "object",
  "x-model-name": "ExtensionUploadConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionUploadConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionUploadConfig', 'Expected an object');
    }

    // Required field: path
    if (!('path' in data)) {
      errors.push('Missing required field: path');
    } else {
      if (typeof data.path !== 'string') {
        errors.push('Field path must be a string');
      }
    }

    // Optional field: publisher
    if ('publisher' in data && data.publisher !== undefined && data.publisher !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: engine_range
    if ('engine_range' in data && data.engine_range !== undefined && data.engine_range !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionUploadConfig', errors.join('; '));
    }

    return data as ExtensionUploadConfig;
  }

  safeValidate(data: any): { success: true; data: ExtensionUploadConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionUploadConfig', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupProperties
 */
export class SubmissionGroupPropertiesValidator extends BaseValidator<SubmissionGroupProperties> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    }
  },
  "additionalProperties": true,
  "properties": {
    "gitlab": {
      "anyOf": [
        {
          "$ref": "#/$defs/GitLabConfig"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "title": "SubmissionGroupProperties",
  "type": "object",
  "x-model-name": "SubmissionGroupProperties"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupProperties {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupProperties', 'Expected an object');
    }

    // Optional field: gitlab
    if ('gitlab' in data && data.gitlab !== undefined && data.gitlab !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupProperties', errors.join('; '));
    }

    return data as SubmissionGroupProperties;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupProperties } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupProperties', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupCreate
 */
export class SubmissionGroupCreateValidator extends BaseValidator<SubmissionGroupCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupProperties",
      "type": "object"
    }
  },
  "properties": {
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Display Name"
    },
    "max_group_size": {
      "default": 1,
      "title": "Max Group Size",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    }
  },
  "required": [
    "course_content_id"
  ],
  "title": "SubmissionGroupCreate",
  "type": "object",
  "x-model-name": "SubmissionGroupCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupCreate', 'Expected an object');
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_group_size
    if ('max_group_size' in data && data.max_group_size !== undefined && data.max_group_size !== null) {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupCreate', errors.join('; '));
    }

    return data as SubmissionGroupCreate;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupCreate', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupGet
 */
export class SubmissionGroupGetValidator extends BaseValidator<SubmissionGroupGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupProperties",
      "type": "object"
    }
  },
  "properties": {
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Display Name"
    },
    "max_group_size": {
      "default": 1,
      "title": "Max Group Size",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    },
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "last_submitted_result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Submitted Result Id"
    }
  },
  "required": [
    "course_content_id",
    "id",
    "course_id"
  ],
  "title": "SubmissionGroupGet",
  "type": "object",
  "x-model-name": "SubmissionGroupGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupGet', 'Expected an object');
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_group_size
    if ('max_group_size' in data && data.max_group_size !== undefined && data.max_group_size !== null) {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Optional field: last_submitted_result_id
    if ('last_submitted_result_id' in data && data.last_submitted_result_id !== undefined && data.last_submitted_result_id !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupGet', errors.join('; '));
    }

    return data as SubmissionGroupGet;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupGet', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupList
 */
export class SubmissionGroupListValidator extends BaseValidator<SubmissionGroupList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupProperties",
      "type": "object"
    }
  },
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Display Name"
    },
    "max_group_size": {
      "title": "Max Group Size",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    },
    "last_submitted_result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Submitted Result Id"
    }
  },
  "required": [
    "id",
    "max_group_size",
    "course_id",
    "course_content_id"
  ],
  "title": "SubmissionGroupList",
  "type": "object",
  "x-model-name": "SubmissionGroupList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupList', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: max_group_size
    if (!('max_group_size' in data)) {
      errors.push('Missing required field: max_group_size');
    } else {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: last_submitted_result_id
    if ('last_submitted_result_id' in data && data.last_submitted_result_id !== undefined && data.last_submitted_result_id !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupList', errors.join('; '));
    }

    return data as SubmissionGroupList;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupList', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupUpdate
 */
export class SubmissionGroupUpdateValidator extends BaseValidator<SubmissionGroupUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupProperties",
      "type": "object"
    }
  },
  "properties": {
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Display Name"
    },
    "max_group_size": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Group Size"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    }
  },
  "title": "SubmissionGroupUpdate",
  "type": "object",
  "x-model-name": "SubmissionGroupUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupUpdate', 'Expected an object');
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_group_size
    if ('max_group_size' in data && data.max_group_size !== undefined && data.max_group_size !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupUpdate', errors.join('; '));
    }

    return data as SubmissionGroupUpdate;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupUpdate', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupQuery
 */
export class SubmissionGroupQueryValidator extends BaseValidator<SubmissionGroupQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupProperties",
      "type": "object"
    }
  },
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Display Name"
    },
    "max_group_size": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Group Size"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "course_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Id"
    },
    "course_content_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Id"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    }
  },
  "title": "SubmissionGroupQuery",
  "type": "object",
  "x-model-name": "SubmissionGroupQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_group_size
    if ('max_group_size' in data && data.max_group_size !== undefined && data.max_group_size !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_id
    if ('course_id' in data && data.course_id !== undefined && data.course_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_id
    if ('course_content_id' in data && data.course_content_id !== undefined && data.course_content_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupQuery', errors.join('; '));
    }

    return data as SubmissionGroupQuery;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupQuery', String(error)) };
    }
  }
}

/**
 * Query parameters for student submission groups
 */
export class SubmissionGroupStudentQueryValidator extends BaseValidator<SubmissionGroupStudentQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Query parameters for student submission groups",
  "properties": {
    "course_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Id"
    },
    "course_content_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Id"
    },
    "has_repository": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Has Repository"
    },
    "is_graded": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Is Graded"
    }
  },
  "title": "SubmissionGroupStudentQuery",
  "type": "object",
  "x-model-name": "SubmissionGroupStudentQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupStudentQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupStudentQuery', 'Expected an object');
    }

    // Optional field: course_id
    if ('course_id' in data && data.course_id !== undefined && data.course_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_id
    if ('course_content_id' in data && data.course_content_id !== undefined && data.course_content_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: has_repository
    if ('has_repository' in data && data.has_repository !== undefined && data.has_repository !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: is_graded
    if ('is_graded' in data && data.is_graded !== undefined && data.is_graded !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupStudentQuery', errors.join('; '));
    }

    return data as SubmissionGroupStudentQuery;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupStudentQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupStudentQuery', String(error)) };
    }
  }
}

/**
 * Submission group with latest grading information.
 */
export class SubmissionGroupWithGradingValidator extends BaseValidator<SubmissionGroupWithGrading> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupProperties",
      "type": "object"
    }
  },
  "description": "Submission group with latest grading information.",
  "properties": {
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Display Name"
    },
    "max_group_size": {
      "default": 1,
      "title": "Max Group Size",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    },
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "last_submitted_result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Submitted Result Id"
    },
    "latest_grading": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Latest Grading"
    },
    "grading_count": {
      "default": 0,
      "title": "Grading Count",
      "type": "integer"
    },
    "last_submitted_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Submitted At"
    }
  },
  "required": [
    "course_content_id",
    "id",
    "course_id"
  ],
  "title": "SubmissionGroupWithGrading",
  "type": "object",
  "x-model-name": "SubmissionGroupWithGrading"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupWithGrading {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupWithGrading', 'Expected an object');
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_group_size
    if ('max_group_size' in data && data.max_group_size !== undefined && data.max_group_size !== null) {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Optional field: last_submitted_result_id
    if ('last_submitted_result_id' in data && data.last_submitted_result_id !== undefined && data.last_submitted_result_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: latest_grading
    if ('latest_grading' in data && data.latest_grading !== undefined && data.latest_grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grading_count
    if ('grading_count' in data && data.grading_count !== undefined && data.grading_count !== null) {
      if (typeof data.grading_count !== 'number') {
        errors.push('Field grading_count must be a number');
      }
    }

    // Optional field: last_submitted_at
    if ('last_submitted_at' in data && data.last_submitted_at !== undefined && data.last_submitted_at !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupWithGrading', errors.join('; '));
    }

    return data as SubmissionGroupWithGrading;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupWithGrading } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupWithGrading', String(error)) };
    }
  }
}

/**
 * Detailed submission group information including members and gradings.
 */
export class SubmissionGroupDetailedValidator extends BaseValidator<SubmissionGroupDetailed> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    },
    "SubmissionGroupProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupProperties",
      "type": "object"
    }
  },
  "description": "Detailed submission group information including members and gradings.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Display Name"
    },
    "max_group_size": {
      "title": "Max Group Size",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "max_test_runs": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Test Runs"
    },
    "members": {
      "default": [],
      "items": {
        "additionalProperties": true,
        "type": "object"
      },
      "title": "Members",
      "type": "array"
    },
    "gradings": {
      "default": [],
      "items": {
        "additionalProperties": true,
        "type": "object"
      },
      "title": "Gradings",
      "type": "array"
    },
    "last_submitted_result": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Submitted Result"
    },
    "current_group_size": {
      "default": 0,
      "title": "Current Group Size",
      "type": "integer"
    },
    "submission_count": {
      "default": 0,
      "title": "Submission Count",
      "type": "integer"
    },
    "test_run_count": {
      "default": 0,
      "title": "Test Run Count",
      "type": "integer"
    },
    "latest_grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Latest Grade"
    },
    "latest_grading_status": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradingStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "format": "date-time",
      "title": "Updated At",
      "type": "string"
    }
  },
  "required": [
    "id",
    "course_id",
    "course_content_id",
    "max_group_size",
    "created_at",
    "updated_at"
  ],
  "title": "SubmissionGroupDetailed",
  "type": "object",
  "x-model-name": "SubmissionGroupDetailed"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupDetailed {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupDetailed', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: max_group_size
    if (!('max_group_size' in data)) {
      errors.push('Missing required field: max_group_size');
    } else {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_test_runs
    if ('max_test_runs' in data && data.max_test_runs !== undefined && data.max_test_runs !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: members
    if ('members' in data && data.members !== undefined && data.members !== null) {
      if (!Array.isArray(data.members)) {
        errors.push('Field members must be an array');
      }
    }

    // Optional field: gradings
    if ('gradings' in data && data.gradings !== undefined && data.gradings !== null) {
      if (!Array.isArray(data.gradings)) {
        errors.push('Field gradings must be an array');
      }
    }

    // Optional field: last_submitted_result
    if ('last_submitted_result' in data && data.last_submitted_result !== undefined && data.last_submitted_result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: current_group_size
    if ('current_group_size' in data && data.current_group_size !== undefined && data.current_group_size !== null) {
      if (typeof data.current_group_size !== 'number') {
        errors.push('Field current_group_size must be a number');
      }
    }

    // Optional field: submission_count
    if ('submission_count' in data && data.submission_count !== undefined && data.submission_count !== null) {
      if (typeof data.submission_count !== 'number') {
        errors.push('Field submission_count must be a number');
      }
    }

    // Optional field: test_run_count
    if ('test_run_count' in data && data.test_run_count !== undefined && data.test_run_count !== null) {
      if (typeof data.test_run_count !== 'number') {
        errors.push('Field test_run_count must be a number');
      }
    }

    // Optional field: latest_grade
    if ('latest_grade' in data && data.latest_grade !== undefined && data.latest_grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: latest_grading_status
    if ('latest_grading_status' in data && data.latest_grading_status !== undefined && data.latest_grading_status !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: updated_at
    if (!('updated_at' in data)) {
      errors.push('Missing required field: updated_at');
    } else {
      if (typeof data.updated_at !== 'string') {
        errors.push('Field updated_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupDetailed', errors.join('; '));
    }

    return data as SubmissionGroupDetailed;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupDetailed } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupDetailed', String(error)) };
    }
  }
}

/**
 * Validator for StudentTemplateSettings
 */
export class StudentTemplateSettingsValidator extends BaseValidator<StudentTemplateSettings> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "MergeMethod": {
      "enum": [
        "rebase_merge",
        "merge",
        "ff"
      ],
      "title": "MergeMethod",
      "type": "string"
    }
  },
  "properties": {
    "mr_default_target_self": {
      "default": true,
      "title": "Mr Default Target Self",
      "type": "boolean"
    },
    "merge_method": {
      "$ref": "#/$defs/MergeMethod",
      "default": "rebase_merge"
    },
    "only_allow_merge_if_pipeline_succeeds": {
      "default": true,
      "title": "Only Allow Merge If Pipeline Succeeds",
      "type": "boolean"
    },
    "only_allow_merge_if_all_discussions_are_resolved": {
      "default": true,
      "title": "Only Allow Merge If All Discussions Are Resolved",
      "type": "boolean"
    }
  },
  "title": "StudentTemplateSettings",
  "type": "object",
  "x-model-name": "StudentTemplateSettings"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StudentTemplateSettings {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StudentTemplateSettings', 'Expected an object');
    }

    // Optional field: mr_default_target_self
    if ('mr_default_target_self' in data && data.mr_default_target_self !== undefined && data.mr_default_target_self !== null) {
      if (typeof data.mr_default_target_self !== 'boolean') {
        errors.push('Field mr_default_target_self must be a boolean');
      }
    }

    // Optional field: merge_method
    if ('merge_method' in data && data.merge_method !== undefined && data.merge_method !== null) {
      // Reference field - basic object check
      if (typeof data.merge_method !== 'object') {
        errors.push('Field merge_method must be an object');
      }
    }

    // Optional field: only_allow_merge_if_pipeline_succeeds
    if ('only_allow_merge_if_pipeline_succeeds' in data && data.only_allow_merge_if_pipeline_succeeds !== undefined && data.only_allow_merge_if_pipeline_succeeds !== null) {
      if (typeof data.only_allow_merge_if_pipeline_succeeds !== 'boolean') {
        errors.push('Field only_allow_merge_if_pipeline_succeeds must be a boolean');
      }
    }

    // Optional field: only_allow_merge_if_all_discussions_are_resolved
    if ('only_allow_merge_if_all_discussions_are_resolved' in data && data.only_allow_merge_if_all_discussions_are_resolved !== undefined && data.only_allow_merge_if_all_discussions_are_resolved !== null) {
      if (typeof data.only_allow_merge_if_all_discussions_are_resolved !== 'boolean') {
        errors.push('Field only_allow_merge_if_all_discussions_are_resolved must be a boolean');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('StudentTemplateSettings', errors.join('; '));
    }

    return data as StudentTemplateSettings;
  }

  safeValidate(data: any): { success: true; data: StudentTemplateSettings } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StudentTemplateSettings', String(error)) };
    }
  }
}

/**
 * Represents a test dependency with slug and version constraint.
 */
export class TestDependencyValidator extends BaseValidator<TestDependency> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Represents a test dependency with slug and version constraint.",
  "properties": {
    "slug": {
      "description": "Hierarchical slug of the dependency example (e.g., 'physics.math.vectors')",
      "title": "Slug",
      "type": "string"
    },
    "version": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Version constraint (e.g., '>=1.2.0', '^2.1.0', '1.0.0'). If not specified, uses latest version.",
      "title": "Version"
    }
  },
  "required": [
    "slug"
  ],
  "title": "TestDependency",
  "type": "object",
  "x-model-name": "TestDependency"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TestDependency {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TestDependency', 'Expected an object');
    }

    // Required field: slug
    if (!('slug' in data)) {
      errors.push('Missing required field: slug');
    } else {
      if (typeof data.slug !== 'string') {
        errors.push('Field slug must be a string');
      }
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TestDependency', errors.join('; '));
    }

    return data as TestDependency;
  }

  safeValidate(data: any): { success: true; data: TestDependency } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TestDependency', String(error)) };
    }
  }
}

/**
 * Base class for all CodeAbility meta models.
 */
export class CodeAbilityBaseValidator extends BaseValidator<CodeAbilityBase> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Base class for all CodeAbility meta models.",
  "properties": {},
  "title": "CodeAbilityBase",
  "type": "object",
  "x-model-name": "CodeAbilityBase"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityBase {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityBase', 'Expected an object');
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityBase', errors.join('; '));
    }

    return data as CodeAbilityBase;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityBase } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityBase', String(error)) };
    }
  }
}

/**
 * Link to external resources.
 */
export class CodeAbilityLinkValidator extends BaseValidator<CodeAbilityLink> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Link to external resources.",
  "properties": {
    "description": {
      "description": "Description of the link",
      "minLength": 0,
      "title": "Description",
      "type": "string"
    },
    "url": {
      "description": "URL of the link",
      "minLength": 1,
      "title": "Url",
      "type": "string"
    }
  },
  "required": [
    "description",
    "url"
  ],
  "title": "CodeAbilityLink",
  "type": "object",
  "x-model-name": "CodeAbilityLink"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityLink {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityLink', 'Expected an object');
    }

    // Required field: description
    if (!('description' in data)) {
      errors.push('Missing required field: description');
    } else {
      if (typeof data.description !== 'string') {
        errors.push('Field description must be a string');
      }
    }

    // Required field: url
    if (!('url' in data)) {
      errors.push('Missing required field: url');
    } else {
      if (typeof data.url !== 'string') {
        errors.push('Field url must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityLink', errors.join('; '));
    }

    return data as CodeAbilityLink;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityLink } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityLink', String(error)) };
    }
  }
}

/**
 * Person information for authors/maintainers.
 */
export class CodeAbilityPersonValidator extends BaseValidator<CodeAbilityPerson> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Person information for authors/maintainers.",
  "properties": {
    "name": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Full name",
      "title": "Name"
    },
    "email": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Email address",
      "title": "Email"
    },
    "affiliation": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Institutional affiliation",
      "title": "Affiliation"
    }
  },
  "title": "CodeAbilityPerson",
  "type": "object",
  "x-model-name": "CodeAbilityPerson"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityPerson {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityPerson', 'Expected an object');
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: email
    if ('email' in data && data.email !== undefined && data.email !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: affiliation
    if ('affiliation' in data && data.affiliation !== undefined && data.affiliation !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityPerson', errors.join('; '));
    }

    return data as CodeAbilityPerson;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityPerson } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityPerson', String(error)) };
    }
  }
}

/**
 * Properties specific to assignment-level meta.
 */
export class CodeAbilityMetaPropertiesValidator extends BaseValidator<CodeAbilityMetaProperties> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CourseExecutionBackendConfig": {
      "description": "Configuration for course execution backend.",
      "properties": {
        "slug": {
          "description": "Unique identifier for the execution backend",
          "title": "Slug",
          "type": "string"
        },
        "version": {
          "description": "Version of the execution backend (e.g., 'r2024b', 'v1.0')",
          "title": "Version",
          "type": "string"
        },
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Backend-specific settings",
          "title": "Settings"
        }
      },
      "required": [
        "slug",
        "version"
      ],
      "title": "CourseExecutionBackendConfig",
      "type": "object"
    },
    "TestDependency": {
      "description": "Represents a test dependency with slug and version constraint.",
      "properties": {
        "slug": {
          "description": "Hierarchical slug of the dependency example (e.g., 'physics.math.vectors')",
          "title": "Slug",
          "type": "string"
        },
        "version": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Version constraint (e.g., '>=1.2.0', '^2.1.0', '1.0.0'). If not specified, uses latest version.",
          "title": "Version"
        }
      },
      "required": [
        "slug"
      ],
      "title": "TestDependency",
      "type": "object"
    }
  },
  "description": "Properties specific to assignment-level meta.",
  "properties": {
    "studentSubmissionFiles": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Files that students must submit",
      "title": "Studentsubmissionfiles"
    },
    "additionalFiles": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Additional files provided to students",
      "title": "Additionalfiles"
    },
    "testFiles": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Test files for automated grading",
      "title": "Testfiles"
    },
    "studentTemplates": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Template files for student projects",
      "title": "Studenttemplates"
    },
    "testDependencies": {
      "anyOf": [
        {
          "items": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/$defs/TestDependency"
              }
            ]
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "List of example dependencies. Can be simple strings (slugs) or objects with slug and version constraints",
      "title": "Testdependencies"
    },
    "executionBackend": {
      "anyOf": [
        {
          "$ref": "#/$defs/CourseExecutionBackendConfig"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Execution backend configuration for this assignment"
    }
  },
  "title": "CodeAbilityMetaProperties",
  "type": "object",
  "x-model-name": "CodeAbilityMetaProperties"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityMetaProperties {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityMetaProperties', 'Expected an object');
    }

    // Optional field: studentSubmissionFiles
    if ('studentSubmissionFiles' in data && data.studentSubmissionFiles !== undefined && data.studentSubmissionFiles !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: additionalFiles
    if ('additionalFiles' in data && data.additionalFiles !== undefined && data.additionalFiles !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: testFiles
    if ('testFiles' in data && data.testFiles !== undefined && data.testFiles !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: studentTemplates
    if ('studentTemplates' in data && data.studentTemplates !== undefined && data.studentTemplates !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: testDependencies
    if ('testDependencies' in data && data.testDependencies !== undefined && data.testDependencies !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: executionBackend
    if ('executionBackend' in data && data.executionBackend !== undefined && data.executionBackend !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityMetaProperties', errors.join('; '));
    }

    return data as CodeAbilityMetaProperties;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityMetaProperties } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityMetaProperties', String(error)) };
    }
  }
}

/**
 * Meta information for assignments/examples.
 */
export class CodeAbilityMetaValidator extends BaseValidator<CodeAbilityMeta> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityLink": {
      "description": "Link to external resources.",
      "properties": {
        "description": {
          "description": "Description of the link",
          "minLength": 0,
          "title": "Description",
          "type": "string"
        },
        "url": {
          "description": "URL of the link",
          "minLength": 1,
          "title": "Url",
          "type": "string"
        }
      },
      "required": [
        "description",
        "url"
      ],
      "title": "CodeAbilityLink",
      "type": "object"
    },
    "CodeAbilityMetaProperties": {
      "description": "Properties specific to assignment-level meta.",
      "properties": {
        "studentSubmissionFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "Files that students must submit",
          "title": "Studentsubmissionfiles"
        },
        "additionalFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "Additional files provided to students",
          "title": "Additionalfiles"
        },
        "testFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "Test files for automated grading",
          "title": "Testfiles"
        },
        "studentTemplates": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "Template files for student projects",
          "title": "Studenttemplates"
        },
        "testDependencies": {
          "anyOf": [
            {
              "items": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/$defs/TestDependency"
                  }
                ]
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "description": "List of example dependencies. Can be simple strings (slugs) or objects with slug and version constraints",
          "title": "Testdependencies"
        },
        "executionBackend": {
          "anyOf": [
            {
              "$ref": "#/$defs/CourseExecutionBackendConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Execution backend configuration for this assignment"
        }
      },
      "title": "CodeAbilityMetaProperties",
      "type": "object"
    },
    "CodeAbilityPerson": {
      "description": "Person information for authors/maintainers.",
      "properties": {
        "name": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Full name",
          "title": "Name"
        },
        "email": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Email address",
          "title": "Email"
        },
        "affiliation": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Institutional affiliation",
          "title": "Affiliation"
        }
      },
      "title": "CodeAbilityPerson",
      "type": "object"
    },
    "CourseExecutionBackendConfig": {
      "description": "Configuration for course execution backend.",
      "properties": {
        "slug": {
          "description": "Unique identifier for the execution backend",
          "title": "Slug",
          "type": "string"
        },
        "version": {
          "description": "Version of the execution backend (e.g., 'r2024b', 'v1.0')",
          "title": "Version",
          "type": "string"
        },
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Backend-specific settings",
          "title": "Settings"
        }
      },
      "required": [
        "slug",
        "version"
      ],
      "title": "CourseExecutionBackendConfig",
      "type": "object"
    },
    "TestDependency": {
      "description": "Represents a test dependency with slug and version constraint.",
      "properties": {
        "slug": {
          "description": "Hierarchical slug of the dependency example (e.g., 'physics.math.vectors')",
          "title": "Slug",
          "type": "string"
        },
        "version": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Version constraint (e.g., '>=1.2.0', '^2.1.0', '1.0.0'). If not specified, uses latest version.",
          "title": "Version"
        }
      },
      "required": [
        "slug"
      ],
      "title": "TestDependency",
      "type": "object"
    }
  },
  "description": "Meta information for assignments/examples.",
  "properties": {
    "version": {
      "anyOf": [
        {
          "pattern": "^([1-9]\\\\d*|0)(\\\\.(([1-9]\\\\d*)|0)){0,3}$",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "1.0",
      "description": "Version of the meta format",
      "title": "Version"
    },
    "slug": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Unique identifier for the assignment",
      "title": "Slug"
    },
    "title": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Human-readable title",
      "title": "Title"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Detailed description of the content",
      "title": "Description"
    },
    "language": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "en",
      "description": "Primary language of the content (e.g., 'en', 'de', 'fr', etc.)",
      "title": "Language"
    },
    "license": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "Not specified",
      "description": "License information",
      "title": "License"
    },
    "authors": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityPerson"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Content authors",
      "title": "Authors"
    },
    "maintainers": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityPerson"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Content maintainers",
      "title": "Maintainers"
    },
    "links": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityLink"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Related links",
      "title": "Links"
    },
    "supportingMaterial": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityLink"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Supporting material links",
      "title": "Supportingmaterial"
    },
    "keywords": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "description": "Keywords for categorization",
      "title": "Keywords"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/CodeAbilityMetaProperties"
        },
        {
          "type": "null"
        }
      ],
      "description": "Assignment-specific properties"
    }
  },
  "title": "CodeAbilityMeta",
  "type": "object",
  "x-model-name": "CodeAbilityMeta"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityMeta {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityMeta', 'Expected an object');
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: slug
    if ('slug' in data && data.slug !== undefined && data.slug !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: title
    if ('title' in data && data.title !== undefined && data.title !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: language
    if ('language' in data && data.language !== undefined && data.language !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: license
    if ('license' in data && data.license !== undefined && data.license !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: authors
    if ('authors' in data && data.authors !== undefined && data.authors !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: maintainers
    if ('maintainers' in data && data.maintainers !== undefined && data.maintainers !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: links
    if ('links' in data && data.links !== undefined && data.links !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: supportingMaterial
    if ('supportingMaterial' in data && data.supportingMaterial !== undefined && data.supportingMaterial !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: keywords
    if ('keywords' in data && data.keywords !== undefined && data.keywords !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityMeta', errors.join('; '));
    }

    return data as CodeAbilityMeta;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityMeta } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityMeta', String(error)) };
    }
  }
}

/**
 * Validator for CommentCreate
 */
export class CommentCreateValidator extends BaseValidator<CommentCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "course_member_id": {
      "anyOf": [
        {
          "format": "uuid",
          "type": "string"
        },
        {
          "type": "string"
        }
      ],
      "title": "Course Member Id"
    },
    "message": {
      "title": "Message",
      "type": "string"
    }
  },
  "required": [
    "course_member_id",
    "message"
  ],
  "title": "CommentCreate",
  "type": "object",
  "x-model-name": "CommentCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CommentCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CommentCreate', 'Expected an object');
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      // Union type - skipping detailed validation
    }

    // Required field: message
    if (!('message' in data)) {
      errors.push('Missing required field: message');
    } else {
      if (typeof data.message !== 'string') {
        errors.push('Field message must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('CommentCreate', errors.join('; '));
    }

    return data as CommentCreate;
  }

  safeValidate(data: any): { success: true; data: CommentCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CommentCreate', String(error)) };
    }
  }
}

/**
 * Validator for CommentUpdate
 */
export class CommentUpdateValidator extends BaseValidator<CommentUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "message": {
      "title": "Message",
      "type": "string"
    }
  },
  "required": [
    "message"
  ],
  "title": "CommentUpdate",
  "type": "object",
  "x-model-name": "CommentUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CommentUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CommentUpdate', 'Expected an object');
    }

    // Required field: message
    if (!('message' in data)) {
      errors.push('Missing required field: message');
    } else {
      if (typeof data.message !== 'string') {
        errors.push('Field message must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('CommentUpdate', errors.join('; '));
    }

    return data as CommentUpdate;
  }

  safeValidate(data: any): { success: true; data: CommentUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CommentUpdate', String(error)) };
    }
  }
}

/**
 * Validator for Repository
 */
export class RepositoryValidator extends BaseValidator<Repository> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "url": {
      "title": "Url",
      "type": "string"
    },
    "user": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "",
      "title": "User"
    },
    "token": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "",
      "title": "Token"
    },
    "branch": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "main",
      "title": "Branch"
    },
    "path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "",
      "title": "Path"
    },
    "commit": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "",
      "title": "Commit"
    }
  },
  "required": [
    "url"
  ],
  "title": "Repository",
  "type": "object",
  "x-model-name": "Repository"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): Repository {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('Repository', 'Expected an object');
    }

    // Required field: url
    if (!('url' in data)) {
      errors.push('Missing required field: url');
    } else {
      if (typeof data.url !== 'string') {
        errors.push('Field url must be a string');
      }
    }

    // Optional field: user
    if ('user' in data && data.user !== undefined && data.user !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: token
    if ('token' in data && data.token !== undefined && data.token !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: branch
    if ('branch' in data && data.branch !== undefined && data.branch !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: path
    if ('path' in data && data.path !== undefined && data.path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: commit
    if ('commit' in data && data.commit !== undefined && data.commit !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('Repository', errors.join('; '));
    }

    return data as Repository;
  }

  safeValidate(data: any): { success: true; data: Repository } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('Repository', String(error)) };
    }
  }
}

/**
 * Validator for ExecutionBackendCreate
 */
export class ExecutionBackendCreateValidator extends BaseValidator<ExecutionBackendCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "type": {
      "title": "Type",
      "type": "string"
    },
    "slug": {
      "title": "Slug",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    }
  },
  "required": [
    "type",
    "slug"
  ],
  "title": "ExecutionBackendCreate",
  "type": "object",
  "x-model-name": "ExecutionBackendCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExecutionBackendCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExecutionBackendCreate', 'Expected an object');
    }

    // Required field: type
    if (!('type' in data)) {
      errors.push('Missing required field: type');
    } else {
      if (typeof data.type !== 'string') {
        errors.push('Field type must be a string');
      }
    }

    // Required field: slug
    if (!('slug' in data)) {
      errors.push('Missing required field: slug');
    } else {
      if (typeof data.slug !== 'string') {
        errors.push('Field slug must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExecutionBackendCreate', errors.join('; '));
    }

    return data as ExecutionBackendCreate;
  }

  safeValidate(data: any): { success: true; data: ExecutionBackendCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExecutionBackendCreate', String(error)) };
    }
  }
}

/**
 * Validator for ExecutionBackendGet
 */
export class ExecutionBackendGetValidator extends BaseValidator<ExecutionBackendGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "type": {
      "title": "Type",
      "type": "string"
    },
    "slug": {
      "title": "Slug",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    }
  },
  "required": [
    "type",
    "slug",
    "id"
  ],
  "title": "ExecutionBackendGet",
  "type": "object",
  "x-model-name": "ExecutionBackendGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExecutionBackendGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExecutionBackendGet', 'Expected an object');
    }

    // Required field: type
    if (!('type' in data)) {
      errors.push('Missing required field: type');
    } else {
      if (typeof data.type !== 'string') {
        errors.push('Field type must be a string');
      }
    }

    // Required field: slug
    if (!('slug' in data)) {
      errors.push('Missing required field: slug');
    } else {
      if (typeof data.slug !== 'string') {
        errors.push('Field slug must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ExecutionBackendGet', errors.join('; '));
    }

    return data as ExecutionBackendGet;
  }

  safeValidate(data: any): { success: true; data: ExecutionBackendGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExecutionBackendGet', String(error)) };
    }
  }
}

/**
 * Validator for ExecutionBackendList
 */
export class ExecutionBackendListValidator extends BaseValidator<ExecutionBackendList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "type": {
      "title": "Type",
      "type": "string"
    },
    "slug": {
      "title": "Slug",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    }
  },
  "required": [
    "type",
    "slug",
    "id"
  ],
  "title": "ExecutionBackendList",
  "type": "object",
  "x-model-name": "ExecutionBackendList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExecutionBackendList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExecutionBackendList', 'Expected an object');
    }

    // Required field: type
    if (!('type' in data)) {
      errors.push('Missing required field: type');
    } else {
      if (typeof data.type !== 'string') {
        errors.push('Field type must be a string');
      }
    }

    // Required field: slug
    if (!('slug' in data)) {
      errors.push('Missing required field: slug');
    } else {
      if (typeof data.slug !== 'string') {
        errors.push('Field slug must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ExecutionBackendList', errors.join('; '));
    }

    return data as ExecutionBackendList;
  }

  safeValidate(data: any): { success: true; data: ExecutionBackendList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExecutionBackendList', String(error)) };
    }
  }
}

/**
 * Validator for ExecutionBackendUpdate
 */
export class ExecutionBackendUpdateValidator extends BaseValidator<ExecutionBackendUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Type"
    },
    "slug": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Slug"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    }
  },
  "title": "ExecutionBackendUpdate",
  "type": "object",
  "x-model-name": "ExecutionBackendUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExecutionBackendUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExecutionBackendUpdate', 'Expected an object');
    }

    // Optional field: type
    if ('type' in data && data.type !== undefined && data.type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: slug
    if ('slug' in data && data.slug !== undefined && data.slug !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExecutionBackendUpdate', errors.join('; '));
    }

    return data as ExecutionBackendUpdate;
  }

  safeValidate(data: any): { success: true; data: ExecutionBackendUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExecutionBackendUpdate', String(error)) };
    }
  }
}

/**
 * Validator for ExecutionBackendQuery
 */
export class ExecutionBackendQueryValidator extends BaseValidator<ExecutionBackendQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Type"
    },
    "slug": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Slug"
    }
  },
  "title": "ExecutionBackendQuery",
  "type": "object",
  "x-model-name": "ExecutionBackendQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExecutionBackendQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExecutionBackendQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: type
    if ('type' in data && data.type !== undefined && data.type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: slug
    if ('slug' in data && data.slug !== undefined && data.slug !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExecutionBackendQuery', errors.join('; '));
    }

    return data as ExecutionBackendQuery;
  }

  safeValidate(data: any): { success: true; data: ExecutionBackendQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExecutionBackendQuery', String(error)) };
    }
  }
}

/**
 * Validator for ListQuery
 */
export class ListQueryValidator extends BaseValidator<ListQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    }
  },
  "title": "ListQuery",
  "type": "object",
  "x-model-name": "ListQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ListQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ListQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ListQuery', errors.join('; '));
    }

    return data as ListQuery;
  }

  safeValidate(data: any): { success: true; data: ListQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ListQuery', String(error)) };
    }
  }
}

/**
 * Validator for BaseEntityList
 */
export class BaseEntityListValidator extends BaseValidator<BaseEntityList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    }
  },
  "title": "BaseEntityList",
  "type": "object",
  "x-model-name": "BaseEntityList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): BaseEntityList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('BaseEntityList', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('BaseEntityList', errors.join('; '));
    }

    return data as BaseEntityList;
  }

  safeValidate(data: any): { success: true; data: BaseEntityList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('BaseEntityList', String(error)) };
    }
  }
}

/**
 * Validator for BaseEntityGet
 */
export class BaseEntityGetValidator extends BaseValidator<BaseEntityGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    }
  },
  "title": "BaseEntityGet",
  "type": "object",
  "x-model-name": "BaseEntityGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): BaseEntityGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('BaseEntityGet', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('BaseEntityGet', errors.join('; '));
    }

    return data as BaseEntityGet;
  }

  safeValidate(data: any): { success: true; data: BaseEntityGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('BaseEntityGet', String(error)) };
    }
  }
}

/**
 * Request model for logout.
 */
export class LogoutRequestValidator extends BaseValidator<LogoutRequest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Request model for logout.",
  "properties": {
    "provider": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Provider name for SSO logout (optional)",
      "title": "Provider"
    }
  },
  "title": "LogoutRequest",
  "type": "object",
  "x-model-name": "LogoutRequest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LogoutRequest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LogoutRequest', 'Expected an object');
    }

    // Optional field: provider
    if ('provider' in data && data.provider !== undefined && data.provider !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('LogoutRequest', errors.join('; '));
    }

    return data as LogoutRequest;
  }

  safeValidate(data: any): { success: true; data: LogoutRequest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LogoutRequest', String(error)) };
    }
  }
}

/**
 * Response model after successful logout.
 */
export class LogoutResponseValidator extends BaseValidator<LogoutResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Response model after successful logout.",
  "properties": {
    "message": {
      "description": "Logout status message",
      "title": "Message",
      "type": "string"
    },
    "provider": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Provider that was logged out from",
      "title": "Provider"
    }
  },
  "required": [
    "message"
  ],
  "title": "LogoutResponse",
  "type": "object",
  "x-model-name": "LogoutResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LogoutResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LogoutResponse', 'Expected an object');
    }

    // Required field: message
    if (!('message' in data)) {
      errors.push('Missing required field: message');
    } else {
      if (typeof data.message !== 'string') {
        errors.push('Field message must be a string');
      }
    }

    // Optional field: provider
    if ('provider' in data && data.provider !== undefined && data.provider !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('LogoutResponse', errors.join('; '));
    }

    return data as LogoutResponse;
  }

  safeValidate(data: any): { success: true; data: LogoutResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LogoutResponse', String(error)) };
    }
  }
}

/**
 * Validator for GitlabGroupProjectConfig
 */
export class GitlabGroupProjectConfigValidator extends BaseValidator<GitlabGroupProjectConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Name"
    },
    "path": {
      "title": "Path",
      "type": "string"
    }
  },
  "required": [
    "path"
  ],
  "title": "GitlabGroupProjectConfig",
  "type": "object",
  "x-model-name": "GitlabGroupProjectConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GitlabGroupProjectConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GitlabGroupProjectConfig', 'Expected an object');
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: path
    if (!('path' in data)) {
      errors.push('Missing required field: path');
    } else {
      if (typeof data.path !== 'string') {
        errors.push('Field path must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('GitlabGroupProjectConfig', errors.join('; '));
    }

    return data as GitlabGroupProjectConfig;
  }

  safeValidate(data: any): { success: true; data: GitlabGroupProjectConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GitlabGroupProjectConfig', String(error)) };
    }
  }
}

/**
 * Validator for ApiConfig
 */
export class ApiConfigValidator extends BaseValidator<ApiConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "user": {
      "title": "User",
      "type": "string"
    },
    "password": {
      "title": "Password",
      "type": "string"
    },
    "url": {
      "title": "Url",
      "type": "string"
    }
  },
  "required": [
    "user",
    "password",
    "url"
  ],
  "title": "ApiConfig",
  "type": "object",
  "x-model-name": "ApiConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ApiConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ApiConfig', 'Expected an object');
    }

    // Required field: user
    if (!('user' in data)) {
      errors.push('Missing required field: user');
    } else {
      if (typeof data.user !== 'string') {
        errors.push('Field user must be a string');
      }
    }

    // Required field: password
    if (!('password' in data)) {
      errors.push('Missing required field: password');
    } else {
      if (typeof data.password !== 'string') {
        errors.push('Field password must be a string');
      }
    }

    // Required field: url
    if (!('url' in data)) {
      errors.push('Missing required field: url');
    } else {
      if (typeof data.url !== 'string') {
        errors.push('Field url must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ApiConfig', errors.join('; '));
    }

    return data as ApiConfig;
  }

  safeValidate(data: any): { success: true; data: ApiConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ApiConfig', String(error)) };
    }
  }
}

/**
 * Validator for RepositoryConfig
 */
export class RepositoryConfigValidator extends BaseValidator<RepositoryConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "settings": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "title": "Settings"
    }
  },
  "title": "RepositoryConfig",
  "type": "object",
  "x-model-name": "RepositoryConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): RepositoryConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('RepositoryConfig', 'Expected an object');
    }

    // Optional field: settings
    if ('settings' in data && data.settings !== undefined && data.settings !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('RepositoryConfig', errors.join('; '));
    }

    return data as RepositoryConfig;
  }

  safeValidate(data: any): { success: true; data: RepositoryConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('RepositoryConfig', String(error)) };
    }
  }
}

/**
 * Validator for GitLabConfigGet
 */
export class GitLabConfigGetValidator extends BaseValidator<GitLabConfigGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "settings": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "title": "Settings"
    },
    "url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Url"
    },
    "full_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Full Path"
    },
    "directory": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Directory"
    },
    "registry": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Registry"
    },
    "parent": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Parent"
    },
    "group_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Group Id"
    },
    "parent_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Parent Id"
    },
    "namespace_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Namespace Id"
    },
    "namespace_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Namespace Path"
    },
    "web_url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Web Url"
    },
    "visibility": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Visibility"
    },
    "last_synced_at": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Synced At"
    }
  },
  "title": "GitLabConfigGet",
  "type": "object",
  "x-model-name": "GitLabConfigGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GitLabConfigGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GitLabConfigGet', 'Expected an object');
    }

    // Optional field: settings
    if ('settings' in data && data.settings !== undefined && data.settings !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: url
    if ('url' in data && data.url !== undefined && data.url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: full_path
    if ('full_path' in data && data.full_path !== undefined && data.full_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: directory
    if ('directory' in data && data.directory !== undefined && data.directory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: registry
    if ('registry' in data && data.registry !== undefined && data.registry !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: parent
    if ('parent' in data && data.parent !== undefined && data.parent !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: group_id
    if ('group_id' in data && data.group_id !== undefined && data.group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: parent_id
    if ('parent_id' in data && data.parent_id !== undefined && data.parent_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: namespace_id
    if ('namespace_id' in data && data.namespace_id !== undefined && data.namespace_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: namespace_path
    if ('namespace_path' in data && data.namespace_path !== undefined && data.namespace_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: web_url
    if ('web_url' in data && data.web_url !== undefined && data.web_url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: visibility
    if ('visibility' in data && data.visibility !== undefined && data.visibility !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: last_synced_at
    if ('last_synced_at' in data && data.last_synced_at !== undefined && data.last_synced_at !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GitLabConfigGet', errors.join('; '));
    }

    return data as GitLabConfigGet;
  }

  safeValidate(data: any): { success: true; data: GitLabConfigGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GitLabConfigGet', String(error)) };
    }
  }
}

/**
 * Validator for TypeConfig
 */
export class TypeConfigValidator extends BaseValidator<TypeConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "kind": {
      "title": "Kind",
      "type": "string"
    },
    "slug": {
      "title": "Slug",
      "type": "string"
    },
    "title": {
      "title": "Title",
      "type": "string"
    },
    "color": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Color"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "properties": {
      "type": "object",
      "additionalProperties": true,
      "default": {},
      "title": "Properties"
    }
  },
  "required": [
    "kind",
    "slug",
    "title"
  ],
  "title": "TypeConfig",
  "type": "object",
  "x-model-name": "TypeConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TypeConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TypeConfig', 'Expected an object');
    }

    // Required field: kind
    if (!('kind' in data)) {
      errors.push('Missing required field: kind');
    } else {
      if (typeof data.kind !== 'string') {
        errors.push('Field kind must be a string');
      }
    }

    // Required field: slug
    if (!('slug' in data)) {
      errors.push('Missing required field: slug');
    } else {
      if (typeof data.slug !== 'string') {
        errors.push('Field slug must be a string');
      }
    }

    // Required field: title
    if (!('title' in data)) {
      errors.push('Missing required field: title');
    } else {
      if (typeof data.title !== 'string') {
        errors.push('Field title must be a string');
      }
    }

    // Optional field: color
    if ('color' in data && data.color !== undefined && data.color !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      if (typeof data.properties !== 'object' || data.properties === null) {
        errors.push('Field properties must be an object');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('TypeConfig', errors.join('; '));
    }

    return data as TypeConfig;
  }

  safeValidate(data: any): { success: true; data: TypeConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TypeConfig', String(error)) };
    }
  }
}

/**
 * Validator for FileSourceConfig
 */
export class FileSourceConfigValidator extends BaseValidator<FileSourceConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "url": {
      "title": "Url",
      "type": "string"
    },
    "token": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Token"
    }
  },
  "required": [
    "url"
  ],
  "title": "FileSourceConfig",
  "type": "object",
  "x-model-name": "FileSourceConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): FileSourceConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('FileSourceConfig', 'Expected an object');
    }

    // Required field: url
    if (!('url' in data)) {
      errors.push('Missing required field: url');
    } else {
      if (typeof data.url !== 'string') {
        errors.push('Field url must be a string');
      }
    }

    // Optional field: token
    if ('token' in data && data.token !== undefined && data.token !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('FileSourceConfig', errors.join('; '));
    }

    return data as FileSourceConfig;
  }

  safeValidate(data: any): { success: true; data: FileSourceConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('FileSourceConfig', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityTestCommon
 */
export class CodeAbilityTestCommonValidator extends BaseValidator<CodeAbilityTestCommon> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "QualificationEnum": {
      "enum": [
        "verifyEqual",
        "matches",
        "contains",
        "startsWith",
        "endsWith",
        "count",
        "regexp"
      ],
      "title": "QualificationEnum",
      "type": "string"
    }
  },
  "properties": {
    "failureMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Failuremessage"
    },
    "successMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Successmessage"
    },
    "qualification": {
      "anyOf": [
        {
          "$ref": "#/$defs/QualificationEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "relativeTolerance": {
      "anyOf": [
        {
          "exclusiveMinimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Relativetolerance"
    },
    "absoluteTolerance": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Absolutetolerance"
    },
    "allowedOccuranceRange": {
      "anyOf": [
        {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Allowedoccurancerange"
    },
    "occuranceType": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Occurancetype"
    },
    "verbosity": {
      "anyOf": [
        {
          "maximum": 3,
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Verbosity"
    }
  },
  "title": "CodeAbilityTestCommon",
  "type": "object",
  "x-model-name": "CodeAbilityTestCommon"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityTestCommon {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityTestCommon', 'Expected an object');
    }

    // Optional field: failureMessage
    if ('failureMessage' in data && data.failureMessage !== undefined && data.failureMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: successMessage
    if ('successMessage' in data && data.successMessage !== undefined && data.successMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: qualification
    if ('qualification' in data && data.qualification !== undefined && data.qualification !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: relativeTolerance
    if ('relativeTolerance' in data && data.relativeTolerance !== undefined && data.relativeTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: absoluteTolerance
    if ('absoluteTolerance' in data && data.absoluteTolerance !== undefined && data.absoluteTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: allowedOccuranceRange
    if ('allowedOccuranceRange' in data && data.allowedOccuranceRange !== undefined && data.allowedOccuranceRange !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: occuranceType
    if ('occuranceType' in data && data.occuranceType !== undefined && data.occuranceType !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: verbosity
    if ('verbosity' in data && data.verbosity !== undefined && data.verbosity !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityTestCommon', errors.join('; '));
    }

    return data as CodeAbilityTestCommon;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityTestCommon } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityTestCommon', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityTestCollectionCommon
 */
export class CodeAbilityTestCollectionCommonValidator extends BaseValidator<CodeAbilityTestCollectionCommon> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "QualificationEnum": {
      "enum": [
        "verifyEqual",
        "matches",
        "contains",
        "startsWith",
        "endsWith",
        "count",
        "regexp"
      ],
      "title": "QualificationEnum",
      "type": "string"
    }
  },
  "properties": {
    "failureMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Failuremessage"
    },
    "successMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Successmessage"
    },
    "qualification": {
      "anyOf": [
        {
          "$ref": "#/$defs/QualificationEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "relativeTolerance": {
      "anyOf": [
        {
          "exclusiveMinimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Relativetolerance"
    },
    "absoluteTolerance": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Absolutetolerance"
    },
    "allowedOccuranceRange": {
      "anyOf": [
        {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Allowedoccurancerange"
    },
    "occuranceType": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Occurancetype"
    },
    "verbosity": {
      "anyOf": [
        {
          "maximum": 3,
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Verbosity"
    },
    "storeGraphicsArtifacts": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Storegraphicsartifacts"
    },
    "competency": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Competency"
    },
    "timeout": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Timeout"
    }
  },
  "title": "CodeAbilityTestCollectionCommon",
  "type": "object",
  "x-model-name": "CodeAbilityTestCollectionCommon"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityTestCollectionCommon {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityTestCollectionCommon', 'Expected an object');
    }

    // Optional field: failureMessage
    if ('failureMessage' in data && data.failureMessage !== undefined && data.failureMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: successMessage
    if ('successMessage' in data && data.successMessage !== undefined && data.successMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: qualification
    if ('qualification' in data && data.qualification !== undefined && data.qualification !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: relativeTolerance
    if ('relativeTolerance' in data && data.relativeTolerance !== undefined && data.relativeTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: absoluteTolerance
    if ('absoluteTolerance' in data && data.absoluteTolerance !== undefined && data.absoluteTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: allowedOccuranceRange
    if ('allowedOccuranceRange' in data && data.allowedOccuranceRange !== undefined && data.allowedOccuranceRange !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: occuranceType
    if ('occuranceType' in data && data.occuranceType !== undefined && data.occuranceType !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: verbosity
    if ('verbosity' in data && data.verbosity !== undefined && data.verbosity !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: storeGraphicsArtifacts
    if ('storeGraphicsArtifacts' in data && data.storeGraphicsArtifacts !== undefined && data.storeGraphicsArtifacts !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: competency
    if ('competency' in data && data.competency !== undefined && data.competency !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: timeout
    if ('timeout' in data && data.timeout !== undefined && data.timeout !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityTestCollectionCommon', errors.join('; '));
    }

    return data as CodeAbilityTestCollectionCommon;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityTestCollectionCommon } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityTestCollectionCommon', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityTest
 */
export class CodeAbilityTestValidator extends BaseValidator<CodeAbilityTest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "QualificationEnum": {
      "enum": [
        "verifyEqual",
        "matches",
        "contains",
        "startsWith",
        "endsWith",
        "count",
        "regexp"
      ],
      "title": "QualificationEnum",
      "type": "string"
    }
  },
  "properties": {
    "failureMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Failuremessage"
    },
    "successMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Successmessage"
    },
    "qualification": {
      "anyOf": [
        {
          "$ref": "#/$defs/QualificationEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "relativeTolerance": {
      "anyOf": [
        {
          "exclusiveMinimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Relativetolerance"
    },
    "absoluteTolerance": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Absolutetolerance"
    },
    "allowedOccuranceRange": {
      "anyOf": [
        {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Allowedoccurancerange"
    },
    "occuranceType": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Occurancetype"
    },
    "verbosity": {
      "anyOf": [
        {
          "maximum": 3,
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Verbosity"
    },
    "name": {
      "minLength": 1,
      "title": "Name",
      "type": "string"
    },
    "value": {
      "anyOf": [
        {},
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Value"
    },
    "evalString": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Evalstring"
    },
    "pattern": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Pattern"
    },
    "countRequirement": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Countrequirement"
    }
  },
  "required": [
    "name"
  ],
  "title": "CodeAbilityTest",
  "type": "object",
  "x-model-name": "CodeAbilityTest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityTest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityTest', 'Expected an object');
    }

    // Optional field: failureMessage
    if ('failureMessage' in data && data.failureMessage !== undefined && data.failureMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: successMessage
    if ('successMessage' in data && data.successMessage !== undefined && data.successMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: qualification
    if ('qualification' in data && data.qualification !== undefined && data.qualification !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: relativeTolerance
    if ('relativeTolerance' in data && data.relativeTolerance !== undefined && data.relativeTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: absoluteTolerance
    if ('absoluteTolerance' in data && data.absoluteTolerance !== undefined && data.absoluteTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: allowedOccuranceRange
    if ('allowedOccuranceRange' in data && data.allowedOccuranceRange !== undefined && data.allowedOccuranceRange !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: occuranceType
    if ('occuranceType' in data && data.occuranceType !== undefined && data.occuranceType !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: verbosity
    if ('verbosity' in data && data.verbosity !== undefined && data.verbosity !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: value
    if ('value' in data && data.value !== undefined && data.value !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: evalString
    if ('evalString' in data && data.evalString !== undefined && data.evalString !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: pattern
    if ('pattern' in data && data.pattern !== undefined && data.pattern !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: countRequirement
    if ('countRequirement' in data && data.countRequirement !== undefined && data.countRequirement !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityTest', errors.join('; '));
    }

    return data as CodeAbilityTest;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityTest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityTest', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityTestCollection
 */
export class CodeAbilityTestCollectionValidator extends BaseValidator<CodeAbilityTestCollection> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityTest": {
      "properties": {
        "failureMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Failuremessage"
        },
        "successMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Successmessage"
        },
        "qualification": {
          "anyOf": [
            {
              "$ref": "#/$defs/QualificationEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "relativeTolerance": {
          "anyOf": [
            {
              "exclusiveMinimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Relativetolerance"
        },
        "absoluteTolerance": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Absolutetolerance"
        },
        "allowedOccuranceRange": {
          "anyOf": [
            {
              "items": {
                "type": "integer"
              },
              "maxItems": 2,
              "minItems": 2,
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Allowedoccurancerange"
        },
        "occuranceType": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Occurancetype"
        },
        "verbosity": {
          "anyOf": [
            {
              "maximum": 3,
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Verbosity"
        },
        "name": {
          "minLength": 1,
          "title": "Name",
          "type": "string"
        },
        "value": {
          "anyOf": [
            {},
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Value"
        },
        "evalString": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Evalstring"
        },
        "pattern": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Pattern"
        },
        "countRequirement": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Countrequirement"
        }
      },
      "required": [
        "name"
      ],
      "title": "CodeAbilityTest",
      "type": "object"
    },
    "QualificationEnum": {
      "enum": [
        "verifyEqual",
        "matches",
        "contains",
        "startsWith",
        "endsWith",
        "count",
        "regexp"
      ],
      "title": "QualificationEnum",
      "type": "string"
    },
    "TypeEnum": {
      "enum": [
        "variable",
        "graphics",
        "structural",
        "linting",
        "exist",
        "error",
        "warning",
        "help",
        "stdout"
      ],
      "title": "TypeEnum",
      "type": "string"
    }
  },
  "properties": {
    "failureMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Failuremessage"
    },
    "successMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Successmessage"
    },
    "qualification": {
      "anyOf": [
        {
          "$ref": "#/$defs/QualificationEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "relativeTolerance": {
      "anyOf": [
        {
          "exclusiveMinimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Relativetolerance"
    },
    "absoluteTolerance": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Absolutetolerance"
    },
    "allowedOccuranceRange": {
      "anyOf": [
        {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Allowedoccurancerange"
    },
    "occuranceType": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Occurancetype"
    },
    "verbosity": {
      "anyOf": [
        {
          "maximum": 3,
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Verbosity"
    },
    "storeGraphicsArtifacts": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Storegraphicsartifacts"
    },
    "competency": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Competency"
    },
    "timeout": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Timeout"
    },
    "type": {
      "anyOf": [
        {
          "$ref": "#/$defs/TypeEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": "variable"
    },
    "name": {
      "minLength": 1,
      "title": "Name",
      "type": "string"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "successDependency": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "integer"
        },
        {
          "items": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ]
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Successdependency"
    },
    "setUpCodeDependency": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Setupcodedependency"
    },
    "entryPoint": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Entrypoint"
    },
    "inputAnswers": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Inputanswers"
    },
    "setUpCode": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Setupcode"
    },
    "tearDownCode": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Teardowncode"
    },
    "id": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "file": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "File"
    },
    "tests": {
      "items": {
        "$ref": "#/$defs/CodeAbilityTest"
      },
      "title": "Tests",
      "type": "array"
    }
  },
  "required": [
    "name",
    "tests"
  ],
  "title": "CodeAbilityTestCollection",
  "type": "object",
  "x-model-name": "CodeAbilityTestCollection"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityTestCollection {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityTestCollection', 'Expected an object');
    }

    // Optional field: failureMessage
    if ('failureMessage' in data && data.failureMessage !== undefined && data.failureMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: successMessage
    if ('successMessage' in data && data.successMessage !== undefined && data.successMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: qualification
    if ('qualification' in data && data.qualification !== undefined && data.qualification !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: relativeTolerance
    if ('relativeTolerance' in data && data.relativeTolerance !== undefined && data.relativeTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: absoluteTolerance
    if ('absoluteTolerance' in data && data.absoluteTolerance !== undefined && data.absoluteTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: allowedOccuranceRange
    if ('allowedOccuranceRange' in data && data.allowedOccuranceRange !== undefined && data.allowedOccuranceRange !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: occuranceType
    if ('occuranceType' in data && data.occuranceType !== undefined && data.occuranceType !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: verbosity
    if ('verbosity' in data && data.verbosity !== undefined && data.verbosity !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: storeGraphicsArtifacts
    if ('storeGraphicsArtifacts' in data && data.storeGraphicsArtifacts !== undefined && data.storeGraphicsArtifacts !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: competency
    if ('competency' in data && data.competency !== undefined && data.competency !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: timeout
    if ('timeout' in data && data.timeout !== undefined && data.timeout !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: type
    if ('type' in data && data.type !== undefined && data.type !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: successDependency
    if ('successDependency' in data && data.successDependency !== undefined && data.successDependency !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: setUpCodeDependency
    if ('setUpCodeDependency' in data && data.setUpCodeDependency !== undefined && data.setUpCodeDependency !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: entryPoint
    if ('entryPoint' in data && data.entryPoint !== undefined && data.entryPoint !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: inputAnswers
    if ('inputAnswers' in data && data.inputAnswers !== undefined && data.inputAnswers !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: setUpCode
    if ('setUpCode' in data && data.setUpCode !== undefined && data.setUpCode !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: tearDownCode
    if ('tearDownCode' in data && data.tearDownCode !== undefined && data.tearDownCode !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: file
    if ('file' in data && data.file !== undefined && data.file !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: tests
    if (!('tests' in data)) {
      errors.push('Missing required field: tests');
    } else {
      if (!Array.isArray(data.tests)) {
        errors.push('Field tests must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityTestCollection', errors.join('; '));
    }

    return data as CodeAbilityTestCollection;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityTestCollection } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityTestCollection', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityTestProperty
 */
export class CodeAbilityTestPropertyValidator extends BaseValidator<CodeAbilityTestProperty> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityTest": {
      "properties": {
        "failureMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Failuremessage"
        },
        "successMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Successmessage"
        },
        "qualification": {
          "anyOf": [
            {
              "$ref": "#/$defs/QualificationEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "relativeTolerance": {
          "anyOf": [
            {
              "exclusiveMinimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Relativetolerance"
        },
        "absoluteTolerance": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Absolutetolerance"
        },
        "allowedOccuranceRange": {
          "anyOf": [
            {
              "items": {
                "type": "integer"
              },
              "maxItems": 2,
              "minItems": 2,
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Allowedoccurancerange"
        },
        "occuranceType": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Occurancetype"
        },
        "verbosity": {
          "anyOf": [
            {
              "maximum": 3,
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Verbosity"
        },
        "name": {
          "minLength": 1,
          "title": "Name",
          "type": "string"
        },
        "value": {
          "anyOf": [
            {},
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Value"
        },
        "evalString": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Evalstring"
        },
        "pattern": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Pattern"
        },
        "countRequirement": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Countrequirement"
        }
      },
      "required": [
        "name"
      ],
      "title": "CodeAbilityTest",
      "type": "object"
    },
    "CodeAbilityTestCollection": {
      "properties": {
        "failureMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Failuremessage"
        },
        "successMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Successmessage"
        },
        "qualification": {
          "anyOf": [
            {
              "$ref": "#/$defs/QualificationEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "relativeTolerance": {
          "anyOf": [
            {
              "exclusiveMinimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Relativetolerance"
        },
        "absoluteTolerance": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Absolutetolerance"
        },
        "allowedOccuranceRange": {
          "anyOf": [
            {
              "items": {
                "type": "integer"
              },
              "maxItems": 2,
              "minItems": 2,
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Allowedoccurancerange"
        },
        "occuranceType": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Occurancetype"
        },
        "verbosity": {
          "anyOf": [
            {
              "maximum": 3,
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Verbosity"
        },
        "storeGraphicsArtifacts": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Storegraphicsartifacts"
        },
        "competency": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Competency"
        },
        "timeout": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Timeout"
        },
        "type": {
          "anyOf": [
            {
              "$ref": "#/$defs/TypeEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": "variable"
        },
        "name": {
          "minLength": 1,
          "title": "Name",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Description"
        },
        "successDependency": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "integer"
            },
            {
              "items": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "integer"
                  }
                ]
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Successdependency"
        },
        "setUpCodeDependency": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Setupcodedependency"
        },
        "entryPoint": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Entrypoint"
        },
        "inputAnswers": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Inputanswers"
        },
        "setUpCode": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Setupcode"
        },
        "tearDownCode": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Teardowncode"
        },
        "id": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Id"
        },
        "file": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "File"
        },
        "tests": {
          "items": {
            "$ref": "#/$defs/CodeAbilityTest"
          },
          "title": "Tests",
          "type": "array"
        }
      },
      "required": [
        "name",
        "tests"
      ],
      "title": "CodeAbilityTestCollection",
      "type": "object"
    },
    "QualificationEnum": {
      "enum": [
        "verifyEqual",
        "matches",
        "contains",
        "startsWith",
        "endsWith",
        "count",
        "regexp"
      ],
      "title": "QualificationEnum",
      "type": "string"
    },
    "TypeEnum": {
      "enum": [
        "variable",
        "graphics",
        "structural",
        "linting",
        "exist",
        "error",
        "warning",
        "help",
        "stdout"
      ],
      "title": "TypeEnum",
      "type": "string"
    }
  },
  "properties": {
    "failureMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "Some or all tests failed",
      "title": "Failuremessage"
    },
    "successMessage": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "Congratulations! All tests passed",
      "title": "Successmessage"
    },
    "qualification": {
      "anyOf": [
        {
          "$ref": "#/$defs/QualificationEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": "verifyEqual"
    },
    "relativeTolerance": {
      "anyOf": [
        {
          "exclusiveMinimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": 1e-15,
      "title": "Relativetolerance"
    },
    "absoluteTolerance": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": 0.0,
      "title": "Absolutetolerance"
    },
    "allowedOccuranceRange": {
      "anyOf": [
        {
          "items": {
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [
        0,
        0
      ],
      "title": "Allowedoccurancerange"
    },
    "occuranceType": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "NAME",
      "title": "Occurancetype"
    },
    "verbosity": {
      "anyOf": [
        {
          "maximum": 3,
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Verbosity"
    },
    "storeGraphicsArtifacts": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Storegraphicsartifacts"
    },
    "competency": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Competency"
    },
    "timeout": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": 180.0,
      "title": "Timeout"
    },
    "tests": {
      "default": [],
      "items": {
        "$ref": "#/$defs/CodeAbilityTestCollection"
      },
      "title": "Tests",
      "type": "array"
    }
  },
  "title": "CodeAbilityTestProperty",
  "type": "object",
  "x-model-name": "CodeAbilityTestProperty"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityTestProperty {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityTestProperty', 'Expected an object');
    }

    // Optional field: failureMessage
    if ('failureMessage' in data && data.failureMessage !== undefined && data.failureMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: successMessage
    if ('successMessage' in data && data.successMessage !== undefined && data.successMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: qualification
    if ('qualification' in data && data.qualification !== undefined && data.qualification !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: relativeTolerance
    if ('relativeTolerance' in data && data.relativeTolerance !== undefined && data.relativeTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: absoluteTolerance
    if ('absoluteTolerance' in data && data.absoluteTolerance !== undefined && data.absoluteTolerance !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: allowedOccuranceRange
    if ('allowedOccuranceRange' in data && data.allowedOccuranceRange !== undefined && data.allowedOccuranceRange !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: occuranceType
    if ('occuranceType' in data && data.occuranceType !== undefined && data.occuranceType !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: verbosity
    if ('verbosity' in data && data.verbosity !== undefined && data.verbosity !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: storeGraphicsArtifacts
    if ('storeGraphicsArtifacts' in data && data.storeGraphicsArtifacts !== undefined && data.storeGraphicsArtifacts !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: competency
    if ('competency' in data && data.competency !== undefined && data.competency !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: timeout
    if ('timeout' in data && data.timeout !== undefined && data.timeout !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: tests
    if ('tests' in data && data.tests !== undefined && data.tests !== null) {
      if (!Array.isArray(data.tests)) {
        errors.push('Field tests must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityTestProperty', errors.join('; '));
    }

    return data as CodeAbilityTestProperty;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityTestProperty } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityTestProperty', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityTestSuite
 */
export class CodeAbilityTestSuiteValidator extends BaseValidator<CodeAbilityTestSuite> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityTest": {
      "properties": {
        "failureMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Failuremessage"
        },
        "successMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Successmessage"
        },
        "qualification": {
          "anyOf": [
            {
              "$ref": "#/$defs/QualificationEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "relativeTolerance": {
          "anyOf": [
            {
              "exclusiveMinimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Relativetolerance"
        },
        "absoluteTolerance": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Absolutetolerance"
        },
        "allowedOccuranceRange": {
          "anyOf": [
            {
              "items": {
                "type": "integer"
              },
              "maxItems": 2,
              "minItems": 2,
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Allowedoccurancerange"
        },
        "occuranceType": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Occurancetype"
        },
        "verbosity": {
          "anyOf": [
            {
              "maximum": 3,
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Verbosity"
        },
        "name": {
          "minLength": 1,
          "title": "Name",
          "type": "string"
        },
        "value": {
          "anyOf": [
            {},
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Value"
        },
        "evalString": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Evalstring"
        },
        "pattern": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Pattern"
        },
        "countRequirement": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Countrequirement"
        }
      },
      "required": [
        "name"
      ],
      "title": "CodeAbilityTest",
      "type": "object"
    },
    "CodeAbilityTestCollection": {
      "properties": {
        "failureMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Failuremessage"
        },
        "successMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Successmessage"
        },
        "qualification": {
          "anyOf": [
            {
              "$ref": "#/$defs/QualificationEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "relativeTolerance": {
          "anyOf": [
            {
              "exclusiveMinimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Relativetolerance"
        },
        "absoluteTolerance": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Absolutetolerance"
        },
        "allowedOccuranceRange": {
          "anyOf": [
            {
              "items": {
                "type": "integer"
              },
              "maxItems": 2,
              "minItems": 2,
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Allowedoccurancerange"
        },
        "occuranceType": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Occurancetype"
        },
        "verbosity": {
          "anyOf": [
            {
              "maximum": 3,
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Verbosity"
        },
        "storeGraphicsArtifacts": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Storegraphicsartifacts"
        },
        "competency": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Competency"
        },
        "timeout": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Timeout"
        },
        "type": {
          "anyOf": [
            {
              "$ref": "#/$defs/TypeEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": "variable"
        },
        "name": {
          "minLength": 1,
          "title": "Name",
          "type": "string"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Description"
        },
        "successDependency": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "integer"
            },
            {
              "items": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "integer"
                  }
                ]
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Successdependency"
        },
        "setUpCodeDependency": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Setupcodedependency"
        },
        "entryPoint": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Entrypoint"
        },
        "inputAnswers": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Inputanswers"
        },
        "setUpCode": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Setupcode"
        },
        "tearDownCode": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Teardowncode"
        },
        "id": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Id"
        },
        "file": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "File"
        },
        "tests": {
          "items": {
            "$ref": "#/$defs/CodeAbilityTest"
          },
          "title": "Tests",
          "type": "array"
        }
      },
      "required": [
        "name",
        "tests"
      ],
      "title": "CodeAbilityTestCollection",
      "type": "object"
    },
    "CodeAbilityTestProperty": {
      "properties": {
        "failureMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "Some or all tests failed",
          "title": "Failuremessage"
        },
        "successMessage": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "Congratulations! All tests passed",
          "title": "Successmessage"
        },
        "qualification": {
          "anyOf": [
            {
              "$ref": "#/$defs/QualificationEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": "verifyEqual"
        },
        "relativeTolerance": {
          "anyOf": [
            {
              "exclusiveMinimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": 1e-15,
          "title": "Relativetolerance"
        },
        "absoluteTolerance": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": 0.0,
          "title": "Absolutetolerance"
        },
        "allowedOccuranceRange": {
          "anyOf": [
            {
              "items": {
                "type": "integer"
              },
              "maxItems": 2,
              "minItems": 2,
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [
            0,
            0
          ],
          "title": "Allowedoccurancerange"
        },
        "occuranceType": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": "NAME",
          "title": "Occurancetype"
        },
        "verbosity": {
          "anyOf": [
            {
              "maximum": 3,
              "minimum": 0,
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Verbosity"
        },
        "storeGraphicsArtifacts": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Storegraphicsartifacts"
        },
        "competency": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Competency"
        },
        "timeout": {
          "anyOf": [
            {
              "minimum": 0,
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": 180.0,
          "title": "Timeout"
        },
        "tests": {
          "default": [],
          "items": {
            "$ref": "#/$defs/CodeAbilityTestCollection"
          },
          "title": "Tests",
          "type": "array"
        }
      },
      "title": "CodeAbilityTestProperty",
      "type": "object"
    },
    "QualificationEnum": {
      "enum": [
        "verifyEqual",
        "matches",
        "contains",
        "startsWith",
        "endsWith",
        "count",
        "regexp"
      ],
      "title": "QualificationEnum",
      "type": "string"
    },
    "TypeEnum": {
      "enum": [
        "variable",
        "graphics",
        "structural",
        "linting",
        "exist",
        "error",
        "warning",
        "help",
        "stdout"
      ],
      "title": "TypeEnum",
      "type": "string"
    }
  },
  "properties": {
    "type": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "python",
      "title": "Type"
    },
    "name": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "Python Test Suite",
      "title": "Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "version": {
      "anyOf": [
        {
          "pattern": "^([1-9]\\\\d*|0)(\\\\.(([1-9]\\\\d*)|0)){0,3}$",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "1.0",
      "title": "Version"
    },
    "properties": {
      "$ref": "#/$defs/CodeAbilityTestProperty",
      "default": {
        "failureMessage": "Some or all tests failed",
        "successMessage": "Congratulations! All tests passed",
        "qualification": "verifyEqual",
        "relativeTolerance": 1e-15,
        "absoluteTolerance": 0.0,
        "allowedOccuranceRange": [
          0,
          0
        ],
        "occuranceType": "NAME",
        "verbosity": null,
        "storeGraphicsArtifacts": null,
        "competency": null,
        "timeout": 180.0,
        "tests": []
      }
    }
  },
  "title": "CodeAbilityTestSuite",
  "type": "object",
  "x-model-name": "CodeAbilityTestSuite"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityTestSuite {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityTestSuite', 'Expected an object');
    }

    // Optional field: type
    if ('type' in data && data.type !== undefined && data.type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Reference field - basic object check
      if (typeof data.properties !== 'object') {
        errors.push('Field properties must be an object');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityTestSuite', errors.join('; '));
    }

    return data as CodeAbilityTestSuite;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityTestSuite } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityTestSuite', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilitySpecification
 */
export class CodeAbilitySpecificationValidator extends BaseValidator<CodeAbilitySpecification> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "executionDirectory": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Executiondirectory"
    },
    "studentDirectory": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "student",
      "title": "Studentdirectory"
    },
    "referenceDirectory": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "reference",
      "title": "Referencedirectory"
    },
    "testDirectory": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "testprograms",
      "title": "Testdirectory"
    },
    "outputDirectory": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "output",
      "title": "Outputdirectory"
    },
    "artifactDirectory": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "artifacts",
      "title": "Artifactdirectory"
    },
    "testVersion": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "v1",
      "title": "Testversion"
    },
    "storeGraphicsArtifacts": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Storegraphicsartifacts"
    },
    "outputName": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "testSummary.json",
      "title": "Outputname"
    },
    "isLocalUsage": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": false,
      "title": "Islocalusage"
    },
    "studentTestCounter": {
      "anyOf": [
        {
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Studenttestcounter"
    }
  },
  "title": "CodeAbilitySpecification",
  "type": "object",
  "x-model-name": "CodeAbilitySpecification"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilitySpecification {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilitySpecification', 'Expected an object');
    }

    // Optional field: executionDirectory
    if ('executionDirectory' in data && data.executionDirectory !== undefined && data.executionDirectory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: studentDirectory
    if ('studentDirectory' in data && data.studentDirectory !== undefined && data.studentDirectory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: referenceDirectory
    if ('referenceDirectory' in data && data.referenceDirectory !== undefined && data.referenceDirectory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: testDirectory
    if ('testDirectory' in data && data.testDirectory !== undefined && data.testDirectory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: outputDirectory
    if ('outputDirectory' in data && data.outputDirectory !== undefined && data.outputDirectory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: artifactDirectory
    if ('artifactDirectory' in data && data.artifactDirectory !== undefined && data.artifactDirectory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: testVersion
    if ('testVersion' in data && data.testVersion !== undefined && data.testVersion !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: storeGraphicsArtifacts
    if ('storeGraphicsArtifacts' in data && data.storeGraphicsArtifacts !== undefined && data.storeGraphicsArtifacts !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: outputName
    if ('outputName' in data && data.outputName !== undefined && data.outputName !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: isLocalUsage
    if ('isLocalUsage' in data && data.isLocalUsage !== undefined && data.isLocalUsage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: studentTestCounter
    if ('studentTestCounter' in data && data.studentTestCounter !== undefined && data.studentTestCounter !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilitySpecification', errors.join('; '));
    }

    return data as CodeAbilitySpecification;
  }

  safeValidate(data: any): { success: true; data: CodeAbilitySpecification } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilitySpecification', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityMetaProperty
 */
export class CodeAbilityMetaPropertyValidator extends BaseValidator<CodeAbilityMetaProperty> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CourseExecutionBackendConfig": {
      "properties": {
        "slug": {
          "title": "Slug",
          "type": "string"
        },
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Settings"
        }
      },
      "required": [
        "slug"
      ],
      "title": "CourseExecutionBackendConfig",
      "type": "object"
    }
  },
  "properties": {
    "studentSubmissionFiles": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Studentsubmissionfiles"
    },
    "additionalFiles": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Additionalfiles"
    },
    "testFiles": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Testfiles"
    },
    "studentTemplates": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Studenttemplates"
    },
    "executionBackend": {
      "anyOf": [
        {
          "$ref": "#/$defs/CourseExecutionBackendConfig"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "maxTestRuns": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Maxtestruns"
    },
    "maxSubmissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Maxsubmissions"
    },
    "maxGroupSize": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Maxgroupsize"
    }
  },
  "title": "CodeAbilityMetaProperty",
  "type": "object",
  "x-model-name": "CodeAbilityMetaProperty"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityMetaProperty {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityMetaProperty', 'Expected an object');
    }

    // Optional field: studentSubmissionFiles
    if ('studentSubmissionFiles' in data && data.studentSubmissionFiles !== undefined && data.studentSubmissionFiles !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: additionalFiles
    if ('additionalFiles' in data && data.additionalFiles !== undefined && data.additionalFiles !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: testFiles
    if ('testFiles' in data && data.testFiles !== undefined && data.testFiles !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: studentTemplates
    if ('studentTemplates' in data && data.studentTemplates !== undefined && data.studentTemplates !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: executionBackend
    if ('executionBackend' in data && data.executionBackend !== undefined && data.executionBackend !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: maxTestRuns
    if ('maxTestRuns' in data && data.maxTestRuns !== undefined && data.maxTestRuns !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: maxSubmissions
    if ('maxSubmissions' in data && data.maxSubmissions !== undefined && data.maxSubmissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: maxGroupSize
    if ('maxGroupSize' in data && data.maxGroupSize !== undefined && data.maxGroupSize !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityMetaProperty', errors.join('; '));
    }

    return data as CodeAbilityMetaProperty;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityMetaProperty } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityMetaProperty', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityReportSummary
 */
export class CodeAbilityReportSummaryValidator extends BaseValidator<CodeAbilityReportSummary> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "total": {
      "default": 0,
      "minimum": 0,
      "title": "Total",
      "type": "integer"
    },
    "passed": {
      "default": 0,
      "minimum": 0,
      "title": "Passed",
      "type": "integer"
    },
    "failed": {
      "default": 0,
      "minimum": 0,
      "title": "Failed",
      "type": "integer"
    },
    "skipped": {
      "default": 0,
      "minimum": 0,
      "title": "Skipped",
      "type": "integer"
    }
  },
  "title": "CodeAbilityReportSummary",
  "type": "object",
  "x-model-name": "CodeAbilityReportSummary"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityReportSummary {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityReportSummary', 'Expected an object');
    }

    // Optional field: total
    if ('total' in data && data.total !== undefined && data.total !== null) {
      if (typeof data.total !== 'number') {
        errors.push('Field total must be a number');
      }
    }

    // Optional field: passed
    if ('passed' in data && data.passed !== undefined && data.passed !== null) {
      if (typeof data.passed !== 'number') {
        errors.push('Field passed must be a number');
      }
    }

    // Optional field: failed
    if ('failed' in data && data.failed !== undefined && data.failed !== null) {
      if (typeof data.failed !== 'number') {
        errors.push('Field failed must be a number');
      }
    }

    // Optional field: skipped
    if ('skipped' in data && data.skipped !== undefined && data.skipped !== null) {
      if (typeof data.skipped !== 'number') {
        errors.push('Field skipped must be a number');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityReportSummary', errors.join('; '));
    }

    return data as CodeAbilityReportSummary;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityReportSummary } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityReportSummary', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityReleaseMeta
 */
export class CodeAbilityReleaseMetaValidator extends BaseValidator<CodeAbilityReleaseMeta> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityLink": {
      "properties": {
        "description": {
          "minLength": 0,
          "title": "Description",
          "type": "string"
        },
        "url": {
          "minLength": 1,
          "title": "Url",
          "type": "string"
        }
      },
      "required": [
        "description",
        "url"
      ],
      "title": "CodeAbilityLink",
      "type": "object"
    },
    "CodeAbilityMetaProperty": {
      "properties": {
        "studentSubmissionFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [],
          "title": "Studentsubmissionfiles"
        },
        "additionalFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [],
          "title": "Additionalfiles"
        },
        "testFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [],
          "title": "Testfiles"
        },
        "studentTemplates": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [],
          "title": "Studenttemplates"
        },
        "executionBackend": {
          "anyOf": [
            {
              "$ref": "#/$defs/CourseExecutionBackendConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "maxTestRuns": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Maxtestruns"
        },
        "maxSubmissions": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Maxsubmissions"
        },
        "maxGroupSize": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Maxgroupsize"
        }
      },
      "title": "CodeAbilityMetaProperty",
      "type": "object"
    },
    "CodeAbilityPerson": {
      "properties": {
        "name": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Name"
        },
        "email": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Email"
        },
        "affiliation": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Affiliation"
        }
      },
      "title": "CodeAbilityPerson",
      "type": "object"
    },
    "CourseExecutionBackendConfig": {
      "properties": {
        "slug": {
          "title": "Slug",
          "type": "string"
        },
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Settings"
        }
      },
      "required": [
        "slug"
      ],
      "title": "CourseExecutionBackendConfig",
      "type": "object"
    },
    "LanguageEnum": {
      "enum": [
        "de",
        "en"
      ],
      "title": "LanguageEnum",
      "type": "string"
    },
    "MetaTypeEnum": {
      "enum": [
        "course",
        "unit",
        "assignment"
      ],
      "title": "MetaTypeEnum",
      "type": "string"
    }
  },
  "properties": {
    "version": {
      "anyOf": [
        {
          "pattern": "^([1-9]\\\\d*|0)(\\\\.(([1-9]\\\\d*)|0)){0,3}$",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "1.0",
      "title": "Version"
    },
    "kind": {
      "anyOf": [
        {
          "$ref": "#/$defs/MetaTypeEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": "assignment"
    },
    "title": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "TITLE",
      "title": "Title"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "language": {
      "anyOf": [
        {
          "$ref": "#/$defs/LanguageEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": "en"
    },
    "license": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "Not specified",
      "title": "License"
    },
    "authors": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityPerson"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Authors"
    },
    "maintainers": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityPerson"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Maintainers"
    },
    "links": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityLink"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Links"
    },
    "supportingMaterial": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityLink"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Supportingmaterial"
    },
    "keywords": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Keywords"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/CodeAbilityMetaProperty"
        },
        {
          "type": "null"
        }
      ],
      "default": {
        "studentSubmissionFiles": [],
        "additionalFiles": [],
        "testFiles": [],
        "studentTemplates": [],
        "executionBackend": null,
        "maxTestRuns": null,
        "maxSubmissions": null,
        "maxGroupSize": null
      }
    }
  },
  "title": "CodeAbilityReleaseMeta",
  "type": "object",
  "x-model-name": "CodeAbilityReleaseMeta"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityReleaseMeta {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityReleaseMeta', 'Expected an object');
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: kind
    if ('kind' in data && data.kind !== undefined && data.kind !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: title
    if ('title' in data && data.title !== undefined && data.title !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: language
    if ('language' in data && data.language !== undefined && data.language !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: license
    if ('license' in data && data.license !== undefined && data.license !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: authors
    if ('authors' in data && data.authors !== undefined && data.authors !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: maintainers
    if ('maintainers' in data && data.maintainers !== undefined && data.maintainers !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: links
    if ('links' in data && data.links !== undefined && data.links !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: supportingMaterial
    if ('supportingMaterial' in data && data.supportingMaterial !== undefined && data.supportingMaterial !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: keywords
    if ('keywords' in data && data.keywords !== undefined && data.keywords !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityReleaseMeta', errors.join('; '));
    }

    return data as CodeAbilityReleaseMeta;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityReleaseMeta } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityReleaseMeta', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityUnitMeta
 */
export class CodeAbilityUnitMetaValidator extends BaseValidator<CodeAbilityUnitMeta> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityLink": {
      "properties": {
        "description": {
          "minLength": 0,
          "title": "Description",
          "type": "string"
        },
        "url": {
          "minLength": 1,
          "title": "Url",
          "type": "string"
        }
      },
      "required": [
        "description",
        "url"
      ],
      "title": "CodeAbilityLink",
      "type": "object"
    },
    "CodeAbilityMetaProperty": {
      "properties": {
        "studentSubmissionFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [],
          "title": "Studentsubmissionfiles"
        },
        "additionalFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [],
          "title": "Additionalfiles"
        },
        "testFiles": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [],
          "title": "Testfiles"
        },
        "studentTemplates": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": [],
          "title": "Studenttemplates"
        },
        "executionBackend": {
          "anyOf": [
            {
              "$ref": "#/$defs/CourseExecutionBackendConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "maxTestRuns": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Maxtestruns"
        },
        "maxSubmissions": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Maxsubmissions"
        },
        "maxGroupSize": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Maxgroupsize"
        }
      },
      "title": "CodeAbilityMetaProperty",
      "type": "object"
    },
    "CodeAbilityPerson": {
      "properties": {
        "name": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Name"
        },
        "email": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Email"
        },
        "affiliation": {
          "anyOf": [
            {
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Affiliation"
        }
      },
      "title": "CodeAbilityPerson",
      "type": "object"
    },
    "CourseExecutionBackendConfig": {
      "properties": {
        "slug": {
          "title": "Slug",
          "type": "string"
        },
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Settings"
        }
      },
      "required": [
        "slug"
      ],
      "title": "CourseExecutionBackendConfig",
      "type": "object"
    },
    "LanguageEnum": {
      "enum": [
        "de",
        "en"
      ],
      "title": "LanguageEnum",
      "type": "string"
    },
    "MetaTypeEnum": {
      "enum": [
        "course",
        "unit",
        "assignment"
      ],
      "title": "MetaTypeEnum",
      "type": "string"
    }
  },
  "properties": {
    "version": {
      "anyOf": [
        {
          "pattern": "^([1-9]\\\\d*|0)(\\\\.(([1-9]\\\\d*)|0)){0,3}$",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "1.0",
      "title": "Version"
    },
    "kind": {
      "anyOf": [
        {
          "$ref": "#/$defs/MetaTypeEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": "assignment"
    },
    "title": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "TITLE",
      "title": "Title"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "language": {
      "anyOf": [
        {
          "$ref": "#/$defs/LanguageEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": "en"
    },
    "license": {
      "anyOf": [
        {
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "Not specified",
      "title": "License"
    },
    "authors": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityPerson"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Authors"
    },
    "maintainers": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityPerson"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Maintainers"
    },
    "links": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityLink"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Links"
    },
    "supportingMaterial": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityLink"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Supportingmaterial"
    },
    "keywords": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Keywords"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/CodeAbilityMetaProperty"
        },
        {
          "type": "null"
        }
      ],
      "default": {
        "studentSubmissionFiles": [],
        "additionalFiles": [],
        "testFiles": [],
        "studentTemplates": [],
        "executionBackend": null,
        "maxTestRuns": null,
        "maxSubmissions": null,
        "maxGroupSize": null
      }
    },
    "type": {
      "title": "Type",
      "type": "string"
    }
  },
  "required": [
    "type"
  ],
  "title": "CodeAbilityUnitMeta",
  "type": "object",
  "x-model-name": "CodeAbilityUnitMeta"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityUnitMeta {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityUnitMeta', 'Expected an object');
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: kind
    if ('kind' in data && data.kind !== undefined && data.kind !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: title
    if ('title' in data && data.title !== undefined && data.title !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: language
    if ('language' in data && data.language !== undefined && data.language !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: license
    if ('license' in data && data.license !== undefined && data.license !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: authors
    if ('authors' in data && data.authors !== undefined && data.authors !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: maintainers
    if ('maintainers' in data && data.maintainers !== undefined && data.maintainers !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: links
    if ('links' in data && data.links !== undefined && data.links !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: supportingMaterial
    if ('supportingMaterial' in data && data.supportingMaterial !== undefined && data.supportingMaterial !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: keywords
    if ('keywords' in data && data.keywords !== undefined && data.keywords !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: type
    if (!('type' in data)) {
      errors.push('Missing required field: type');
    } else {
      if (typeof data.type !== 'string') {
        errors.push('Field type must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityUnitMeta', errors.join('; '));
    }

    return data as CodeAbilityUnitMeta;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityUnitMeta } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityUnitMeta', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityReportProperties
 */
export class CodeAbilityReportPropertiesValidator extends BaseValidator<CodeAbilityReportProperties> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityReportSummary": {
      "properties": {
        "total": {
          "default": 0,
          "minimum": 0,
          "title": "Total",
          "type": "integer"
        },
        "passed": {
          "default": 0,
          "minimum": 0,
          "title": "Passed",
          "type": "integer"
        },
        "failed": {
          "default": 0,
          "minimum": 0,
          "title": "Failed",
          "type": "integer"
        },
        "skipped": {
          "default": 0,
          "minimum": 0,
          "title": "Skipped",
          "type": "integer"
        }
      },
      "title": "CodeAbilityReportSummary",
      "type": "object"
    },
    "ResultEnum": {
      "enum": [
        "PASSED",
        "FAILED",
        "SKIPPED"
      ],
      "title": "ResultEnum",
      "type": "string"
    },
    "StatusEnum": {
      "enum": [
        "SCHEDULED",
        "COMPLETED",
        "TIMEDOUT",
        "CRASHED",
        "CANCELLED",
        "SKIPPED",
        "FAILED"
      ],
      "title": "StatusEnum",
      "type": "string"
    }
  },
  "properties": {
    "timestamp": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Timestamp"
    },
    "type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Type"
    },
    "version": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version"
    },
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/StatusEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "result": {
      "anyOf": [
        {
          "$ref": "#/$defs/ResultEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "summary": {
      "anyOf": [
        {
          "$ref": "#/$defs/CodeAbilityReportSummary"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "statusMessage": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Statusmessage"
    },
    "resultMessage": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Resultmessage"
    },
    "details": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Details"
    },
    "setup": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Setup"
    },
    "teardown": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Teardown"
    },
    "duration": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Duration"
    },
    "executionDuration": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Executionduration"
    },
    "environment": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Environment"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "debug": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Debug"
    }
  },
  "title": "CodeAbilityReportProperties",
  "type": "object",
  "x-model-name": "CodeAbilityReportProperties"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityReportProperties {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityReportProperties', 'Expected an object');
    }

    // Optional field: timestamp
    if ('timestamp' in data && data.timestamp !== undefined && data.timestamp !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: type
    if ('type' in data && data.type !== undefined && data.type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result
    if ('result' in data && data.result !== undefined && data.result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: summary
    if ('summary' in data && data.summary !== undefined && data.summary !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: statusMessage
    if ('statusMessage' in data && data.statusMessage !== undefined && data.statusMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: resultMessage
    if ('resultMessage' in data && data.resultMessage !== undefined && data.resultMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: details
    if ('details' in data && data.details !== undefined && data.details !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: setup
    if ('setup' in data && data.setup !== undefined && data.setup !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: teardown
    if ('teardown' in data && data.teardown !== undefined && data.teardown !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: duration
    if ('duration' in data && data.duration !== undefined && data.duration !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: executionDuration
    if ('executionDuration' in data && data.executionDuration !== undefined && data.executionDuration !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: environment
    if ('environment' in data && data.environment !== undefined && data.environment !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: debug
    if ('debug' in data && data.debug !== undefined && data.debug !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityReportProperties', errors.join('; '));
    }

    return data as CodeAbilityReportProperties;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityReportProperties } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityReportProperties', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityReportSub
 */
export class CodeAbilityReportSubValidator extends BaseValidator<CodeAbilityReportSub> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityReportSummary": {
      "properties": {
        "total": {
          "default": 0,
          "minimum": 0,
          "title": "Total",
          "type": "integer"
        },
        "passed": {
          "default": 0,
          "minimum": 0,
          "title": "Passed",
          "type": "integer"
        },
        "failed": {
          "default": 0,
          "minimum": 0,
          "title": "Failed",
          "type": "integer"
        },
        "skipped": {
          "default": 0,
          "minimum": 0,
          "title": "Skipped",
          "type": "integer"
        }
      },
      "title": "CodeAbilityReportSummary",
      "type": "object"
    },
    "ResultEnum": {
      "enum": [
        "PASSED",
        "FAILED",
        "SKIPPED"
      ],
      "title": "ResultEnum",
      "type": "string"
    },
    "StatusEnum": {
      "enum": [
        "SCHEDULED",
        "COMPLETED",
        "TIMEDOUT",
        "CRASHED",
        "CANCELLED",
        "SKIPPED",
        "FAILED"
      ],
      "title": "StatusEnum",
      "type": "string"
    }
  },
  "properties": {
    "timestamp": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Timestamp"
    },
    "type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Type"
    },
    "version": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version"
    },
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/StatusEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "result": {
      "anyOf": [
        {
          "$ref": "#/$defs/ResultEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "summary": {
      "anyOf": [
        {
          "$ref": "#/$defs/CodeAbilityReportSummary"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "statusMessage": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Statusmessage"
    },
    "resultMessage": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Resultmessage"
    },
    "details": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Details"
    },
    "setup": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Setup"
    },
    "teardown": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Teardown"
    },
    "duration": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Duration"
    },
    "executionDuration": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Executionduration"
    },
    "environment": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Environment"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "debug": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Debug"
    }
  },
  "title": "CodeAbilityReportSub",
  "type": "object",
  "x-model-name": "CodeAbilityReportSub"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityReportSub {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityReportSub', 'Expected an object');
    }

    // Optional field: timestamp
    if ('timestamp' in data && data.timestamp !== undefined && data.timestamp !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: type
    if ('type' in data && data.type !== undefined && data.type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result
    if ('result' in data && data.result !== undefined && data.result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: summary
    if ('summary' in data && data.summary !== undefined && data.summary !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: statusMessage
    if ('statusMessage' in data && data.statusMessage !== undefined && data.statusMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: resultMessage
    if ('resultMessage' in data && data.resultMessage !== undefined && data.resultMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: details
    if ('details' in data && data.details !== undefined && data.details !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: setup
    if ('setup' in data && data.setup !== undefined && data.setup !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: teardown
    if ('teardown' in data && data.teardown !== undefined && data.teardown !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: duration
    if ('duration' in data && data.duration !== undefined && data.duration !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: executionDuration
    if ('executionDuration' in data && data.executionDuration !== undefined && data.executionDuration !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: environment
    if ('environment' in data && data.environment !== undefined && data.environment !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: debug
    if ('debug' in data && data.debug !== undefined && data.debug !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityReportSub', errors.join('; '));
    }

    return data as CodeAbilityReportSub;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityReportSub } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityReportSub', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityReportMain
 */
export class CodeAbilityReportMainValidator extends BaseValidator<CodeAbilityReportMain> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityReportSub": {
      "properties": {
        "timestamp": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Timestamp"
        },
        "type": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Type"
        },
        "version": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Version"
        },
        "name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Name"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Description"
        },
        "status": {
          "anyOf": [
            {
              "$ref": "#/$defs/StatusEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "result": {
          "anyOf": [
            {
              "$ref": "#/$defs/ResultEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "summary": {
          "anyOf": [
            {
              "$ref": "#/$defs/CodeAbilityReportSummary"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "statusMessage": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Statusmessage"
        },
        "resultMessage": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Resultmessage"
        },
        "details": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Details"
        },
        "setup": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Setup"
        },
        "teardown": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Teardown"
        },
        "duration": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Duration"
        },
        "executionDuration": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Executionduration"
        },
        "environment": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Environment"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Properties"
        },
        "debug": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Debug"
        }
      },
      "title": "CodeAbilityReportSub",
      "type": "object"
    },
    "CodeAbilityReportSummary": {
      "properties": {
        "total": {
          "default": 0,
          "minimum": 0,
          "title": "Total",
          "type": "integer"
        },
        "passed": {
          "default": 0,
          "minimum": 0,
          "title": "Passed",
          "type": "integer"
        },
        "failed": {
          "default": 0,
          "minimum": 0,
          "title": "Failed",
          "type": "integer"
        },
        "skipped": {
          "default": 0,
          "minimum": 0,
          "title": "Skipped",
          "type": "integer"
        }
      },
      "title": "CodeAbilityReportSummary",
      "type": "object"
    },
    "ResultEnum": {
      "enum": [
        "PASSED",
        "FAILED",
        "SKIPPED"
      ],
      "title": "ResultEnum",
      "type": "string"
    },
    "StatusEnum": {
      "enum": [
        "SCHEDULED",
        "COMPLETED",
        "TIMEDOUT",
        "CRASHED",
        "CANCELLED",
        "SKIPPED",
        "FAILED"
      ],
      "title": "StatusEnum",
      "type": "string"
    }
  },
  "properties": {
    "timestamp": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Timestamp"
    },
    "type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Type"
    },
    "version": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version"
    },
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/StatusEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "result": {
      "anyOf": [
        {
          "$ref": "#/$defs/ResultEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "summary": {
      "anyOf": [
        {
          "$ref": "#/$defs/CodeAbilityReportSummary"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "statusMessage": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Statusmessage"
    },
    "resultMessage": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Resultmessage"
    },
    "details": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Details"
    },
    "setup": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Setup"
    },
    "teardown": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Teardown"
    },
    "duration": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Duration"
    },
    "executionDuration": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Executionduration"
    },
    "environment": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Environment"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "debug": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Debug"
    },
    "tests": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityReportSub"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Tests"
    }
  },
  "title": "CodeAbilityReportMain",
  "type": "object",
  "x-model-name": "CodeAbilityReportMain"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityReportMain {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityReportMain', 'Expected an object');
    }

    // Optional field: timestamp
    if ('timestamp' in data && data.timestamp !== undefined && data.timestamp !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: type
    if ('type' in data && data.type !== undefined && data.type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result
    if ('result' in data && data.result !== undefined && data.result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: summary
    if ('summary' in data && data.summary !== undefined && data.summary !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: statusMessage
    if ('statusMessage' in data && data.statusMessage !== undefined && data.statusMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: resultMessage
    if ('resultMessage' in data && data.resultMessage !== undefined && data.resultMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: details
    if ('details' in data && data.details !== undefined && data.details !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: setup
    if ('setup' in data && data.setup !== undefined && data.setup !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: teardown
    if ('teardown' in data && data.teardown !== undefined && data.teardown !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: duration
    if ('duration' in data && data.duration !== undefined && data.duration !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: executionDuration
    if ('executionDuration' in data && data.executionDuration !== undefined && data.executionDuration !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: environment
    if ('environment' in data && data.environment !== undefined && data.environment !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: debug
    if ('debug' in data && data.debug !== undefined && data.debug !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: tests
    if ('tests' in data && data.tests !== undefined && data.tests !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityReportMain', errors.join('; '));
    }

    return data as CodeAbilityReportMain;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityReportMain } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityReportMain', String(error)) };
    }
  }
}

/**
 * Validator for CodeAbilityReport
 */
export class CodeAbilityReportValidator extends BaseValidator<CodeAbilityReport> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CodeAbilityReportMain": {
      "properties": {
        "timestamp": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Timestamp"
        },
        "type": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Type"
        },
        "version": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Version"
        },
        "name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Name"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Description"
        },
        "status": {
          "anyOf": [
            {
              "$ref": "#/$defs/StatusEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "result": {
          "anyOf": [
            {
              "$ref": "#/$defs/ResultEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "summary": {
          "anyOf": [
            {
              "$ref": "#/$defs/CodeAbilityReportSummary"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "statusMessage": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Statusmessage"
        },
        "resultMessage": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Resultmessage"
        },
        "details": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Details"
        },
        "setup": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Setup"
        },
        "teardown": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Teardown"
        },
        "duration": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Duration"
        },
        "executionDuration": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Executionduration"
        },
        "environment": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Environment"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Properties"
        },
        "debug": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Debug"
        },
        "tests": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/CodeAbilityReportSub"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Tests"
        }
      },
      "title": "CodeAbilityReportMain",
      "type": "object"
    },
    "CodeAbilityReportSub": {
      "properties": {
        "timestamp": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Timestamp"
        },
        "type": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Type"
        },
        "version": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Version"
        },
        "name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Name"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Description"
        },
        "status": {
          "anyOf": [
            {
              "$ref": "#/$defs/StatusEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "result": {
          "anyOf": [
            {
              "$ref": "#/$defs/ResultEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "summary": {
          "anyOf": [
            {
              "$ref": "#/$defs/CodeAbilityReportSummary"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "statusMessage": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Statusmessage"
        },
        "resultMessage": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Resultmessage"
        },
        "details": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Details"
        },
        "setup": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Setup"
        },
        "teardown": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Teardown"
        },
        "duration": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Duration"
        },
        "executionDuration": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Executionduration"
        },
        "environment": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Environment"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Properties"
        },
        "debug": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Debug"
        }
      },
      "title": "CodeAbilityReportSub",
      "type": "object"
    },
    "CodeAbilityReportSummary": {
      "properties": {
        "total": {
          "default": 0,
          "minimum": 0,
          "title": "Total",
          "type": "integer"
        },
        "passed": {
          "default": 0,
          "minimum": 0,
          "title": "Passed",
          "type": "integer"
        },
        "failed": {
          "default": 0,
          "minimum": 0,
          "title": "Failed",
          "type": "integer"
        },
        "skipped": {
          "default": 0,
          "minimum": 0,
          "title": "Skipped",
          "type": "integer"
        }
      },
      "title": "CodeAbilityReportSummary",
      "type": "object"
    },
    "ResultEnum": {
      "enum": [
        "PASSED",
        "FAILED",
        "SKIPPED"
      ],
      "title": "ResultEnum",
      "type": "string"
    },
    "StatusEnum": {
      "enum": [
        "SCHEDULED",
        "COMPLETED",
        "TIMEDOUT",
        "CRASHED",
        "CANCELLED",
        "SKIPPED",
        "FAILED"
      ],
      "title": "StatusEnum",
      "type": "string"
    }
  },
  "properties": {
    "timestamp": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Timestamp"
    },
    "type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Type"
    },
    "version": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version"
    },
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Description"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/StatusEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "result": {
      "anyOf": [
        {
          "$ref": "#/$defs/ResultEnum"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "summary": {
      "anyOf": [
        {
          "$ref": "#/$defs/CodeAbilityReportSummary"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "statusMessage": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Statusmessage"
    },
    "resultMessage": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Resultmessage"
    },
    "details": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Details"
    },
    "setup": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Setup"
    },
    "teardown": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Teardown"
    },
    "duration": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Duration"
    },
    "executionDuration": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Executionduration"
    },
    "environment": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Environment"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "debug": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Debug"
    },
    "tests": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/CodeAbilityReportMain"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Tests"
    }
  },
  "title": "CodeAbilityReport",
  "type": "object",
  "x-model-name": "CodeAbilityReport"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CodeAbilityReport {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CodeAbilityReport', 'Expected an object');
    }

    // Optional field: timestamp
    if ('timestamp' in data && data.timestamp !== undefined && data.timestamp !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: type
    if ('type' in data && data.type !== undefined && data.type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result
    if ('result' in data && data.result !== undefined && data.result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: summary
    if ('summary' in data && data.summary !== undefined && data.summary !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: statusMessage
    if ('statusMessage' in data && data.statusMessage !== undefined && data.statusMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: resultMessage
    if ('resultMessage' in data && data.resultMessage !== undefined && data.resultMessage !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: details
    if ('details' in data && data.details !== undefined && data.details !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: setup
    if ('setup' in data && data.setup !== undefined && data.setup !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: teardown
    if ('teardown' in data && data.teardown !== undefined && data.teardown !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: duration
    if ('duration' in data && data.duration !== undefined && data.duration !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: executionDuration
    if ('executionDuration' in data && data.executionDuration !== undefined && data.executionDuration !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: environment
    if ('environment' in data && data.environment !== undefined && data.environment !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: debug
    if ('debug' in data && data.debug !== undefined && data.debug !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: tests
    if ('tests' in data && data.tests !== undefined && data.tests !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CodeAbilityReport', errors.join('; '));
    }

    return data as CodeAbilityReport;
  }

  safeValidate(data: any): { success: true; data: CodeAbilityReport } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CodeAbilityReport', String(error)) };
    }
  }
}

/**
 * Semantic version following semver.org spec (subset).

    Supports format: <major>.<minor>.<patch>[-<prerelease>]

    Examples:
        - 1.0.0
        - 2.1.3
        - 1.0.0-alpha
        - 3.2.1-beta.2
 */
export class SemanticVersionValidator extends BaseValidator<SemanticVersion> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Semantic version following semver.org spec (subset).\\n\\n    Supports format: <major>.<minor>.<patch>[-<prerelease>]\\n\\n    Examples:\\n        - 1.0.0\\n        - 2.1.3\\n        - 1.0.0-alpha\\n        - 3.2.1-beta.2",
  "properties": {
    "major": {
      "description": "Major version number",
      "minimum": 0,
      "title": "Major",
      "type": "integer"
    },
    "minor": {
      "description": "Minor version number",
      "minimum": 0,
      "title": "Minor",
      "type": "integer"
    },
    "patch": {
      "description": "Patch version number",
      "minimum": 0,
      "title": "Patch",
      "type": "integer"
    },
    "prerelease": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Optional prerelease identifier",
      "title": "Prerelease"
    }
  },
  "required": [
    "major",
    "minor",
    "patch"
  ],
  "title": "SemanticVersion",
  "type": "object",
  "x-model-name": "SemanticVersion"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SemanticVersion {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SemanticVersion', 'Expected an object');
    }

    // Required field: major
    if (!('major' in data)) {
      errors.push('Missing required field: major');
    } else {
      if (typeof data.major !== 'number') {
        errors.push('Field major must be a number');
      }
    }

    // Required field: minor
    if (!('minor' in data)) {
      errors.push('Missing required field: minor');
    } else {
      if (typeof data.minor !== 'number') {
        errors.push('Field minor must be a number');
      }
    }

    // Required field: patch
    if (!('patch' in data)) {
      errors.push('Missing required field: patch');
    } else {
      if (typeof data.patch !== 'number') {
        errors.push('Field patch must be a number');
      }
    }

    // Optional field: prerelease
    if ('prerelease' in data && data.prerelease !== undefined && data.prerelease !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SemanticVersion', errors.join('; '));
    }

    return data as SemanticVersion;
  }

  safeValidate(data: any): { success: true; data: SemanticVersion } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SemanticVersion', String(error)) };
    }
  }
}

/**
 * Member information in a submission group.
 */
export class TutorSubmissionGroupMemberValidator extends BaseValidator<TutorSubmissionGroupMember> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Member information in a submission group.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "user_id": {
      "title": "User Id",
      "type": "string"
    },
    "given_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Given Name"
    },
    "family_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Family Name"
    },
    "email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Email"
    }
  },
  "required": [
    "id",
    "course_member_id",
    "user_id"
  ],
  "title": "TutorSubmissionGroupMember",
  "type": "object",
  "x-model-name": "TutorSubmissionGroupMember"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TutorSubmissionGroupMember {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TutorSubmissionGroupMember', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Optional field: given_name
    if ('given_name' in data && data.given_name !== undefined && data.given_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: family_name
    if ('family_name' in data && data.family_name !== undefined && data.family_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: email
    if ('email' in data && data.email !== undefined && data.email !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TutorSubmissionGroupMember', errors.join('; '));
    }

    return data as TutorSubmissionGroupMember;
  }

  safeValidate(data: any): { success: true; data: TutorSubmissionGroupMember } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TutorSubmissionGroupMember', String(error)) };
    }
  }
}

/**
 * List view of submission groups for tutors.
 */
export class TutorSubmissionGroupListValidator extends BaseValidator<TutorSubmissionGroupList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "List view of submission groups for tutors.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "display_name": {
      "title": "Display Name",
      "type": "string"
    },
    "max_group_size": {
      "title": "Max Group Size",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "max_test_runs": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Test Runs"
    },
    "member_count": {
      "default": 0,
      "title": "Member Count",
      "type": "integer"
    },
    "submission_count": {
      "default": 0,
      "title": "Submission Count",
      "type": "integer"
    },
    "latest_submission_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Latest Submission At"
    },
    "has_ungraded_submissions": {
      "default": false,
      "title": "Has Ungraded Submissions",
      "type": "boolean"
    },
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "format": "date-time",
      "title": "Updated At",
      "type": "string"
    }
  },
  "required": [
    "id",
    "course_id",
    "course_content_id",
    "display_name",
    "max_group_size",
    "created_at",
    "updated_at"
  ],
  "title": "TutorSubmissionGroupList",
  "type": "object",
  "x-model-name": "TutorSubmissionGroupList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TutorSubmissionGroupList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TutorSubmissionGroupList', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: display_name
    if (!('display_name' in data)) {
      errors.push('Missing required field: display_name');
    } else {
      if (typeof data.display_name !== 'string') {
        errors.push('Field display_name must be a string');
      }
    }

    // Required field: max_group_size
    if (!('max_group_size' in data)) {
      errors.push('Missing required field: max_group_size');
    } else {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_test_runs
    if ('max_test_runs' in data && data.max_test_runs !== undefined && data.max_test_runs !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: member_count
    if ('member_count' in data && data.member_count !== undefined && data.member_count !== null) {
      if (typeof data.member_count !== 'number') {
        errors.push('Field member_count must be a number');
      }
    }

    // Optional field: submission_count
    if ('submission_count' in data && data.submission_count !== undefined && data.submission_count !== null) {
      if (typeof data.submission_count !== 'number') {
        errors.push('Field submission_count must be a number');
      }
    }

    // Optional field: latest_submission_at
    if ('latest_submission_at' in data && data.latest_submission_at !== undefined && data.latest_submission_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: has_ungraded_submissions
    if ('has_ungraded_submissions' in data && data.has_ungraded_submissions !== undefined && data.has_ungraded_submissions !== null) {
      if (typeof data.has_ungraded_submissions !== 'boolean') {
        errors.push('Field has_ungraded_submissions must be a boolean');
      }
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: updated_at
    if (!('updated_at' in data)) {
      errors.push('Missing required field: updated_at');
    } else {
      if (typeof data.updated_at !== 'string') {
        errors.push('Field updated_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('TutorSubmissionGroupList', errors.join('; '));
    }

    return data as TutorSubmissionGroupList;
  }

  safeValidate(data: any): { success: true; data: TutorSubmissionGroupList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TutorSubmissionGroupList', String(error)) };
    }
  }
}

/**
 * Detailed view of a submission group for tutors.
 */
export class TutorSubmissionGroupGetValidator extends BaseValidator<TutorSubmissionGroupGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TutorSubmissionGroupMember": {
      "description": "Member information in a submission group.",
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "course_member_id": {
          "title": "Course Member Id",
          "type": "string"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "given_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Family Name"
        },
        "email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Email"
        }
      },
      "required": [
        "id",
        "course_member_id",
        "user_id"
      ],
      "title": "TutorSubmissionGroupMember",
      "type": "object"
    }
  },
  "description": "Detailed view of a submission group for tutors.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "display_name": {
      "title": "Display Name",
      "type": "string"
    },
    "max_group_size": {
      "title": "Max Group Size",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "max_test_runs": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Test Runs"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "members": {
      "default": [],
      "items": {
        "$ref": "#/$defs/TutorSubmissionGroupMember"
      },
      "title": "Members",
      "type": "array"
    },
    "member_count": {
      "default": 0,
      "title": "Member Count",
      "type": "integer"
    },
    "submission_count": {
      "default": 0,
      "title": "Submission Count",
      "type": "integer"
    },
    "test_run_count": {
      "default": 0,
      "title": "Test Run Count",
      "type": "integer"
    },
    "latest_submission_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Latest Submission At"
    },
    "latest_submission_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Latest Submission Id"
    },
    "has_ungraded_submissions": {
      "default": false,
      "title": "Has Ungraded Submissions",
      "type": "boolean"
    },
    "graded_submission_count": {
      "default": 0,
      "title": "Graded Submission Count",
      "type": "integer"
    },
    "latest_grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Latest Grade"
    },
    "average_grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Average Grade"
    },
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "format": "date-time",
      "title": "Updated At",
      "type": "string"
    }
  },
  "required": [
    "id",
    "course_id",
    "course_content_id",
    "display_name",
    "max_group_size",
    "created_at",
    "updated_at"
  ],
  "title": "TutorSubmissionGroupGet",
  "type": "object",
  "x-model-name": "TutorSubmissionGroupGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TutorSubmissionGroupGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TutorSubmissionGroupGet', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: display_name
    if (!('display_name' in data)) {
      errors.push('Missing required field: display_name');
    } else {
      if (typeof data.display_name !== 'string') {
        errors.push('Field display_name must be a string');
      }
    }

    // Required field: max_group_size
    if (!('max_group_size' in data)) {
      errors.push('Missing required field: max_group_size');
    } else {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_test_runs
    if ('max_test_runs' in data && data.max_test_runs !== undefined && data.max_test_runs !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: members
    if ('members' in data && data.members !== undefined && data.members !== null) {
      if (!Array.isArray(data.members)) {
        errors.push('Field members must be an array');
      }
    }

    // Optional field: member_count
    if ('member_count' in data && data.member_count !== undefined && data.member_count !== null) {
      if (typeof data.member_count !== 'number') {
        errors.push('Field member_count must be a number');
      }
    }

    // Optional field: submission_count
    if ('submission_count' in data && data.submission_count !== undefined && data.submission_count !== null) {
      if (typeof data.submission_count !== 'number') {
        errors.push('Field submission_count must be a number');
      }
    }

    // Optional field: test_run_count
    if ('test_run_count' in data && data.test_run_count !== undefined && data.test_run_count !== null) {
      if (typeof data.test_run_count !== 'number') {
        errors.push('Field test_run_count must be a number');
      }
    }

    // Optional field: latest_submission_at
    if ('latest_submission_at' in data && data.latest_submission_at !== undefined && data.latest_submission_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: latest_submission_id
    if ('latest_submission_id' in data && data.latest_submission_id !== undefined && data.latest_submission_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: has_ungraded_submissions
    if ('has_ungraded_submissions' in data && data.has_ungraded_submissions !== undefined && data.has_ungraded_submissions !== null) {
      if (typeof data.has_ungraded_submissions !== 'boolean') {
        errors.push('Field has_ungraded_submissions must be a boolean');
      }
    }

    // Optional field: graded_submission_count
    if ('graded_submission_count' in data && data.graded_submission_count !== undefined && data.graded_submission_count !== null) {
      if (typeof data.graded_submission_count !== 'number') {
        errors.push('Field graded_submission_count must be a number');
      }
    }

    // Optional field: latest_grade
    if ('latest_grade' in data && data.latest_grade !== undefined && data.latest_grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: average_grade
    if ('average_grade' in data && data.average_grade !== undefined && data.average_grade !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: updated_at
    if (!('updated_at' in data)) {
      errors.push('Missing required field: updated_at');
    } else {
      if (typeof data.updated_at !== 'string') {
        errors.push('Field updated_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('TutorSubmissionGroupGet', errors.join('; '));
    }

    return data as TutorSubmissionGroupGet;
  }

  safeValidate(data: any): { success: true; data: TutorSubmissionGroupGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TutorSubmissionGroupGet', String(error)) };
    }
  }
}

/**
 * Query parameters for filtering submission groups.
 */
export class TutorSubmissionGroupQueryValidator extends BaseValidator<TutorSubmissionGroupQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Query parameters for filtering submission groups.",
  "properties": {
    "course_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Id"
    },
    "course_content_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Id"
    },
    "course_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Group Id"
    },
    "has_submissions": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Has Submissions"
    },
    "has_ungraded_submissions": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Has Ungraded Submissions"
    },
    "limit": {
      "default": 100,
      "title": "Limit",
      "type": "integer"
    },
    "offset": {
      "default": 0,
      "title": "Offset",
      "type": "integer"
    }
  },
  "title": "TutorSubmissionGroupQuery",
  "type": "object",
  "x-model-name": "TutorSubmissionGroupQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TutorSubmissionGroupQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TutorSubmissionGroupQuery', 'Expected an object');
    }

    // Optional field: course_id
    if ('course_id' in data && data.course_id !== undefined && data.course_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_id
    if ('course_content_id' in data && data.course_content_id !== undefined && data.course_content_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_group_id
    if ('course_group_id' in data && data.course_group_id !== undefined && data.course_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: has_submissions
    if ('has_submissions' in data && data.has_submissions !== undefined && data.has_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: has_ungraded_submissions
    if ('has_ungraded_submissions' in data && data.has_ungraded_submissions !== undefined && data.has_ungraded_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      if (typeof data.limit !== 'number') {
        errors.push('Field limit must be a number');
      }
    }

    // Optional field: offset
    if ('offset' in data && data.offset !== undefined && data.offset !== null) {
      if (typeof data.offset !== 'number') {
        errors.push('Field offset must be a number');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('TutorSubmissionGroupQuery', errors.join('; '));
    }

    return data as TutorSubmissionGroupQuery;
  }

  safeValidate(data: any): { success: true; data: TutorSubmissionGroupQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TutorSubmissionGroupQuery', String(error)) };
    }
  }
}

/**
 * Metadata for storage objects
 */
export class StorageObjectMetadataValidator extends BaseValidator<StorageObjectMetadata> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Metadata for storage objects",
  "properties": {
    "content_type": {
      "description": "MIME type of the object",
      "title": "Content Type",
      "type": "string"
    },
    "size": {
      "description": "Size of the object in bytes",
      "title": "Size",
      "type": "integer"
    },
    "etag": {
      "description": "Entity tag of the object",
      "title": "Etag",
      "type": "string"
    },
    "last_modified": {
      "description": "Last modification timestamp",
      "format": "date-time",
      "title": "Last Modified",
      "type": "string"
    },
    "metadata": {
      "anyOf": [
        {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Custom metadata",
      "title": "Metadata"
    }
  },
  "required": [
    "content_type",
    "size",
    "etag",
    "last_modified"
  ],
  "title": "StorageObjectMetadata",
  "type": "object",
  "x-model-name": "StorageObjectMetadata"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StorageObjectMetadata {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StorageObjectMetadata', 'Expected an object');
    }

    // Required field: content_type
    if (!('content_type' in data)) {
      errors.push('Missing required field: content_type');
    } else {
      if (typeof data.content_type !== 'string') {
        errors.push('Field content_type must be a string');
      }
    }

    // Required field: size
    if (!('size' in data)) {
      errors.push('Missing required field: size');
    } else {
      if (typeof data.size !== 'number') {
        errors.push('Field size must be a number');
      }
    }

    // Required field: etag
    if (!('etag' in data)) {
      errors.push('Missing required field: etag');
    } else {
      if (typeof data.etag !== 'string') {
        errors.push('Field etag must be a string');
      }
    }

    // Required field: last_modified
    if (!('last_modified' in data)) {
      errors.push('Missing required field: last_modified');
    } else {
      if (typeof data.last_modified !== 'string') {
        errors.push('Field last_modified must be a string');
      }
    }

    // Optional field: metadata
    if ('metadata' in data && data.metadata !== undefined && data.metadata !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StorageObjectMetadata', errors.join('; '));
    }

    return data as StorageObjectMetadata;
  }

  safeValidate(data: any): { success: true; data: StorageObjectMetadata } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StorageObjectMetadata', String(error)) };
    }
  }
}

/**
 * DTO for creating/uploading a storage object
 */
export class StorageObjectCreateValidator extends BaseValidator<StorageObjectCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for creating/uploading a storage object",
  "properties": {
    "object_key": {
      "description": "Key/path for the object in the bucket",
      "title": "Object Key",
      "type": "string"
    },
    "bucket_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Target bucket name",
      "title": "Bucket Name"
    },
    "metadata": {
      "anyOf": [
        {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Custom metadata for the object",
      "title": "Metadata"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "MIME type of the object",
      "title": "Content Type"
    }
  },
  "required": [
    "object_key"
  ],
  "title": "StorageObjectCreate",
  "type": "object",
  "x-model-name": "StorageObjectCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StorageObjectCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StorageObjectCreate', 'Expected an object');
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Optional field: bucket_name
    if ('bucket_name' in data && data.bucket_name !== undefined && data.bucket_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: metadata
    if ('metadata' in data && data.metadata !== undefined && data.metadata !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StorageObjectCreate', errors.join('; '));
    }

    return data as StorageObjectCreate;
  }

  safeValidate(data: any): { success: true; data: StorageObjectCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StorageObjectCreate', String(error)) };
    }
  }
}

/**
 * DTO for retrieving a storage object
 */
export class StorageObjectGetValidator extends BaseValidator<StorageObjectGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for retrieving a storage object",
  "properties": {
    "content_type": {
      "description": "MIME type of the object",
      "title": "Content Type",
      "type": "string"
    },
    "size": {
      "description": "Size of the object in bytes",
      "title": "Size",
      "type": "integer"
    },
    "etag": {
      "description": "Entity tag of the object",
      "title": "Etag",
      "type": "string"
    },
    "last_modified": {
      "description": "Last modification timestamp",
      "format": "date-time",
      "title": "Last Modified",
      "type": "string"
    },
    "metadata": {
      "anyOf": [
        {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Custom metadata",
      "title": "Metadata"
    },
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "description": "Storage object ID",
      "title": "Id",
      "type": "integer"
    },
    "object_key": {
      "description": "Object key/path in the bucket",
      "title": "Object Key",
      "type": "string"
    },
    "bucket_name": {
      "description": "Bucket name",
      "title": "Bucket Name",
      "type": "string"
    },
    "download_url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Presigned download URL",
      "title": "Download Url"
    }
  },
  "required": [
    "content_type",
    "size",
    "etag",
    "last_modified",
    "id",
    "object_key",
    "bucket_name"
  ],
  "title": "StorageObjectGet",
  "type": "object",
  "x-model-name": "StorageObjectGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StorageObjectGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StorageObjectGet', 'Expected an object');
    }

    // Required field: content_type
    if (!('content_type' in data)) {
      errors.push('Missing required field: content_type');
    } else {
      if (typeof data.content_type !== 'string') {
        errors.push('Field content_type must be a string');
      }
    }

    // Required field: size
    if (!('size' in data)) {
      errors.push('Missing required field: size');
    } else {
      if (typeof data.size !== 'number') {
        errors.push('Field size must be a number');
      }
    }

    // Required field: etag
    if (!('etag' in data)) {
      errors.push('Missing required field: etag');
    } else {
      if (typeof data.etag !== 'string') {
        errors.push('Field etag must be a string');
      }
    }

    // Required field: last_modified
    if (!('last_modified' in data)) {
      errors.push('Missing required field: last_modified');
    } else {
      if (typeof data.last_modified !== 'string') {
        errors.push('Field last_modified must be a string');
      }
    }

    // Optional field: metadata
    if ('metadata' in data && data.metadata !== undefined && data.metadata !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'number') {
        errors.push('Field id must be a number');
      }
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Optional field: download_url
    if ('download_url' in data && data.download_url !== undefined && data.download_url !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StorageObjectGet', errors.join('; '));
    }

    return data as StorageObjectGet;
  }

  safeValidate(data: any): { success: true; data: StorageObjectGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StorageObjectGet', String(error)) };
    }
  }
}

/**
 * DTO for listing storage objects
 */
export class StorageObjectListValidator extends BaseValidator<StorageObjectList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for listing storage objects",
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "description": "Storage object ID",
      "title": "Id",
      "type": "integer"
    },
    "object_key": {
      "description": "Object key/path in the bucket",
      "title": "Object Key",
      "type": "string"
    },
    "bucket_name": {
      "description": "Bucket name",
      "title": "Bucket Name",
      "type": "string"
    },
    "content_type": {
      "description": "MIME type of the object",
      "title": "Content Type",
      "type": "string"
    },
    "size": {
      "description": "Size of the object in bytes",
      "title": "Size",
      "type": "integer"
    },
    "last_modified": {
      "description": "Last modification timestamp",
      "format": "date-time",
      "title": "Last Modified",
      "type": "string"
    }
  },
  "required": [
    "id",
    "object_key",
    "bucket_name",
    "content_type",
    "size",
    "last_modified"
  ],
  "title": "StorageObjectList",
  "type": "object",
  "x-model-name": "StorageObjectList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StorageObjectList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StorageObjectList', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'number') {
        errors.push('Field id must be a number');
      }
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Required field: content_type
    if (!('content_type' in data)) {
      errors.push('Missing required field: content_type');
    } else {
      if (typeof data.content_type !== 'string') {
        errors.push('Field content_type must be a string');
      }
    }

    // Required field: size
    if (!('size' in data)) {
      errors.push('Missing required field: size');
    } else {
      if (typeof data.size !== 'number') {
        errors.push('Field size must be a number');
      }
    }

    // Required field: last_modified
    if (!('last_modified' in data)) {
      errors.push('Missing required field: last_modified');
    } else {
      if (typeof data.last_modified !== 'string') {
        errors.push('Field last_modified must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('StorageObjectList', errors.join('; '));
    }

    return data as StorageObjectList;
  }

  safeValidate(data: any): { success: true; data: StorageObjectList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StorageObjectList', String(error)) };
    }
  }
}

/**
 * DTO for updating storage object metadata
 */
export class StorageObjectUpdateValidator extends BaseValidator<StorageObjectUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for updating storage object metadata",
  "properties": {
    "metadata": {
      "anyOf": [
        {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Updated custom metadata",
      "title": "Metadata"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Updated MIME type",
      "title": "Content Type"
    }
  },
  "title": "StorageObjectUpdate",
  "type": "object",
  "x-model-name": "StorageObjectUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StorageObjectUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StorageObjectUpdate', 'Expected an object');
    }

    // Optional field: metadata
    if ('metadata' in data && data.metadata !== undefined && data.metadata !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StorageObjectUpdate', errors.join('; '));
    }

    return data as StorageObjectUpdate;
  }

  safeValidate(data: any): { success: true; data: StorageObjectUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StorageObjectUpdate', String(error)) };
    }
  }
}

/**
 * Query parameters for filtering storage objects
 */
export class StorageObjectQueryValidator extends BaseValidator<StorageObjectQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Query parameters for filtering storage objects",
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "bucket_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by bucket name",
      "title": "Bucket Name"
    },
    "prefix": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by object key prefix",
      "title": "Prefix"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by content type",
      "title": "Content Type"
    },
    "min_size": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Minimum object size in bytes",
      "title": "Min Size"
    },
    "max_size": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Maximum object size in bytes",
      "title": "Max Size"
    }
  },
  "title": "StorageObjectQuery",
  "type": "object",
  "x-model-name": "StorageObjectQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StorageObjectQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StorageObjectQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: bucket_name
    if ('bucket_name' in data && data.bucket_name !== undefined && data.bucket_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: prefix
    if ('prefix' in data && data.prefix !== undefined && data.prefix !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: min_size
    if ('min_size' in data && data.min_size !== undefined && data.min_size !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_size
    if ('max_size' in data && data.max_size !== undefined && data.max_size !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StorageObjectQuery', errors.join('; '));
    }

    return data as StorageObjectQuery;
  }

  safeValidate(data: any): { success: true; data: StorageObjectQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StorageObjectQuery', String(error)) };
    }
  }
}

/**
 * DTO for creating a storage bucket
 */
export class BucketCreateValidator extends BaseValidator<BucketCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for creating a storage bucket",
  "properties": {
    "bucket_name": {
      "description": "Name of the bucket to create",
      "title": "Bucket Name",
      "type": "string"
    },
    "region": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Region for the bucket",
      "title": "Region"
    }
  },
  "required": [
    "bucket_name"
  ],
  "title": "BucketCreate",
  "type": "object",
  "x-model-name": "BucketCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): BucketCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('BucketCreate', 'Expected an object');
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Optional field: region
    if ('region' in data && data.region !== undefined && data.region !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('BucketCreate', errors.join('; '));
    }

    return data as BucketCreate;
  }

  safeValidate(data: any): { success: true; data: BucketCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('BucketCreate', String(error)) };
    }
  }
}

/**
 * DTO for bucket information
 */
export class BucketInfoValidator extends BaseValidator<BucketInfo> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for bucket information",
  "properties": {
    "bucket_name": {
      "description": "Name of the bucket",
      "title": "Bucket Name",
      "type": "string"
    },
    "creation_date": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Bucket creation date",
      "title": "Creation Date"
    },
    "region": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Bucket region",
      "title": "Region"
    }
  },
  "required": [
    "bucket_name"
  ],
  "title": "BucketInfo",
  "type": "object",
  "x-model-name": "BucketInfo"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): BucketInfo {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('BucketInfo', 'Expected an object');
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Optional field: creation_date
    if ('creation_date' in data && data.creation_date !== undefined && data.creation_date !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: region
    if ('region' in data && data.region !== undefined && data.region !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('BucketInfo', errors.join('; '));
    }

    return data as BucketInfo;
  }

  safeValidate(data: any): { success: true; data: BucketInfo } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('BucketInfo', String(error)) };
    }
  }
}

/**
 * DTO for listing buckets
 */
export class BucketListValidator extends BaseValidator<BucketList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "BucketInfo": {
      "description": "DTO for bucket information",
      "properties": {
        "bucket_name": {
          "description": "Name of the bucket",
          "title": "Bucket Name",
          "type": "string"
        },
        "creation_date": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Bucket creation date",
          "title": "Creation Date"
        },
        "region": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Bucket region",
          "title": "Region"
        }
      },
      "required": [
        "bucket_name"
      ],
      "title": "BucketInfo",
      "type": "object"
    }
  },
  "description": "DTO for listing buckets",
  "properties": {
    "buckets": {
      "description": "List of buckets",
      "items": {
        "$ref": "#/$defs/BucketInfo"
      },
      "title": "Buckets",
      "type": "array"
    }
  },
  "required": [
    "buckets"
  ],
  "title": "BucketList",
  "type": "object",
  "x-model-name": "BucketList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): BucketList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('BucketList', 'Expected an object');
    }

    // Required field: buckets
    if (!('buckets' in data)) {
      errors.push('Missing required field: buckets');
    } else {
      if (!Array.isArray(data.buckets)) {
        errors.push('Field buckets must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('BucketList', errors.join('; '));
    }

    return data as BucketList;
  }

  safeValidate(data: any): { success: true; data: BucketList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('BucketList', String(error)) };
    }
  }
}

/**
 * DTO for generating presigned URLs
 */
export class PresignedUrlRequestValidator extends BaseValidator<PresignedUrlRequest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for generating presigned URLs",
  "properties": {
    "object_key": {
      "description": "Object key/path in the bucket",
      "title": "Object Key",
      "type": "string"
    },
    "bucket_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Bucket name",
      "title": "Bucket Name"
    },
    "expiry_seconds": {
      "anyOf": [
        {
          "maximum": 604800,
          "minimum": 1,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 3600,
      "description": "URL expiry time in seconds",
      "title": "Expiry Seconds"
    },
    "method": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": "GET",
      "description": "HTTP method for the presigned URL",
      "title": "Method"
    }
  },
  "required": [
    "object_key"
  ],
  "title": "PresignedUrlRequest",
  "type": "object",
  "x-model-name": "PresignedUrlRequest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): PresignedUrlRequest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('PresignedUrlRequest', 'Expected an object');
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Optional field: bucket_name
    if ('bucket_name' in data && data.bucket_name !== undefined && data.bucket_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: expiry_seconds
    if ('expiry_seconds' in data && data.expiry_seconds !== undefined && data.expiry_seconds !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: method
    if ('method' in data && data.method !== undefined && data.method !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('PresignedUrlRequest', errors.join('; '));
    }

    return data as PresignedUrlRequest;
  }

  safeValidate(data: any): { success: true; data: PresignedUrlRequest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('PresignedUrlRequest', String(error)) };
    }
  }
}

/**
 * DTO for presigned URL response
 */
export class PresignedUrlResponseValidator extends BaseValidator<PresignedUrlResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for presigned URL response",
  "properties": {
    "url": {
      "description": "The presigned URL",
      "title": "Url",
      "type": "string"
    },
    "expires_at": {
      "description": "URL expiration timestamp",
      "format": "date-time",
      "title": "Expires At",
      "type": "string"
    },
    "method": {
      "description": "HTTP method for the URL",
      "title": "Method",
      "type": "string"
    }
  },
  "required": [
    "url",
    "expires_at",
    "method"
  ],
  "title": "PresignedUrlResponse",
  "type": "object",
  "x-model-name": "PresignedUrlResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): PresignedUrlResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('PresignedUrlResponse', 'Expected an object');
    }

    // Required field: url
    if (!('url' in data)) {
      errors.push('Missing required field: url');
    } else {
      if (typeof data.url !== 'string') {
        errors.push('Field url must be a string');
      }
    }

    // Required field: expires_at
    if (!('expires_at' in data)) {
      errors.push('Missing required field: expires_at');
    } else {
      if (typeof data.expires_at !== 'string') {
        errors.push('Field expires_at must be a string');
      }
    }

    // Required field: method
    if (!('method' in data)) {
      errors.push('Missing required field: method');
    } else {
      if (typeof data.method !== 'string') {
        errors.push('Field method must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('PresignedUrlResponse', errors.join('; '));
    }

    return data as PresignedUrlResponse;
  }

  safeValidate(data: any): { success: true; data: PresignedUrlResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('PresignedUrlResponse', String(error)) };
    }
  }
}

/**
 * DTO for storage usage statistics
 */
export class StorageUsageStatsValidator extends BaseValidator<StorageUsageStats> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for storage usage statistics",
  "properties": {
    "bucket_name": {
      "description": "Bucket name",
      "title": "Bucket Name",
      "type": "string"
    },
    "object_count": {
      "description": "Number of objects in the bucket",
      "title": "Object Count",
      "type": "integer"
    },
    "total_size": {
      "description": "Total size of all objects in bytes",
      "title": "Total Size",
      "type": "integer"
    },
    "last_updated": {
      "description": "Last statistics update timestamp",
      "format": "date-time",
      "title": "Last Updated",
      "type": "string"
    }
  },
  "required": [
    "bucket_name",
    "object_count",
    "total_size",
    "last_updated"
  ],
  "title": "StorageUsageStats",
  "type": "object",
  "x-model-name": "StorageUsageStats"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StorageUsageStats {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StorageUsageStats', 'Expected an object');
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Required field: object_count
    if (!('object_count' in data)) {
      errors.push('Missing required field: object_count');
    } else {
      if (typeof data.object_count !== 'number') {
        errors.push('Field object_count must be a number');
      }
    }

    // Required field: total_size
    if (!('total_size' in data)) {
      errors.push('Missing required field: total_size');
    } else {
      if (typeof data.total_size !== 'number') {
        errors.push('Field total_size must be a number');
      }
    }

    // Required field: last_updated
    if (!('last_updated' in data)) {
      errors.push('Missing required field: last_updated');
    } else {
      if (typeof data.last_updated !== 'string') {
        errors.push('Field last_updated must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('StorageUsageStats', errors.join('; '));
    }

    return data as StorageUsageStats;
  }

  safeValidate(data: any): { success: true; data: StorageUsageStats } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StorageUsageStats', String(error)) };
    }
  }
}

/**
 * Repository information for a submission group
 */
export class SubmissionGroupRepositoryValidator extends BaseValidator<SubmissionGroupRepository> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Repository information for a submission group",
  "properties": {
    "provider": {
      "default": "gitlab",
      "title": "Provider",
      "type": "string"
    },
    "url": {
      "title": "Url",
      "type": "string"
    },
    "full_path": {
      "title": "Full Path",
      "type": "string"
    },
    "clone_url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Clone Url"
    },
    "web_url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Web Url"
    }
  },
  "required": [
    "url",
    "full_path"
  ],
  "title": "SubmissionGroupRepository",
  "type": "object",
  "x-model-name": "SubmissionGroupRepository"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupRepository {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupRepository', 'Expected an object');
    }

    // Optional field: provider
    if ('provider' in data && data.provider !== undefined && data.provider !== null) {
      if (typeof data.provider !== 'string') {
        errors.push('Field provider must be a string');
      }
    }

    // Required field: url
    if (!('url' in data)) {
      errors.push('Missing required field: url');
    } else {
      if (typeof data.url !== 'string') {
        errors.push('Field url must be a string');
      }
    }

    // Required field: full_path
    if (!('full_path' in data)) {
      errors.push('Missing required field: full_path');
    } else {
      if (typeof data.full_path !== 'string') {
        errors.push('Field full_path must be a string');
      }
    }

    // Optional field: clone_url
    if ('clone_url' in data && data.clone_url !== undefined && data.clone_url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: web_url
    if ('web_url' in data && data.web_url !== undefined && data.web_url !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupRepository', errors.join('; '));
    }

    return data as SubmissionGroupRepository;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupRepository } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupRepository', String(error)) };
    }
  }
}

/**
 * Basic member information
 */
export class SubmissionGroupMemberBasicValidator extends BaseValidator<SubmissionGroupMemberBasic> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Basic member information",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "user_id": {
      "title": "User Id",
      "type": "string"
    },
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "username": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Username"
    },
    "full_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Full Name"
    }
  },
  "required": [
    "id",
    "user_id",
    "course_member_id"
  ],
  "title": "SubmissionGroupMemberBasic",
  "type": "object",
  "x-model-name": "SubmissionGroupMemberBasic"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupMemberBasic {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupMemberBasic', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Optional field: username
    if ('username' in data && data.username !== undefined && data.username !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: full_name
    if ('full_name' in data && data.full_name !== undefined && data.full_name !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupMemberBasic', errors.join('; '));
    }

    return data as SubmissionGroupMemberBasic;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupMemberBasic } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupMemberBasic', String(error)) };
    }
  }
}

/**
 * Submission group data for course contents (list view).
 */
export class SubmissionGroupStudentListValidator extends BaseValidator<SubmissionGroupStudentList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "SubmissionGroupMemberBasic": {
      "description": "Basic member information",
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "course_member_id": {
          "title": "Course Member Id",
          "type": "string"
        },
        "username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Username"
        },
        "full_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Name"
        }
      },
      "required": [
        "id",
        "user_id",
        "course_member_id"
      ],
      "title": "SubmissionGroupMemberBasic",
      "type": "object"
    },
    "SubmissionGroupRepository": {
      "description": "Repository information for a submission group",
      "properties": {
        "provider": {
          "default": "gitlab",
          "title": "Provider",
          "type": "string"
        },
        "url": {
          "title": "Url",
          "type": "string"
        },
        "full_path": {
          "title": "Full Path",
          "type": "string"
        },
        "clone_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Clone Url"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        }
      },
      "required": [
        "url",
        "full_path"
      ],
      "title": "SubmissionGroupRepository",
      "type": "object"
    }
  },
  "description": "Submission group data for course contents (list view).",
  "properties": {
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "course_content_title": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Title"
    },
    "course_content_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Path"
    },
    "example_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Identifier"
    },
    "max_group_size": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Group Size"
    },
    "current_group_size": {
      "default": 1,
      "title": "Current Group Size",
      "type": "integer"
    },
    "members": {
      "default": [],
      "items": {
        "$ref": "#/$defs/SubmissionGroupMemberBasic"
      },
      "title": "Members",
      "type": "array"
    },
    "repository": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupRepository"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    },
    "grading": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grading"
    },
    "count": {
      "default": 0,
      "title": "Count",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "unread_message_count": {
      "default": 0,
      "title": "Unread Message Count",
      "type": "integer"
    }
  },
  "title": "SubmissionGroupStudentList",
  "type": "object",
  "x-model-name": "SubmissionGroupStudentList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupStudentList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupStudentList', 'Expected an object');
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_title
    if ('course_content_title' in data && data.course_content_title !== undefined && data.course_content_title !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_path
    if ('course_content_path' in data && data.course_content_path !== undefined && data.course_content_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_identifier
    if ('example_identifier' in data && data.example_identifier !== undefined && data.example_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_group_size
    if ('max_group_size' in data && data.max_group_size !== undefined && data.max_group_size !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: current_group_size
    if ('current_group_size' in data && data.current_group_size !== undefined && data.current_group_size !== null) {
      if (typeof data.current_group_size !== 'number') {
        errors.push('Field current_group_size must be a number');
      }
    }

    // Optional field: members
    if ('members' in data && data.members !== undefined && data.members !== null) {
      if (!Array.isArray(data.members)) {
        errors.push('Field members must be an array');
      }
    }

    // Optional field: repository
    if ('repository' in data && data.repository !== undefined && data.repository !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grading
    if ('grading' in data && data.grading !== undefined && data.grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: count
    if ('count' in data && data.count !== undefined && data.count !== null) {
      if (typeof data.count !== 'number') {
        errors.push('Field count must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: unread_message_count
    if ('unread_message_count' in data && data.unread_message_count !== undefined && data.unread_message_count !== null) {
      if (typeof data.unread_message_count !== 'number') {
        errors.push('Field unread_message_count must be a number');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupStudentList', errors.join('; '));
    }

    return data as SubmissionGroupStudentList;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupStudentList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupStudentList', String(error)) };
    }
  }
}

/**
 * Detailed submission group view including grading history.
 */
export class SubmissionGroupStudentGetValidator extends BaseValidator<SubmissionGroupStudentGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradedByCourseMember": {
      "properties": {
        "course_role_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Course Role Id"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "user": {
          "anyOf": [
            {
              "$ref": "#/$defs/GradingAuthor"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "user_id"
      ],
      "title": "GradedByCourseMember",
      "type": "object"
    },
    "GradingAuthor": {
      "properties": {
        "given_name": {
          "anyOf": [
            {
              "maxLength": 255,
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Author's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "maxLength": 255,
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Author's family name",
          "title": "Family Name"
        }
      },
      "title": "GradingAuthor",
      "type": "object"
    },
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    },
    "SubmissionGroupGradingList": {
      "description": "List view of grading.",
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "submission_group_id": {
          "title": "Submission Group Id",
          "type": "string"
        },
        "graded_by_course_member_id": {
          "title": "Graded By Course Member Id",
          "type": "string"
        },
        "result_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Result Id"
        },
        "grading": {
          "title": "Grading",
          "type": "number"
        },
        "status": {
          "$ref": "#/$defs/GradingStatus"
        },
        "feedback": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Feedback"
        },
        "created_at": {
          "format": "date-time",
          "title": "Created At",
          "type": "string"
        },
        "graded_by_course_member": {
          "anyOf": [
            {
              "$ref": "#/$defs/GradedByCourseMember"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "id",
        "submission_group_id",
        "graded_by_course_member_id",
        "grading",
        "status",
        "created_at"
      ],
      "title": "SubmissionGroupGradingList",
      "type": "object"
    },
    "SubmissionGroupMemberBasic": {
      "description": "Basic member information",
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "course_member_id": {
          "title": "Course Member Id",
          "type": "string"
        },
        "username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Username"
        },
        "full_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Name"
        }
      },
      "required": [
        "id",
        "user_id",
        "course_member_id"
      ],
      "title": "SubmissionGroupMemberBasic",
      "type": "object"
    },
    "SubmissionGroupRepository": {
      "description": "Repository information for a submission group",
      "properties": {
        "provider": {
          "default": "gitlab",
          "title": "Provider",
          "type": "string"
        },
        "url": {
          "title": "Url",
          "type": "string"
        },
        "full_path": {
          "title": "Full Path",
          "type": "string"
        },
        "clone_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Clone Url"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        }
      },
      "required": [
        "url",
        "full_path"
      ],
      "title": "SubmissionGroupRepository",
      "type": "object"
    }
  },
  "description": "Detailed submission group view including grading history.",
  "properties": {
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "course_content_title": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Title"
    },
    "course_content_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Path"
    },
    "example_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Identifier"
    },
    "max_group_size": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Group Size"
    },
    "current_group_size": {
      "default": 1,
      "title": "Current Group Size",
      "type": "integer"
    },
    "members": {
      "default": [],
      "items": {
        "$ref": "#/$defs/SubmissionGroupMemberBasic"
      },
      "title": "Members",
      "type": "array"
    },
    "repository": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupRepository"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    },
    "grading": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grading"
    },
    "count": {
      "default": 0,
      "title": "Count",
      "type": "integer"
    },
    "max_submissions": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Submissions"
    },
    "unread_message_count": {
      "default": 0,
      "title": "Unread Message Count",
      "type": "integer"
    },
    "gradings": {
      "items": {
        "$ref": "#/$defs/SubmissionGroupGradingList"
      },
      "title": "Gradings",
      "type": "array"
    }
  },
  "title": "SubmissionGroupStudentGet",
  "type": "object",
  "x-model-name": "SubmissionGroupStudentGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupStudentGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupStudentGet', 'Expected an object');
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_title
    if ('course_content_title' in data && data.course_content_title !== undefined && data.course_content_title !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_path
    if ('course_content_path' in data && data.course_content_path !== undefined && data.course_content_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_identifier
    if ('example_identifier' in data && data.example_identifier !== undefined && data.example_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_group_size
    if ('max_group_size' in data && data.max_group_size !== undefined && data.max_group_size !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: current_group_size
    if ('current_group_size' in data && data.current_group_size !== undefined && data.current_group_size !== null) {
      if (typeof data.current_group_size !== 'number') {
        errors.push('Field current_group_size must be a number');
      }
    }

    // Optional field: members
    if ('members' in data && data.members !== undefined && data.members !== null) {
      if (!Array.isArray(data.members)) {
        errors.push('Field members must be an array');
      }
    }

    // Optional field: repository
    if ('repository' in data && data.repository !== undefined && data.repository !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grading
    if ('grading' in data && data.grading !== undefined && data.grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: count
    if ('count' in data && data.count !== undefined && data.count !== null) {
      if (typeof data.count !== 'number') {
        errors.push('Field count must be a number');
      }
    }

    // Optional field: max_submissions
    if ('max_submissions' in data && data.max_submissions !== undefined && data.max_submissions !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: unread_message_count
    if ('unread_message_count' in data && data.unread_message_count !== undefined && data.unread_message_count !== null) {
      if (typeof data.unread_message_count !== 'number') {
        errors.push('Field unread_message_count must be a number');
      }
    }

    // Optional field: gradings
    if ('gradings' in data && data.gradings !== undefined && data.gradings !== null) {
      if (!Array.isArray(data.gradings)) {
        errors.push('Field gradings must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupStudentGet', errors.join('; '));
    }

    return data as SubmissionGroupStudentGet;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupStudentGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupStudentGet', String(error)) };
    }
  }
}

/**
 * Validator for ResultStudentList
 */
export class ResultStudentListValidator extends BaseValidator<ResultStudentList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "properties": {
    "execution_backend_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Execution Backend Id"
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Identifier"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/TaskStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "result": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result"
    },
    "result_json": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Json"
    },
    "submit": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submit"
    }
  },
  "title": "ResultStudentList",
  "type": "object",
  "x-model-name": "ResultStudentList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultStudentList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultStudentList', 'Expected an object');
    }

    // Optional field: execution_backend_id
    if ('execution_backend_id' in data && data.execution_backend_id !== undefined && data.execution_backend_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version_identifier
    if ('version_identifier' in data && data.version_identifier !== undefined && data.version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result
    if ('result' in data && data.result !== undefined && data.result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_json
    if ('result_json' in data && data.result_json !== undefined && data.result_json !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submit
    if ('submit' in data && data.submit !== undefined && data.submit !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultStudentList', errors.join('; '));
    }

    return data as ResultStudentList;
  }

  safeValidate(data: any): { success: true; data: ResultStudentList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultStudentList', String(error)) };
    }
  }
}

/**
 * Validator for TestCreate
 */
export class TestCreateValidator extends BaseValidator<TestCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Artifact Id"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Identifier"
    },
    "course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Member Id"
    },
    "course_content_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Id"
    },
    "course_content_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Path"
    },
    "directory": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Directory"
    },
    "project": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Project"
    },
    "provider_url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Provider Url"
    },
    "submit": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submit"
    }
  },
  "title": "TestCreate",
  "type": "object",
  "x-model-name": "TestCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TestCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TestCreate', 'Expected an object');
    }

    // Optional field: artifact_id
    if ('artifact_id' in data && data.artifact_id !== undefined && data.artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version_identifier
    if ('version_identifier' in data && data.version_identifier !== undefined && data.version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_member_id
    if ('course_member_id' in data && data.course_member_id !== undefined && data.course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_id
    if ('course_content_id' in data && data.course_content_id !== undefined && data.course_content_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_path
    if ('course_content_path' in data && data.course_content_path !== undefined && data.course_content_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: directory
    if ('directory' in data && data.directory !== undefined && data.directory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: project
    if ('project' in data && data.project !== undefined && data.project !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: provider_url
    if ('provider_url' in data && data.provider_url !== undefined && data.provider_url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submit
    if ('submit' in data && data.submit !== undefined && data.submit !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TestCreate', errors.join('; '));
    }

    return data as TestCreate;
  }

  safeValidate(data: any): { success: true; data: TestCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TestCreate', String(error)) };
    }
  }
}

/**
 * Payload describing a manual submission request.
 */
export class SubmissionCreateValidator extends BaseValidator<SubmissionCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Payload describing a manual submission request.",
  "properties": {
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Identifier"
    },
    "submit": {
      "default": false,
      "title": "Submit",
      "type": "boolean"
    }
  },
  "required": [
    "submission_group_id"
  ],
  "title": "SubmissionCreate",
  "type": "object",
  "x-model-name": "SubmissionCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionCreate', 'Expected an object');
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Optional field: version_identifier
    if ('version_identifier' in data && data.version_identifier !== undefined && data.version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submit
    if ('submit' in data && data.submit !== undefined && data.submit !== null) {
      if (typeof data.submit !== 'boolean') {
        errors.push('Field submit must be a boolean');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionCreate', errors.join('; '));
    }

    return data as SubmissionCreate;
  }

  safeValidate(data: any): { success: true; data: SubmissionCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionCreate', String(error)) };
    }
  }
}

/**
 * Metadata about a file extracted from a submission archive.
 */
export class SubmissionUploadedFileValidator extends BaseValidator<SubmissionUploadedFile> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Metadata about a file extracted from a submission archive.",
  "properties": {
    "object_key": {
      "title": "Object Key",
      "type": "string"
    },
    "size": {
      "title": "Size",
      "type": "integer"
    },
    "content_type": {
      "title": "Content Type",
      "type": "string"
    },
    "relative_path": {
      "title": "Relative Path",
      "type": "string"
    }
  },
  "required": [
    "object_key",
    "size",
    "content_type",
    "relative_path"
  ],
  "title": "SubmissionUploadedFile",
  "type": "object",
  "x-model-name": "SubmissionUploadedFile"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionUploadedFile {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionUploadedFile', 'Expected an object');
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Required field: size
    if (!('size' in data)) {
      errors.push('Missing required field: size');
    } else {
      if (typeof data.size !== 'number') {
        errors.push('Field size must be a number');
      }
    }

    // Required field: content_type
    if (!('content_type' in data)) {
      errors.push('Missing required field: content_type');
    } else {
      if (typeof data.content_type !== 'string') {
        errors.push('Field content_type must be a string');
      }
    }

    // Required field: relative_path
    if (!('relative_path' in data)) {
      errors.push('Missing required field: relative_path');
    } else {
      if (typeof data.relative_path !== 'string') {
        errors.push('Field relative_path must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionUploadedFile', errors.join('; '));
    }

    return data as SubmissionUploadedFile;
  }

  safeValidate(data: any): { success: true; data: SubmissionUploadedFile } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionUploadedFile', String(error)) };
    }
  }
}

/**
 * Response returned after processing a manual submission.
 */
export class SubmissionUploadResponseModelValidator extends BaseValidator<SubmissionUploadResponseModel> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Response returned after processing a manual submission.",
  "properties": {
    "artifacts": {
      "items": {
        "type": "string"
      },
      "title": "Artifacts",
      "type": "array"
    },
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "uploaded_by_course_member_id": {
      "title": "Uploaded By Course Member Id",
      "type": "string"
    },
    "total_size": {
      "title": "Total Size",
      "type": "integer"
    },
    "files_count": {
      "title": "Files Count",
      "type": "integer"
    },
    "uploaded_at": {
      "format": "date-time",
      "title": "Uploaded At",
      "type": "string"
    },
    "version_identifier": {
      "title": "Version Identifier",
      "type": "string"
    }
  },
  "required": [
    "artifacts",
    "submission_group_id",
    "uploaded_by_course_member_id",
    "total_size",
    "files_count",
    "uploaded_at",
    "version_identifier"
  ],
  "title": "SubmissionUploadResponseModel",
  "type": "object",
  "x-model-name": "SubmissionUploadResponseModel"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionUploadResponseModel {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionUploadResponseModel', 'Expected an object');
    }

    // Required field: artifacts
    if (!('artifacts' in data)) {
      errors.push('Missing required field: artifacts');
    } else {
      if (!Array.isArray(data.artifacts)) {
        errors.push('Field artifacts must be an array');
      }
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Required field: uploaded_by_course_member_id
    if (!('uploaded_by_course_member_id' in data)) {
      errors.push('Missing required field: uploaded_by_course_member_id');
    } else {
      if (typeof data.uploaded_by_course_member_id !== 'string') {
        errors.push('Field uploaded_by_course_member_id must be a string');
      }
    }

    // Required field: total_size
    if (!('total_size' in data)) {
      errors.push('Missing required field: total_size');
    } else {
      if (typeof data.total_size !== 'number') {
        errors.push('Field total_size must be a number');
      }
    }

    // Required field: files_count
    if (!('files_count' in data)) {
      errors.push('Missing required field: files_count');
    } else {
      if (typeof data.files_count !== 'number') {
        errors.push('Field files_count must be a number');
      }
    }

    // Required field: uploaded_at
    if (!('uploaded_at' in data)) {
      errors.push('Missing required field: uploaded_at');
    } else {
      if (typeof data.uploaded_at !== 'string') {
        errors.push('Field uploaded_at must be a string');
      }
    }

    // Required field: version_identifier
    if (!('version_identifier' in data)) {
      errors.push('Missing required field: version_identifier');
    } else {
      if (typeof data.version_identifier !== 'string') {
        errors.push('Field version_identifier must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionUploadResponseModel', errors.join('; '));
    }

    return data as SubmissionUploadResponseModel;
  }

  safeValidate(data: any): { success: true; data: SubmissionUploadResponseModel } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionUploadResponseModel', String(error)) };
    }
  }
}

/**
 * List item representation for manual submissions stored as results.
 */
export class SubmissionListItemValidator extends BaseValidator<SubmissionListItem> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "description": "List item representation for manual submissions stored as results.",
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "submit": {
      "title": "Submit",
      "type": "boolean"
    },
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "execution_backend_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Execution Backend Id"
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "version_identifier": {
      "title": "Version Identifier",
      "type": "string"
    },
    "reference_version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Reference Version Identifier"
    },
    "status": {
      "$ref": "#/$defs/TaskStatus"
    },
    "result": {
      "title": "Result",
      "type": "number"
    },
    "result_json": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Json"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    }
  },
  "required": [
    "id",
    "submit",
    "course_member_id",
    "course_content_id",
    "version_identifier",
    "status",
    "result"
  ],
  "title": "SubmissionListItem",
  "type": "object",
  "x-model-name": "SubmissionListItem"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionListItem {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionListItem', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: submit
    if (!('submit' in data)) {
      errors.push('Missing required field: submit');
    } else {
      if (typeof data.submit !== 'boolean') {
        errors.push('Field submit must be a boolean');
      }
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: execution_backend_id
    if ('execution_backend_id' in data && data.execution_backend_id !== undefined && data.execution_backend_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: version_identifier
    if (!('version_identifier' in data)) {
      errors.push('Missing required field: version_identifier');
    } else {
      if (typeof data.version_identifier !== 'string') {
        errors.push('Field version_identifier must be a string');
      }
    }

    // Optional field: reference_version_identifier
    if ('reference_version_identifier' in data && data.reference_version_identifier !== undefined && data.reference_version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Required field: result
    if (!('result' in data)) {
      errors.push('Missing required field: result');
    } else {
      if (typeof data.result !== 'number') {
        errors.push('Field result must be a number');
      }
    }

    // Optional field: result_json
    if ('result_json' in data && data.result_json !== undefined && data.result_json !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionListItem', errors.join('; '));
    }

    return data as SubmissionListItem;
  }

  safeValidate(data: any): { success: true; data: SubmissionListItem } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionListItem', String(error)) };
    }
  }
}

/**
 * Query parameters for listing manual submissions.
 */
export class SubmissionQueryValidator extends BaseValidator<SubmissionQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "description": "Query parameters for listing manual submissions.",
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "submit": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submit"
    },
    "course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Member Id"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "course_content_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Id"
    },
    "execution_backend_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Execution Backend Id"
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Identifier"
    },
    "reference_version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Reference Version Identifier"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/TaskStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "title": "SubmissionQuery",
  "type": "object",
  "x-model-name": "SubmissionQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submit
    if ('submit' in data && data.submit !== undefined && data.submit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_member_id
    if ('course_member_id' in data && data.course_member_id !== undefined && data.course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_id
    if ('course_content_id' in data && data.course_content_id !== undefined && data.course_content_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: execution_backend_id
    if ('execution_backend_id' in data && data.execution_backend_id !== undefined && data.execution_backend_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version_identifier
    if ('version_identifier' in data && data.version_identifier !== undefined && data.version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: reference_version_identifier
    if ('reference_version_identifier' in data && data.reference_version_identifier !== undefined && data.reference_version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionQuery', errors.join('; '));
    }

    return data as SubmissionQuery;
  }

  safeValidate(data: any): { success: true; data: SubmissionQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionQuery', String(error)) };
    }
  }
}

/**
 * Validator for SessionCreate
 */
export class SessionCreateValidator extends BaseValidator<SessionCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "user_id": {
      "description": "Associated user ID",
      "title": "User Id",
      "type": "string"
    },
    "session_id": {
      "description": "Hashed session token",
      "maxLength": 1024,
      "minLength": 1,
      "title": "Session Id",
      "type": "string"
    },
    "refresh_token_hash": {
      "anyOf": [
        {
          "format": "binary",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Hashed refresh token (binary)",
      "title": "Refresh Token Hash"
    },
    "created_ip": {
      "description": "IP address at session creation",
      "title": "Created Ip",
      "type": "string"
    },
    "last_ip": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Last seen IP address",
      "title": "Last Ip"
    },
    "user_agent": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User agent string",
      "title": "User Agent"
    },
    "device_label": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Human-readable device description",
      "title": "Device Label"
    },
    "expires_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Session expiration time",
      "title": "Expires At"
    },
    "refresh_expires_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Refresh token expiration",
      "title": "Refresh Expires At"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "description": "Additional session properties",
      "title": "Properties"
    }
  },
  "required": [
    "user_id",
    "session_id",
    "created_ip"
  ],
  "title": "SessionCreate",
  "type": "object",
  "x-model-name": "SessionCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SessionCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SessionCreate', 'Expected an object');
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Required field: session_id
    if (!('session_id' in data)) {
      errors.push('Missing required field: session_id');
    } else {
      if (typeof data.session_id !== 'string') {
        errors.push('Field session_id must be a string');
      }
    }

    // Optional field: refresh_token_hash
    if ('refresh_token_hash' in data && data.refresh_token_hash !== undefined && data.refresh_token_hash !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: created_ip
    if (!('created_ip' in data)) {
      errors.push('Missing required field: created_ip');
    } else {
      if (typeof data.created_ip !== 'string') {
        errors.push('Field created_ip must be a string');
      }
    }

    // Optional field: last_ip
    if ('last_ip' in data && data.last_ip !== undefined && data.last_ip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: user_agent
    if ('user_agent' in data && data.user_agent !== undefined && data.user_agent !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: device_label
    if ('device_label' in data && data.device_label !== undefined && data.device_label !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: expires_at
    if ('expires_at' in data && data.expires_at !== undefined && data.expires_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: refresh_expires_at
    if ('refresh_expires_at' in data && data.refresh_expires_at !== undefined && data.refresh_expires_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SessionCreate', errors.join('; '));
    }

    return data as SessionCreate;
  }

  safeValidate(data: any): { success: true; data: SessionCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SessionCreate', String(error)) };
    }
  }
}

/**
 * Validator for SessionGet
 */
export class SessionGetValidator extends BaseValidator<SessionGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "created_at": {
      "description": "Session creation time",
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "description": "Session unique identifier",
      "title": "Id",
      "type": "string"
    },
    "sid": {
      "description": "Unique session ID per device",
      "title": "Sid",
      "type": "string"
    },
    "user_id": {
      "description": "Associated user ID",
      "title": "User Id",
      "type": "string"
    },
    "session_id": {
      "description": "Hashed session token",
      "title": "Session Id",
      "type": "string"
    },
    "last_seen_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Last activity time",
      "title": "Last Seen At"
    },
    "expires_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Expiration time",
      "title": "Expires At"
    },
    "revoked_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Revocation timestamp",
      "title": "Revoked At"
    },
    "revocation_reason": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Reason for revocation",
      "title": "Revocation Reason"
    },
    "ended_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "End timestamp (logout)",
      "title": "Ended At"
    },
    "refresh_counter": {
      "default": 0,
      "description": "Number of token refreshes",
      "title": "Refresh Counter",
      "type": "integer"
    },
    "created_ip": {
      "description": "IP at creation",
      "title": "Created Ip",
      "type": "string"
    },
    "last_ip": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Last seen IP",
      "title": "Last Ip"
    },
    "device_label": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Device description",
      "title": "Device Label"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional properties",
      "title": "Properties"
    },
    "logout_time": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Deprecated: use ended_at",
      "title": "Logout Time"
    },
    "ip_address": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Deprecated: use created_ip",
      "title": "Ip Address"
    }
  },
  "required": [
    "created_at",
    "id",
    "sid",
    "user_id",
    "session_id",
    "created_ip"
  ],
  "title": "SessionGet",
  "type": "object",
  "x-model-name": "SessionGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SessionGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SessionGet', 'Expected an object');
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: sid
    if (!('sid' in data)) {
      errors.push('Missing required field: sid');
    } else {
      if (typeof data.sid !== 'string') {
        errors.push('Field sid must be a string');
      }
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Required field: session_id
    if (!('session_id' in data)) {
      errors.push('Missing required field: session_id');
    } else {
      if (typeof data.session_id !== 'string') {
        errors.push('Field session_id must be a string');
      }
    }

    // Optional field: last_seen_at
    if ('last_seen_at' in data && data.last_seen_at !== undefined && data.last_seen_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: expires_at
    if ('expires_at' in data && data.expires_at !== undefined && data.expires_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: revoked_at
    if ('revoked_at' in data && data.revoked_at !== undefined && data.revoked_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: revocation_reason
    if ('revocation_reason' in data && data.revocation_reason !== undefined && data.revocation_reason !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: ended_at
    if ('ended_at' in data && data.ended_at !== undefined && data.ended_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: refresh_counter
    if ('refresh_counter' in data && data.refresh_counter !== undefined && data.refresh_counter !== null) {
      if (typeof data.refresh_counter !== 'number') {
        errors.push('Field refresh_counter must be a number');
      }
    }

    // Required field: created_ip
    if (!('created_ip' in data)) {
      errors.push('Missing required field: created_ip');
    } else {
      if (typeof data.created_ip !== 'string') {
        errors.push('Field created_ip must be a string');
      }
    }

    // Optional field: last_ip
    if ('last_ip' in data && data.last_ip !== undefined && data.last_ip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: device_label
    if ('device_label' in data && data.device_label !== undefined && data.device_label !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: logout_time
    if ('logout_time' in data && data.logout_time !== undefined && data.logout_time !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: ip_address
    if ('ip_address' in data && data.ip_address !== undefined && data.ip_address !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SessionGet', errors.join('; '));
    }

    return data as SessionGet;
  }

  safeValidate(data: any): { success: true; data: SessionGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SessionGet', String(error)) };
    }
  }
}

/**
 * Validator for SessionList
 */
export class SessionListValidator extends BaseValidator<SessionList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "created_at": {
      "description": "Session creation time",
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "description": "Session unique identifier",
      "title": "Id",
      "type": "string"
    },
    "sid": {
      "description": "Unique session ID per device",
      "title": "Sid",
      "type": "string"
    },
    "user_id": {
      "description": "Associated user ID",
      "title": "User Id",
      "type": "string"
    },
    "session_id": {
      "description": "Hashed session token",
      "title": "Session Id",
      "type": "string"
    },
    "last_seen_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Last activity time",
      "title": "Last Seen At"
    },
    "expires_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Expiration time",
      "title": "Expires At"
    },
    "revoked_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Revocation timestamp",
      "title": "Revoked At"
    },
    "ended_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "End timestamp",
      "title": "Ended At"
    },
    "created_ip": {
      "description": "IP at creation",
      "title": "Created Ip",
      "type": "string"
    },
    "last_ip": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Last seen IP",
      "title": "Last Ip"
    },
    "device_label": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Device description",
      "title": "Device Label"
    },
    "refresh_counter": {
      "default": 0,
      "description": "Refresh count",
      "title": "Refresh Counter",
      "type": "integer"
    },
    "logout_time": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Deprecated",
      "title": "Logout Time"
    },
    "ip_address": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Deprecated",
      "title": "Ip Address"
    }
  },
  "required": [
    "created_at",
    "id",
    "sid",
    "user_id",
    "session_id",
    "created_ip"
  ],
  "title": "SessionList",
  "type": "object",
  "x-model-name": "SessionList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SessionList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SessionList', 'Expected an object');
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: sid
    if (!('sid' in data)) {
      errors.push('Missing required field: sid');
    } else {
      if (typeof data.sid !== 'string') {
        errors.push('Field sid must be a string');
      }
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Required field: session_id
    if (!('session_id' in data)) {
      errors.push('Missing required field: session_id');
    } else {
      if (typeof data.session_id !== 'string') {
        errors.push('Field session_id must be a string');
      }
    }

    // Optional field: last_seen_at
    if ('last_seen_at' in data && data.last_seen_at !== undefined && data.last_seen_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: expires_at
    if ('expires_at' in data && data.expires_at !== undefined && data.expires_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: revoked_at
    if ('revoked_at' in data && data.revoked_at !== undefined && data.revoked_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: ended_at
    if ('ended_at' in data && data.ended_at !== undefined && data.ended_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: created_ip
    if (!('created_ip' in data)) {
      errors.push('Missing required field: created_ip');
    } else {
      if (typeof data.created_ip !== 'string') {
        errors.push('Field created_ip must be a string');
      }
    }

    // Optional field: last_ip
    if ('last_ip' in data && data.last_ip !== undefined && data.last_ip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: device_label
    if ('device_label' in data && data.device_label !== undefined && data.device_label !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: refresh_counter
    if ('refresh_counter' in data && data.refresh_counter !== undefined && data.refresh_counter !== null) {
      if (typeof data.refresh_counter !== 'number') {
        errors.push('Field refresh_counter must be a number');
      }
    }

    // Optional field: logout_time
    if ('logout_time' in data && data.logout_time !== undefined && data.logout_time !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: ip_address
    if ('ip_address' in data && data.ip_address !== undefined && data.ip_address !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SessionList', errors.join('; '));
    }

    return data as SessionList;
  }

  safeValidate(data: any): { success: true; data: SessionList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SessionList', String(error)) };
    }
  }
}

/**
 * Validator for SessionUpdate
 */
export class SessionUpdateValidator extends BaseValidator<SessionUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "logout_time": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Logout timestamp",
      "title": "Logout Time"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional properties",
      "title": "Properties"
    }
  },
  "title": "SessionUpdate",
  "type": "object",
  "x-model-name": "SessionUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SessionUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SessionUpdate', 'Expected an object');
    }

    // Optional field: logout_time
    if ('logout_time' in data && data.logout_time !== undefined && data.logout_time !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SessionUpdate', errors.join('; '));
    }

    return data as SessionUpdate;
  }

  safeValidate(data: any): { success: true; data: SessionUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SessionUpdate', String(error)) };
    }
  }
}

/**
 * Validator for SessionQuery
 */
export class SessionQueryValidator extends BaseValidator<SessionQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by session ID",
      "title": "Id"
    },
    "user_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by user ID",
      "title": "User Id"
    },
    "session_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by session identifier",
      "title": "Session Id"
    },
    "active_only": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter for active sessions only",
      "title": "Active Only"
    },
    "ip_address": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by IP address",
      "title": "Ip Address"
    }
  },
  "title": "SessionQuery",
  "type": "object",
  "x-model-name": "SessionQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SessionQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SessionQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: user_id
    if ('user_id' in data && data.user_id !== undefined && data.user_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: session_id
    if ('session_id' in data && data.session_id !== undefined && data.session_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: active_only
    if ('active_only' in data && data.active_only !== undefined && data.active_only !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: ip_address
    if ('ip_address' in data && data.ip_address !== undefined && data.ip_address !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SessionQuery', errors.join('; '));
    }

    return data as SessionQuery;
  }

  safeValidate(data: any): { success: true; data: SessionQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SessionQuery', String(error)) };
    }
  }
}

/**
 * Validator for GroupClaimCreate
 */
export class GroupClaimCreateValidator extends BaseValidator<GroupClaimCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "group_id": {
      "description": "Group ID this claim belongs to",
      "title": "Group Id",
      "type": "string"
    },
    "claim_type": {
      "description": "Type of claim (e.g., 'permission', 'attribute')",
      "maxLength": 255,
      "minLength": 1,
      "title": "Claim Type",
      "type": "string"
    },
    "claim_value": {
      "description": "Value of the claim",
      "maxLength": 255,
      "minLength": 1,
      "title": "Claim Value",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional claim properties",
      "title": "Properties"
    }
  },
  "required": [
    "group_id",
    "claim_type",
    "claim_value"
  ],
  "title": "GroupClaimCreate",
  "type": "object",
  "x-model-name": "GroupClaimCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupClaimCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupClaimCreate', 'Expected an object');
    }

    // Required field: group_id
    if (!('group_id' in data)) {
      errors.push('Missing required field: group_id');
    } else {
      if (typeof data.group_id !== 'string') {
        errors.push('Field group_id must be a string');
      }
    }

    // Required field: claim_type
    if (!('claim_type' in data)) {
      errors.push('Missing required field: claim_type');
    } else {
      if (typeof data.claim_type !== 'string') {
        errors.push('Field claim_type must be a string');
      }
    }

    // Required field: claim_value
    if (!('claim_value' in data)) {
      errors.push('Missing required field: claim_value');
    } else {
      if (typeof data.claim_value !== 'string') {
        errors.push('Field claim_value must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupClaimCreate', errors.join('; '));
    }

    return data as GroupClaimCreate;
  }

  safeValidate(data: any): { success: true; data: GroupClaimCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupClaimCreate', String(error)) };
    }
  }
}

/**
 * Validator for GroupClaimGet
 */
export class GroupClaimGetValidator extends BaseValidator<GroupClaimGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "group_id": {
      "description": "Group ID",
      "title": "Group Id",
      "type": "string"
    },
    "claim_type": {
      "description": "Type of claim",
      "title": "Claim Type",
      "type": "string"
    },
    "claim_value": {
      "description": "Value of the claim",
      "title": "Claim Value",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional properties",
      "title": "Properties"
    }
  },
  "required": [
    "group_id",
    "claim_type",
    "claim_value"
  ],
  "title": "GroupClaimGet",
  "type": "object",
  "x-model-name": "GroupClaimGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupClaimGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupClaimGet', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: group_id
    if (!('group_id' in data)) {
      errors.push('Missing required field: group_id');
    } else {
      if (typeof data.group_id !== 'string') {
        errors.push('Field group_id must be a string');
      }
    }

    // Required field: claim_type
    if (!('claim_type' in data)) {
      errors.push('Missing required field: claim_type');
    } else {
      if (typeof data.claim_type !== 'string') {
        errors.push('Field claim_type must be a string');
      }
    }

    // Required field: claim_value
    if (!('claim_value' in data)) {
      errors.push('Missing required field: claim_value');
    } else {
      if (typeof data.claim_value !== 'string') {
        errors.push('Field claim_value must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupClaimGet', errors.join('; '));
    }

    return data as GroupClaimGet;
  }

  safeValidate(data: any): { success: true; data: GroupClaimGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupClaimGet', String(error)) };
    }
  }
}

/**
 * Validator for GroupClaimList
 */
export class GroupClaimListValidator extends BaseValidator<GroupClaimList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "group_id": {
      "description": "Group ID",
      "title": "Group Id",
      "type": "string"
    },
    "claim_type": {
      "description": "Type of claim",
      "title": "Claim Type",
      "type": "string"
    },
    "claim_value": {
      "description": "Value of the claim",
      "title": "Claim Value",
      "type": "string"
    }
  },
  "required": [
    "group_id",
    "claim_type",
    "claim_value"
  ],
  "title": "GroupClaimList",
  "type": "object",
  "x-model-name": "GroupClaimList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupClaimList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupClaimList', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: group_id
    if (!('group_id' in data)) {
      errors.push('Missing required field: group_id');
    } else {
      if (typeof data.group_id !== 'string') {
        errors.push('Field group_id must be a string');
      }
    }

    // Required field: claim_type
    if (!('claim_type' in data)) {
      errors.push('Missing required field: claim_type');
    } else {
      if (typeof data.claim_type !== 'string') {
        errors.push('Field claim_type must be a string');
      }
    }

    // Required field: claim_value
    if (!('claim_value' in data)) {
      errors.push('Missing required field: claim_value');
    } else {
      if (typeof data.claim_value !== 'string') {
        errors.push('Field claim_value must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupClaimList', errors.join('; '));
    }

    return data as GroupClaimList;
  }

  safeValidate(data: any): { success: true; data: GroupClaimList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupClaimList', String(error)) };
    }
  }
}

/**
 * Validator for GroupClaimUpdate
 */
export class GroupClaimUpdateValidator extends BaseValidator<GroupClaimUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional claim properties",
      "title": "Properties"
    }
  },
  "title": "GroupClaimUpdate",
  "type": "object",
  "x-model-name": "GroupClaimUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupClaimUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupClaimUpdate', 'Expected an object');
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupClaimUpdate', errors.join('; '));
    }

    return data as GroupClaimUpdate;
  }

  safeValidate(data: any): { success: true; data: GroupClaimUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupClaimUpdate', String(error)) };
    }
  }
}

/**
 * Validator for GroupClaimQuery
 */
export class GroupClaimQueryValidator extends BaseValidator<GroupClaimQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by group ID",
      "title": "Group Id"
    },
    "claim_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by claim type",
      "title": "Claim Type"
    },
    "claim_value": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by claim value",
      "title": "Claim Value"
    }
  },
  "title": "GroupClaimQuery",
  "type": "object",
  "x-model-name": "GroupClaimQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GroupClaimQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GroupClaimQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: group_id
    if ('group_id' in data && data.group_id !== undefined && data.group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: claim_type
    if ('claim_type' in data && data.claim_type !== undefined && data.claim_type !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: claim_value
    if ('claim_value' in data && data.claim_value !== undefined && data.claim_value !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GroupClaimQuery', errors.join('; '));
    }

    return data as GroupClaimQuery;
  }

  safeValidate(data: any): { success: true; data: GroupClaimQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GroupClaimQuery', String(error)) };
    }
  }
}

/**
 * Information about a team member (for display in team lists).
 */
export class TeamMemberInfoValidator extends BaseValidator<TeamMemberInfo> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Information about a team member (for display in team lists).",
  "properties": {
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "user_id": {
      "title": "User Id",
      "type": "string"
    },
    "given_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Given Name"
    },
    "family_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Family Name"
    },
    "email": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Email"
    }
  },
  "required": [
    "course_member_id",
    "user_id"
  ],
  "title": "TeamMemberInfo",
  "type": "object",
  "x-model-name": "TeamMemberInfo"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TeamMemberInfo {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TeamMemberInfo', 'Expected an object');
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Optional field: given_name
    if ('given_name' in data && data.given_name !== undefined && data.given_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: family_name
    if ('family_name' in data && data.family_name !== undefined && data.family_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: email
    if ('email' in data && data.email !== undefined && data.email !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TeamMemberInfo', errors.join('; '));
    }

    return data as TeamMemberInfo;
  }

  safeValidate(data: any): { success: true; data: TeamMemberInfo } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TeamMemberInfo', String(error)) };
    }
  }
}

/**
 * Team formation rules resolved from Course and CourseContent.
 */
export class TeamFormationRulesValidator extends BaseValidator<TeamFormationRules> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Team formation rules resolved from Course and CourseContent.",
  "properties": {
    "mode": {
      "default": "self_organized",
      "title": "Mode",
      "type": "string"
    },
    "max_group_size": {
      "title": "Max Group Size",
      "type": "integer"
    },
    "min_group_size": {
      "default": 1,
      "title": "Min Group Size",
      "type": "integer"
    },
    "formation_deadline": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Formation Deadline"
    },
    "allow_student_group_creation": {
      "default": true,
      "title": "Allow Student Group Creation",
      "type": "boolean"
    },
    "allow_student_join_groups": {
      "default": true,
      "title": "Allow Student Join Groups",
      "type": "boolean"
    },
    "allow_student_leave_groups": {
      "default": true,
      "title": "Allow Student Leave Groups",
      "type": "boolean"
    },
    "auto_assign_unmatched": {
      "default": false,
      "title": "Auto Assign Unmatched",
      "type": "boolean"
    },
    "lock_teams_at_deadline": {
      "default": true,
      "title": "Lock Teams At Deadline",
      "type": "boolean"
    },
    "require_approval": {
      "default": false,
      "title": "Require Approval",
      "type": "boolean"
    }
  },
  "required": [
    "max_group_size"
  ],
  "title": "TeamFormationRules",
  "type": "object",
  "x-model-name": "TeamFormationRules"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TeamFormationRules {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TeamFormationRules', 'Expected an object');
    }

    // Optional field: mode
    if ('mode' in data && data.mode !== undefined && data.mode !== null) {
      if (typeof data.mode !== 'string') {
        errors.push('Field mode must be a string');
      }
    }

    // Required field: max_group_size
    if (!('max_group_size' in data)) {
      errors.push('Missing required field: max_group_size');
    } else {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: min_group_size
    if ('min_group_size' in data && data.min_group_size !== undefined && data.min_group_size !== null) {
      if (typeof data.min_group_size !== 'number') {
        errors.push('Field min_group_size must be a number');
      }
    }

    // Optional field: formation_deadline
    if ('formation_deadline' in data && data.formation_deadline !== undefined && data.formation_deadline !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: allow_student_group_creation
    if ('allow_student_group_creation' in data && data.allow_student_group_creation !== undefined && data.allow_student_group_creation !== null) {
      if (typeof data.allow_student_group_creation !== 'boolean') {
        errors.push('Field allow_student_group_creation must be a boolean');
      }
    }

    // Optional field: allow_student_join_groups
    if ('allow_student_join_groups' in data && data.allow_student_join_groups !== undefined && data.allow_student_join_groups !== null) {
      if (typeof data.allow_student_join_groups !== 'boolean') {
        errors.push('Field allow_student_join_groups must be a boolean');
      }
    }

    // Optional field: allow_student_leave_groups
    if ('allow_student_leave_groups' in data && data.allow_student_leave_groups !== undefined && data.allow_student_leave_groups !== null) {
      if (typeof data.allow_student_leave_groups !== 'boolean') {
        errors.push('Field allow_student_leave_groups must be a boolean');
      }
    }

    // Optional field: auto_assign_unmatched
    if ('auto_assign_unmatched' in data && data.auto_assign_unmatched !== undefined && data.auto_assign_unmatched !== null) {
      if (typeof data.auto_assign_unmatched !== 'boolean') {
        errors.push('Field auto_assign_unmatched must be a boolean');
      }
    }

    // Optional field: lock_teams_at_deadline
    if ('lock_teams_at_deadline' in data && data.lock_teams_at_deadline !== undefined && data.lock_teams_at_deadline !== null) {
      if (typeof data.lock_teams_at_deadline !== 'boolean') {
        errors.push('Field lock_teams_at_deadline must be a boolean');
      }
    }

    // Optional field: require_approval
    if ('require_approval' in data && data.require_approval !== undefined && data.require_approval !== null) {
      if (typeof data.require_approval !== 'boolean') {
        errors.push('Field require_approval must be a boolean');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('TeamFormationRules', errors.join('; '));
    }

    return data as TeamFormationRules;
  }

  safeValidate(data: any): { success: true; data: TeamFormationRules } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TeamFormationRules', String(error)) };
    }
  }
}

/**
 * Request to create a new team.
 */
export class TeamCreateValidator extends BaseValidator<TeamCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Request to create a new team.",
  "properties": {
    "team_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Optional team name (default: generated from members)",
      "title": "Team Name"
    }
  },
  "title": "TeamCreate",
  "type": "object",
  "x-model-name": "TeamCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TeamCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TeamCreate', 'Expected an object');
    }

    // Optional field: team_name
    if ('team_name' in data && data.team_name !== undefined && data.team_name !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TeamCreate', errors.join('; '));
    }

    return data as TeamCreate;
  }

  safeValidate(data: any): { success: true; data: TeamCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TeamCreate', String(error)) };
    }
  }
}

/**
 * Response when team is created or retrieved.
 */
export class TeamResponseValidator extends BaseValidator<TeamResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TeamMemberInfo": {
      "description": "Information about a team member (for display in team lists).",
      "properties": {
        "course_member_id": {
          "title": "Course Member Id",
          "type": "string"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "given_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Family Name"
        },
        "email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Email"
        }
      },
      "required": [
        "course_member_id",
        "user_id"
      ],
      "title": "TeamMemberInfo",
      "type": "object"
    }
  },
  "description": "Response when team is created or retrieved.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "max_group_size": {
      "title": "Max Group Size",
      "type": "integer"
    },
    "status": {
      "default": "forming",
      "title": "Status",
      "type": "string"
    },
    "created_by": {
      "default": "student",
      "title": "Created By",
      "type": "string"
    },
    "join_code": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Join Code"
    },
    "members": {
      "items": {
        "$ref": "#/$defs/TeamMemberInfo"
      },
      "title": "Members",
      "type": "array"
    },
    "member_count": {
      "title": "Member Count",
      "type": "integer"
    },
    "can_join": {
      "title": "Can Join",
      "type": "boolean"
    },
    "locked_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Locked At"
    }
  },
  "required": [
    "id",
    "course_content_id",
    "course_id",
    "max_group_size",
    "members",
    "member_count",
    "can_join"
  ],
  "title": "TeamResponse",
  "type": "object",
  "x-model-name": "TeamResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TeamResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TeamResponse', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: max_group_size
    if (!('max_group_size' in data)) {
      errors.push('Missing required field: max_group_size');
    } else {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      if (typeof data.status !== 'string') {
        errors.push('Field status must be a string');
      }
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      if (typeof data.created_by !== 'string') {
        errors.push('Field created_by must be a string');
      }
    }

    // Optional field: join_code
    if ('join_code' in data && data.join_code !== undefined && data.join_code !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: members
    if (!('members' in data)) {
      errors.push('Missing required field: members');
    } else {
      if (!Array.isArray(data.members)) {
        errors.push('Field members must be an array');
      }
    }

    // Required field: member_count
    if (!('member_count' in data)) {
      errors.push('Missing required field: member_count');
    } else {
      if (typeof data.member_count !== 'number') {
        errors.push('Field member_count must be a number');
      }
    }

    // Required field: can_join
    if (!('can_join' in data)) {
      errors.push('Missing required field: can_join');
    } else {
      if (typeof data.can_join !== 'boolean') {
        errors.push('Field can_join must be a boolean');
      }
    }

    // Optional field: locked_at
    if ('locked_at' in data && data.locked_at !== undefined && data.locked_at !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TeamResponse', errors.join('; '));
    }

    return data as TeamResponse;
  }

  safeValidate(data: any): { success: true; data: TeamResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TeamResponse', String(error)) };
    }
  }
}

/**
 * Team available for joining (limited info for privacy).
 */
export class AvailableTeamValidator extends BaseValidator<AvailableTeam> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TeamMemberInfo": {
      "description": "Information about a team member (for display in team lists).",
      "properties": {
        "course_member_id": {
          "title": "Course Member Id",
          "type": "string"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "given_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Family Name"
        },
        "email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Email"
        }
      },
      "required": [
        "course_member_id",
        "user_id"
      ],
      "title": "TeamMemberInfo",
      "type": "object"
    }
  },
  "description": "Team available for joining (limited info for privacy).",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "member_count": {
      "title": "Member Count",
      "type": "integer"
    },
    "max_group_size": {
      "title": "Max Group Size",
      "type": "integer"
    },
    "join_code": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Join Code"
    },
    "requires_approval": {
      "title": "Requires Approval",
      "type": "boolean"
    },
    "status": {
      "title": "Status",
      "type": "string"
    },
    "members": {
      "items": {
        "$ref": "#/$defs/TeamMemberInfo"
      },
      "title": "Members",
      "type": "array"
    }
  },
  "required": [
    "id",
    "member_count",
    "max_group_size",
    "requires_approval",
    "status",
    "members"
  ],
  "title": "AvailableTeam",
  "type": "object",
  "x-model-name": "AvailableTeam"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): AvailableTeam {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('AvailableTeam', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: member_count
    if (!('member_count' in data)) {
      errors.push('Missing required field: member_count');
    } else {
      if (typeof data.member_count !== 'number') {
        errors.push('Field member_count must be a number');
      }
    }

    // Required field: max_group_size
    if (!('max_group_size' in data)) {
      errors.push('Missing required field: max_group_size');
    } else {
      if (typeof data.max_group_size !== 'number') {
        errors.push('Field max_group_size must be a number');
      }
    }

    // Optional field: join_code
    if ('join_code' in data && data.join_code !== undefined && data.join_code !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: requires_approval
    if (!('requires_approval' in data)) {
      errors.push('Missing required field: requires_approval');
    } else {
      if (typeof data.requires_approval !== 'boolean') {
        errors.push('Field requires_approval must be a boolean');
      }
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      if (typeof data.status !== 'string') {
        errors.push('Field status must be a string');
      }
    }

    // Required field: members
    if (!('members' in data)) {
      errors.push('Missing required field: members');
    } else {
      if (!Array.isArray(data.members)) {
        errors.push('Field members must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('AvailableTeam', errors.join('; '));
    }

    return data as AvailableTeam;
  }

  safeValidate(data: any): { success: true; data: AvailableTeam } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('AvailableTeam', String(error)) };
    }
  }
}

/**
 * Request to join a team.
 */
export class JoinTeamRequestValidator extends BaseValidator<JoinTeamRequest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Request to join a team.",
  "properties": {
    "join_code": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Optional join code for direct access",
      "title": "Join Code"
    }
  },
  "title": "JoinTeamRequest",
  "type": "object",
  "x-model-name": "JoinTeamRequest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): JoinTeamRequest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('JoinTeamRequest', 'Expected an object');
    }

    // Optional field: join_code
    if ('join_code' in data && data.join_code !== undefined && data.join_code !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('JoinTeamRequest', errors.join('; '));
    }

    return data as JoinTeamRequest;
  }

  safeValidate(data: any): { success: true; data: JoinTeamRequest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('JoinTeamRequest', String(error)) };
    }
  }
}

/**
 * Response when joining a team.
 */
export class JoinTeamResponseValidator extends BaseValidator<JoinTeamResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Response when joining a team.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "status": {
      "title": "Status",
      "type": "string"
    },
    "message": {
      "title": "Message",
      "type": "string"
    }
  },
  "required": [
    "id",
    "status",
    "message"
  ],
  "title": "JoinTeamResponse",
  "type": "object",
  "x-model-name": "JoinTeamResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): JoinTeamResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('JoinTeamResponse', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      if (typeof data.status !== 'string') {
        errors.push('Field status must be a string');
      }
    }

    // Required field: message
    if (!('message' in data)) {
      errors.push('Missing required field: message');
    } else {
      if (typeof data.message !== 'string') {
        errors.push('Field message must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('JoinTeamResponse', errors.join('; '));
    }

    return data as JoinTeamResponse;
  }

  safeValidate(data: any): { success: true; data: JoinTeamResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('JoinTeamResponse', String(error)) };
    }
  }
}

/**
 * Response when leaving a team.
 */
export class LeaveTeamResponseValidator extends BaseValidator<LeaveTeamResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Response when leaving a team.",
  "properties": {
    "success": {
      "title": "Success",
      "type": "boolean"
    },
    "message": {
      "title": "Message",
      "type": "string"
    }
  },
  "required": [
    "success",
    "message"
  ],
  "title": "LeaveTeamResponse",
  "type": "object",
  "x-model-name": "LeaveTeamResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LeaveTeamResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LeaveTeamResponse', 'Expected an object');
    }

    // Required field: success
    if (!('success' in data)) {
      errors.push('Missing required field: success');
    } else {
      if (typeof data.success !== 'boolean') {
        errors.push('Field success must be a boolean');
      }
    }

    // Required field: message
    if (!('message' in data)) {
      errors.push('Missing required field: message');
    } else {
      if (typeof data.message !== 'string') {
        errors.push('Field message must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('LeaveTeamResponse', errors.join('; '));
    }

    return data as LeaveTeamResponse;
  }

  safeValidate(data: any): { success: true; data: LeaveTeamResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LeaveTeamResponse', String(error)) };
    }
  }
}

/**
 * Request to lock a team (instructor only).
 */
export class TeamLockRequestValidator extends BaseValidator<TeamLockRequest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Request to lock a team (instructor only).",
  "properties": {
    "reason": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Optional reason for locking",
      "title": "Reason"
    }
  },
  "title": "TeamLockRequest",
  "type": "object",
  "x-model-name": "TeamLockRequest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TeamLockRequest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TeamLockRequest', 'Expected an object');
    }

    // Optional field: reason
    if ('reason' in data && data.reason !== undefined && data.reason !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TeamLockRequest', errors.join('; '));
    }

    return data as TeamLockRequest;
  }

  safeValidate(data: any): { success: true; data: TeamLockRequest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TeamLockRequest', String(error)) };
    }
  }
}

/**
 * Response when team is locked.
 */
export class TeamLockResponseValidator extends BaseValidator<TeamLockResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Response when team is locked.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "locked_at": {
      "format": "date-time",
      "title": "Locked At",
      "type": "string"
    },
    "message": {
      "title": "Message",
      "type": "string"
    }
  },
  "required": [
    "id",
    "locked_at",
    "message"
  ],
  "title": "TeamLockResponse",
  "type": "object",
  "x-model-name": "TeamLockResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TeamLockResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TeamLockResponse', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: locked_at
    if (!('locked_at' in data)) {
      errors.push('Missing required field: locked_at');
    } else {
      if (typeof data.locked_at !== 'string') {
        errors.push('Field locked_at must be a string');
      }
    }

    // Required field: message
    if (!('message' in data)) {
      errors.push('Missing required field: message');
    } else {
      if (typeof data.message !== 'string') {
        errors.push('Field message must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('TeamLockResponse', errors.join('; '));
    }

    return data as TeamLockResponse;
  }

  safeValidate(data: any): { success: true; data: TeamLockResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TeamLockResponse', String(error)) };
    }
  }
}

/**
 * DTO for creating submission artifacts.

    This is used internally when processing submission uploads.
    The upload endpoint accepts SubmissionCreate which only has:
    - submission_group_id
    - version_identifier (optional)
 */
export class SubmissionArtifactCreateValidator extends BaseValidator<SubmissionArtifactCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for creating submission artifacts.\\n\\n    This is used internally when processing submission uploads.\\n    The upload endpoint accepts SubmissionCreate which only has:\\n    - submission_group_id\\n    - version_identifier (optional)",
  "properties": {
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Identifier"
    }
  },
  "required": [
    "submission_group_id"
  ],
  "title": "SubmissionArtifactCreate",
  "type": "object",
  "x-model-name": "SubmissionArtifactCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionArtifactCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionArtifactCreate', 'Expected an object');
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Optional field: version_identifier
    if ('version_identifier' in data && data.version_identifier !== undefined && data.version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionArtifactCreate', errors.join('; '));
    }

    return data as SubmissionArtifactCreate;
  }

  safeValidate(data: any): { success: true; data: SubmissionArtifactCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionArtifactCreate', String(error)) };
    }
  }
}

/**
 * DTO for updating submission artifacts.
 */
export class SubmissionArtifactUpdateValidator extends BaseValidator<SubmissionArtifactUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for updating submission artifacts.",
  "properties": {
    "submit": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submit"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    }
  },
  "title": "SubmissionArtifactUpdate",
  "type": "object",
  "x-model-name": "SubmissionArtifactUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionArtifactUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionArtifactUpdate', 'Expected an object');
    }

    // Optional field: submit
    if ('submit' in data && data.submit !== undefined && data.submit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionArtifactUpdate', errors.join('; '));
    }

    return data as SubmissionArtifactUpdate;
  }

  safeValidate(data: any): { success: true; data: SubmissionArtifactUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionArtifactUpdate', String(error)) };
    }
  }
}

/**
 * List item representation for submission artifacts.

    Essential metadata is stored in proper database columns.
    Properties field is kept for legacy compatibility and future extensibility.
 */
export class SubmissionArtifactListValidator extends BaseValidator<SubmissionArtifactList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ResultList": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "id": {
          "title": "Id",
          "type": "string"
        },
        "course_member_id": {
          "title": "Course Member Id",
          "type": "string"
        },
        "course_content_id": {
          "title": "Course Content Id",
          "type": "string"
        },
        "course_content_type_id": {
          "title": "Course Content Type Id",
          "type": "string"
        },
        "submission_group_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Submission Group Id"
        },
        "submission_artifact_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Submission Artifact Id"
        },
        "execution_backend_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Execution Backend Id"
        },
        "test_system_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Test System Id"
        },
        "result": {
          "title": "Result",
          "type": "number"
        },
        "grade": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Grade"
        },
        "version_identifier": {
          "title": "Version Identifier",
          "type": "string"
        },
        "reference_version_identifier": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Reference Version Identifier"
        },
        "status": {
          "$ref": "#/$defs/TaskStatus"
        }
      },
      "required": [
        "id",
        "course_member_id",
        "course_content_id",
        "course_content_type_id",
        "result",
        "version_identifier",
        "status"
      ],
      "title": "ResultList",
      "type": "object"
    },
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "description": "List item representation for submission artifacts.\\n\\n    Essential metadata is stored in proper database columns.\\n    Properties field is kept for legacy compatibility and future extensibility.",
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "uploaded_by_course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Uploaded By Course Member Id"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Content Type"
    },
    "file_size": {
      "title": "File Size",
      "type": "integer"
    },
    "bucket_name": {
      "title": "Bucket Name",
      "type": "string"
    },
    "object_key": {
      "title": "Object Key",
      "type": "string"
    },
    "uploaded_at": {
      "format": "date-time",
      "title": "Uploaded At",
      "type": "string"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Identifier"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "latest_result": {
      "anyOf": [
        {
          "$ref": "#/$defs/ResultList"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "id",
    "submission_group_id",
    "file_size",
    "bucket_name",
    "object_key",
    "uploaded_at"
  ],
  "title": "SubmissionArtifactList",
  "type": "object",
  "x-model-name": "SubmissionArtifactList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionArtifactList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionArtifactList', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Optional field: uploaded_by_course_member_id
    if ('uploaded_by_course_member_id' in data && data.uploaded_by_course_member_id !== undefined && data.uploaded_by_course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: file_size
    if (!('file_size' in data)) {
      errors.push('Missing required field: file_size');
    } else {
      if (typeof data.file_size !== 'number') {
        errors.push('Field file_size must be a number');
      }
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Required field: uploaded_at
    if (!('uploaded_at' in data)) {
      errors.push('Missing required field: uploaded_at');
    } else {
      if (typeof data.uploaded_at !== 'string') {
        errors.push('Field uploaded_at must be a string');
      }
    }

    // Optional field: version_identifier
    if ('version_identifier' in data && data.version_identifier !== undefined && data.version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: latest_result
    if ('latest_result' in data && data.latest_result !== undefined && data.latest_result !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionArtifactList', errors.join('; '));
    }

    return data as SubmissionArtifactList;
  }

  safeValidate(data: any): { success: true; data: SubmissionArtifactList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionArtifactList', String(error)) };
    }
  }
}

/**
 * Detailed view of submission artifact with related data.
 */
export class SubmissionArtifactGetValidator extends BaseValidator<SubmissionArtifactGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ResultList": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "id": {
          "title": "Id",
          "type": "string"
        },
        "course_member_id": {
          "title": "Course Member Id",
          "type": "string"
        },
        "course_content_id": {
          "title": "Course Content Id",
          "type": "string"
        },
        "course_content_type_id": {
          "title": "Course Content Type Id",
          "type": "string"
        },
        "submission_group_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Submission Group Id"
        },
        "submission_artifact_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Submission Artifact Id"
        },
        "execution_backend_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Execution Backend Id"
        },
        "test_system_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Test System Id"
        },
        "result": {
          "title": "Result",
          "type": "number"
        },
        "grade": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Grade"
        },
        "version_identifier": {
          "title": "Version Identifier",
          "type": "string"
        },
        "reference_version_identifier": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Reference Version Identifier"
        },
        "status": {
          "$ref": "#/$defs/TaskStatus"
        }
      },
      "required": [
        "id",
        "course_member_id",
        "course_content_id",
        "course_content_type_id",
        "result",
        "version_identifier",
        "status"
      ],
      "title": "ResultList",
      "type": "object"
    },
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "description": "Detailed view of submission artifact with related data.",
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "uploaded_by_course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Uploaded By Course Member Id"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Content Type"
    },
    "file_size": {
      "title": "File Size",
      "type": "integer"
    },
    "bucket_name": {
      "title": "Bucket Name",
      "type": "string"
    },
    "object_key": {
      "title": "Object Key",
      "type": "string"
    },
    "uploaded_at": {
      "format": "date-time",
      "title": "Uploaded At",
      "type": "string"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Identifier"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "latest_result": {
      "anyOf": [
        {
          "$ref": "#/$defs/ResultList"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "test_results_count": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test Results Count"
    },
    "grades_count": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grades Count"
    },
    "reviews_count": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Reviews Count"
    },
    "average_grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Average Grade"
    }
  },
  "required": [
    "id",
    "submission_group_id",
    "file_size",
    "bucket_name",
    "object_key",
    "uploaded_at"
  ],
  "title": "SubmissionArtifactGet",
  "type": "object",
  "x-model-name": "SubmissionArtifactGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionArtifactGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionArtifactGet', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Optional field: uploaded_by_course_member_id
    if ('uploaded_by_course_member_id' in data && data.uploaded_by_course_member_id !== undefined && data.uploaded_by_course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: file_size
    if (!('file_size' in data)) {
      errors.push('Missing required field: file_size');
    } else {
      if (typeof data.file_size !== 'number') {
        errors.push('Field file_size must be a number');
      }
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Required field: uploaded_at
    if (!('uploaded_at' in data)) {
      errors.push('Missing required field: uploaded_at');
    } else {
      if (typeof data.uploaded_at !== 'string') {
        errors.push('Field uploaded_at must be a string');
      }
    }

    // Optional field: version_identifier
    if ('version_identifier' in data && data.version_identifier !== undefined && data.version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: latest_result
    if ('latest_result' in data && data.latest_result !== undefined && data.latest_result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_results_count
    if ('test_results_count' in data && data.test_results_count !== undefined && data.test_results_count !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grades_count
    if ('grades_count' in data && data.grades_count !== undefined && data.grades_count !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: reviews_count
    if ('reviews_count' in data && data.reviews_count !== undefined && data.reviews_count !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: average_grade
    if ('average_grade' in data && data.average_grade !== undefined && data.average_grade !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionArtifactGet', errors.join('; '));
    }

    return data as SubmissionArtifactGet;
  }

  safeValidate(data: any): { success: true; data: SubmissionArtifactGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionArtifactGet', String(error)) };
    }
  }
}

/**
 * Query parameters for listing submission artifacts.
 */
export class SubmissionArtifactQueryValidator extends BaseValidator<SubmissionArtifactQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Query parameters for listing submission artifacts.",
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "uploaded_by_course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Uploaded By Course Member Id"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Content Type"
    }
  },
  "title": "SubmissionArtifactQuery",
  "type": "object",
  "x-model-name": "SubmissionArtifactQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionArtifactQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionArtifactQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: uploaded_by_course_member_id
    if ('uploaded_by_course_member_id' in data && data.uploaded_by_course_member_id !== undefined && data.uploaded_by_course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionArtifactQuery', errors.join('; '));
    }

    return data as SubmissionArtifactQuery;
  }

  safeValidate(data: any): { success: true; data: SubmissionArtifactQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionArtifactQuery', String(error)) };
    }
  }
}

/**
 * DTO for creating submission grades.
 */
export class SubmissionGradeCreateValidator extends BaseValidator<SubmissionGradeCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "DTO for creating submission grades.",
  "properties": {
    "artifact_id": {
      "title": "Artifact Id",
      "type": "string"
    },
    "graded_by_course_member_id": {
      "title": "Graded By Course Member Id",
      "type": "string"
    },
    "grade": {
      "title": "Grade",
      "type": "number"
    },
    "status": {
      "$ref": "#/$defs/GradingStatus",
      "default": 0
    },
    "comment": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Comment"
    }
  },
  "required": [
    "artifact_id",
    "graded_by_course_member_id",
    "grade"
  ],
  "title": "SubmissionGradeCreate",
  "type": "object",
  "x-model-name": "SubmissionGradeCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGradeCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGradeCreate', 'Expected an object');
    }

    // Required field: artifact_id
    if (!('artifact_id' in data)) {
      errors.push('Missing required field: artifact_id');
    } else {
      if (typeof data.artifact_id !== 'string') {
        errors.push('Field artifact_id must be a string');
      }
    }

    // Required field: graded_by_course_member_id
    if (!('graded_by_course_member_id' in data)) {
      errors.push('Missing required field: graded_by_course_member_id');
    } else {
      if (typeof data.graded_by_course_member_id !== 'string') {
        errors.push('Field graded_by_course_member_id must be a string');
      }
    }

    // Required field: grade
    if (!('grade' in data)) {
      errors.push('Missing required field: grade');
    } else {
      if (typeof data.grade !== 'number') {
        errors.push('Field grade must be a number');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: comment
    if ('comment' in data && data.comment !== undefined && data.comment !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGradeCreate', errors.join('; '));
    }

    return data as SubmissionGradeCreate;
  }

  safeValidate(data: any): { success: true; data: SubmissionGradeCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGradeCreate', String(error)) };
    }
  }
}

/**
 * DTO for updating submission grades.
 */
export class SubmissionGradeUpdateValidator extends BaseValidator<SubmissionGradeUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "DTO for updating submission grades.",
  "properties": {
    "grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grade"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradingStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "comment": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Comment"
    }
  },
  "title": "SubmissionGradeUpdate",
  "type": "object",
  "x-model-name": "SubmissionGradeUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGradeUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGradeUpdate', 'Expected an object');
    }

    // Optional field: grade
    if ('grade' in data && data.grade !== undefined && data.grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: comment
    if ('comment' in data && data.comment !== undefined && data.comment !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGradeUpdate', errors.join('; '));
    }

    return data as SubmissionGradeUpdate;
  }

  safeValidate(data: any): { success: true; data: SubmissionGradeUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGradeUpdate', String(error)) };
    }
  }
}

/**
 * List item representation for submission grades.
 */
export class SubmissionGradeListItemValidator extends BaseValidator<SubmissionGradeListItem> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "List item representation for submission grades.",
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "artifact_id": {
      "title": "Artifact Id",
      "type": "string"
    },
    "graded_by_course_member_id": {
      "title": "Graded By Course Member Id",
      "type": "string"
    },
    "grade": {
      "title": "Grade",
      "type": "number"
    },
    "status": {
      "$ref": "#/$defs/GradingStatus"
    },
    "comment": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Comment"
    },
    "graded_at": {
      "format": "date-time",
      "title": "Graded At",
      "type": "string"
    }
  },
  "required": [
    "id",
    "artifact_id",
    "graded_by_course_member_id",
    "grade",
    "status",
    "graded_at"
  ],
  "title": "SubmissionGradeListItem",
  "type": "object",
  "x-model-name": "SubmissionGradeListItem"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGradeListItem {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGradeListItem', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: artifact_id
    if (!('artifact_id' in data)) {
      errors.push('Missing required field: artifact_id');
    } else {
      if (typeof data.artifact_id !== 'string') {
        errors.push('Field artifact_id must be a string');
      }
    }

    // Required field: graded_by_course_member_id
    if (!('graded_by_course_member_id' in data)) {
      errors.push('Missing required field: graded_by_course_member_id');
    } else {
      if (typeof data.graded_by_course_member_id !== 'string') {
        errors.push('Field graded_by_course_member_id must be a string');
      }
    }

    // Required field: grade
    if (!('grade' in data)) {
      errors.push('Missing required field: grade');
    } else {
      if (typeof data.grade !== 'number') {
        errors.push('Field grade must be a number');
      }
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: comment
    if ('comment' in data && data.comment !== undefined && data.comment !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: graded_at
    if (!('graded_at' in data)) {
      errors.push('Missing required field: graded_at');
    } else {
      if (typeof data.graded_at !== 'string') {
        errors.push('Field graded_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGradeListItem', errors.join('; '));
    }

    return data as SubmissionGradeListItem;
  }

  safeValidate(data: any): { success: true; data: SubmissionGradeListItem } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGradeListItem', String(error)) };
    }
  }
}

/**
 * Detailed view of submission grade.
 */
export class SubmissionGradeDetailValidator extends BaseValidator<SubmissionGradeDetail> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "Detailed view of submission grade.",
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "artifact_id": {
      "title": "Artifact Id",
      "type": "string"
    },
    "graded_by_course_member_id": {
      "title": "Graded By Course Member Id",
      "type": "string"
    },
    "grade": {
      "title": "Grade",
      "type": "number"
    },
    "status": {
      "$ref": "#/$defs/GradingStatus"
    },
    "comment": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Comment"
    },
    "graded_at": {
      "format": "date-time",
      "title": "Graded At",
      "type": "string"
    }
  },
  "required": [
    "id",
    "artifact_id",
    "graded_by_course_member_id",
    "grade",
    "status",
    "graded_at"
  ],
  "title": "SubmissionGradeDetail",
  "type": "object",
  "x-model-name": "SubmissionGradeDetail"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGradeDetail {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGradeDetail', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: artifact_id
    if (!('artifact_id' in data)) {
      errors.push('Missing required field: artifact_id');
    } else {
      if (typeof data.artifact_id !== 'string') {
        errors.push('Field artifact_id must be a string');
      }
    }

    // Required field: graded_by_course_member_id
    if (!('graded_by_course_member_id' in data)) {
      errors.push('Missing required field: graded_by_course_member_id');
    } else {
      if (typeof data.graded_by_course_member_id !== 'string') {
        errors.push('Field graded_by_course_member_id must be a string');
      }
    }

    // Required field: grade
    if (!('grade' in data)) {
      errors.push('Missing required field: grade');
    } else {
      if (typeof data.grade !== 'number') {
        errors.push('Field grade must be a number');
      }
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: comment
    if ('comment' in data && data.comment !== undefined && data.comment !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: graded_at
    if (!('graded_at' in data)) {
      errors.push('Missing required field: graded_at');
    } else {
      if (typeof data.graded_at !== 'string') {
        errors.push('Field graded_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGradeDetail', errors.join('; '));
    }

    return data as SubmissionGradeDetail;
  }

  safeValidate(data: any): { success: true; data: SubmissionGradeDetail } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGradeDetail', String(error)) };
    }
  }
}

/**
 * Query parameters for listing submission grades.
 */
export class SubmissionGradeQueryValidator extends BaseValidator<SubmissionGradeQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "Query parameters for listing submission grades.",
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Artifact Id"
    },
    "graded_by_course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Graded By Course Member Id"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradingStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "title": "SubmissionGradeQuery",
  "type": "object",
  "x-model-name": "SubmissionGradeQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGradeQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGradeQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: artifact_id
    if ('artifact_id' in data && data.artifact_id !== undefined && data.artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: graded_by_course_member_id
    if ('graded_by_course_member_id' in data && data.graded_by_course_member_id !== undefined && data.graded_by_course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGradeQuery', errors.join('; '));
    }

    return data as SubmissionGradeQuery;
  }

  safeValidate(data: any): { success: true; data: SubmissionGradeQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGradeQuery', String(error)) };
    }
  }
}

/**
 * DTO for creating submission reviews.
 */
export class SubmissionReviewCreateValidator extends BaseValidator<SubmissionReviewCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for creating submission reviews.",
  "properties": {
    "artifact_id": {
      "title": "Artifact Id",
      "type": "string"
    },
    "reviewer_course_member_id": {
      "title": "Reviewer Course Member Id",
      "type": "string"
    },
    "body": {
      "title": "Body",
      "type": "string"
    },
    "review_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Review Type"
    }
  },
  "required": [
    "artifact_id",
    "reviewer_course_member_id",
    "body"
  ],
  "title": "SubmissionReviewCreate",
  "type": "object",
  "x-model-name": "SubmissionReviewCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionReviewCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionReviewCreate', 'Expected an object');
    }

    // Required field: artifact_id
    if (!('artifact_id' in data)) {
      errors.push('Missing required field: artifact_id');
    } else {
      if (typeof data.artifact_id !== 'string') {
        errors.push('Field artifact_id must be a string');
      }
    }

    // Required field: reviewer_course_member_id
    if (!('reviewer_course_member_id' in data)) {
      errors.push('Missing required field: reviewer_course_member_id');
    } else {
      if (typeof data.reviewer_course_member_id !== 'string') {
        errors.push('Field reviewer_course_member_id must be a string');
      }
    }

    // Required field: body
    if (!('body' in data)) {
      errors.push('Missing required field: body');
    } else {
      if (typeof data.body !== 'string') {
        errors.push('Field body must be a string');
      }
    }

    // Optional field: review_type
    if ('review_type' in data && data.review_type !== undefined && data.review_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionReviewCreate', errors.join('; '));
    }

    return data as SubmissionReviewCreate;
  }

  safeValidate(data: any): { success: true; data: SubmissionReviewCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionReviewCreate', String(error)) };
    }
  }
}

/**
 * DTO for updating submission reviews.
 */
export class SubmissionReviewUpdateValidator extends BaseValidator<SubmissionReviewUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for updating submission reviews.",
  "properties": {
    "body": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Body"
    },
    "review_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Review Type"
    }
  },
  "title": "SubmissionReviewUpdate",
  "type": "object",
  "x-model-name": "SubmissionReviewUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionReviewUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionReviewUpdate', 'Expected an object');
    }

    // Optional field: body
    if ('body' in data && data.body !== undefined && data.body !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: review_type
    if ('review_type' in data && data.review_type !== undefined && data.review_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionReviewUpdate', errors.join('; '));
    }

    return data as SubmissionReviewUpdate;
  }

  safeValidate(data: any): { success: true; data: SubmissionReviewUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionReviewUpdate', String(error)) };
    }
  }
}

/**
 * List item representation for submission reviews.
 */
export class SubmissionReviewListItemValidator extends BaseValidator<SubmissionReviewListItem> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "List item representation for submission reviews.",
  "properties": {
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "artifact_id": {
      "title": "Artifact Id",
      "type": "string"
    },
    "reviewer_course_member_id": {
      "title": "Reviewer Course Member Id",
      "type": "string"
    },
    "body": {
      "title": "Body",
      "type": "string"
    },
    "review_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Review Type"
    }
  },
  "required": [
    "created_at",
    "id",
    "artifact_id",
    "reviewer_course_member_id",
    "body"
  ],
  "title": "SubmissionReviewListItem",
  "type": "object",
  "x-model-name": "SubmissionReviewListItem"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionReviewListItem {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionReviewListItem', 'Expected an object');
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: artifact_id
    if (!('artifact_id' in data)) {
      errors.push('Missing required field: artifact_id');
    } else {
      if (typeof data.artifact_id !== 'string') {
        errors.push('Field artifact_id must be a string');
      }
    }

    // Required field: reviewer_course_member_id
    if (!('reviewer_course_member_id' in data)) {
      errors.push('Missing required field: reviewer_course_member_id');
    } else {
      if (typeof data.reviewer_course_member_id !== 'string') {
        errors.push('Field reviewer_course_member_id must be a string');
      }
    }

    // Required field: body
    if (!('body' in data)) {
      errors.push('Missing required field: body');
    } else {
      if (typeof data.body !== 'string') {
        errors.push('Field body must be a string');
      }
    }

    // Optional field: review_type
    if ('review_type' in data && data.review_type !== undefined && data.review_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionReviewListItem', errors.join('; '));
    }

    return data as SubmissionReviewListItem;
  }

  safeValidate(data: any): { success: true; data: SubmissionReviewListItem } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionReviewListItem', String(error)) };
    }
  }
}

/**
 * Detailed view of submission review.
 */
export class SubmissionReviewDetailValidator extends BaseValidator<SubmissionReviewDetail> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Detailed view of submission review.",
  "properties": {
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "artifact_id": {
      "title": "Artifact Id",
      "type": "string"
    },
    "reviewer_course_member_id": {
      "title": "Reviewer Course Member Id",
      "type": "string"
    },
    "body": {
      "title": "Body",
      "type": "string"
    },
    "review_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Review Type"
    }
  },
  "required": [
    "created_at",
    "id",
    "artifact_id",
    "reviewer_course_member_id",
    "body"
  ],
  "title": "SubmissionReviewDetail",
  "type": "object",
  "x-model-name": "SubmissionReviewDetail"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionReviewDetail {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionReviewDetail', 'Expected an object');
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: artifact_id
    if (!('artifact_id' in data)) {
      errors.push('Missing required field: artifact_id');
    } else {
      if (typeof data.artifact_id !== 'string') {
        errors.push('Field artifact_id must be a string');
      }
    }

    // Required field: reviewer_course_member_id
    if (!('reviewer_course_member_id' in data)) {
      errors.push('Missing required field: reviewer_course_member_id');
    } else {
      if (typeof data.reviewer_course_member_id !== 'string') {
        errors.push('Field reviewer_course_member_id must be a string');
      }
    }

    // Required field: body
    if (!('body' in data)) {
      errors.push('Missing required field: body');
    } else {
      if (typeof data.body !== 'string') {
        errors.push('Field body must be a string');
      }
    }

    // Optional field: review_type
    if ('review_type' in data && data.review_type !== undefined && data.review_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionReviewDetail', errors.join('; '));
    }

    return data as SubmissionReviewDetail;
  }

  safeValidate(data: any): { success: true; data: SubmissionReviewDetail } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionReviewDetail', String(error)) };
    }
  }
}

/**
 * Query parameters for listing submission reviews.
 */
export class SubmissionReviewQueryValidator extends BaseValidator<SubmissionReviewQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Query parameters for listing submission reviews.",
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Artifact Id"
    },
    "reviewer_course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Reviewer Course Member Id"
    },
    "review_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Review Type"
    }
  },
  "title": "SubmissionReviewQuery",
  "type": "object",
  "x-model-name": "SubmissionReviewQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionReviewQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionReviewQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: artifact_id
    if ('artifact_id' in data && data.artifact_id !== undefined && data.artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: reviewer_course_member_id
    if ('reviewer_course_member_id' in data && data.reviewer_course_member_id !== undefined && data.reviewer_course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: review_type
    if ('review_type' in data && data.review_type !== undefined && data.review_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionReviewQuery', errors.join('; '));
    }

    return data as SubmissionReviewQuery;
  }

  safeValidate(data: any): { success: true; data: SubmissionReviewQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionReviewQuery', String(error)) };
    }
  }
}

/**
 * DTO for creating result artifacts.
 */
export class ResultArtifactCreateValidator extends BaseValidator<ResultArtifactCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for creating result artifacts.",
  "properties": {
    "result_id": {
      "title": "Result Id",
      "type": "string"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Content Type"
    },
    "file_size": {
      "title": "File Size",
      "type": "integer"
    },
    "bucket_name": {
      "title": "Bucket Name",
      "type": "string"
    },
    "object_key": {
      "title": "Object Key",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    }
  },
  "required": [
    "result_id",
    "file_size",
    "bucket_name",
    "object_key"
  ],
  "title": "ResultArtifactCreate",
  "type": "object",
  "x-model-name": "ResultArtifactCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultArtifactCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultArtifactCreate', 'Expected an object');
    }

    // Required field: result_id
    if (!('result_id' in data)) {
      errors.push('Missing required field: result_id');
    } else {
      if (typeof data.result_id !== 'string') {
        errors.push('Field result_id must be a string');
      }
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: file_size
    if (!('file_size' in data)) {
      errors.push('Missing required field: file_size');
    } else {
      if (typeof data.file_size !== 'number') {
        errors.push('Field file_size must be a number');
      }
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultArtifactCreate', errors.join('; '));
    }

    return data as ResultArtifactCreate;
  }

  safeValidate(data: any): { success: true; data: ResultArtifactCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultArtifactCreate', String(error)) };
    }
  }
}

/**
 * List item representation for result artifacts.
 */
export class ResultArtifactListItemValidator extends BaseValidator<ResultArtifactListItem> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "List item representation for result artifacts.",
  "properties": {
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "result_id": {
      "title": "Result Id",
      "type": "string"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Content Type"
    },
    "file_size": {
      "title": "File Size",
      "type": "integer"
    },
    "bucket_name": {
      "title": "Bucket Name",
      "type": "string"
    },
    "object_key": {
      "title": "Object Key",
      "type": "string"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    }
  },
  "required": [
    "created_at",
    "id",
    "result_id",
    "file_size",
    "bucket_name",
    "object_key"
  ],
  "title": "ResultArtifactListItem",
  "type": "object",
  "x-model-name": "ResultArtifactListItem"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultArtifactListItem {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultArtifactListItem', 'Expected an object');
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: result_id
    if (!('result_id' in data)) {
      errors.push('Missing required field: result_id');
    } else {
      if (typeof data.result_id !== 'string') {
        errors.push('Field result_id must be a string');
      }
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: file_size
    if (!('file_size' in data)) {
      errors.push('Missing required field: file_size');
    } else {
      if (typeof data.file_size !== 'number') {
        errors.push('Field file_size must be a number');
      }
    }

    // Required field: bucket_name
    if (!('bucket_name' in data)) {
      errors.push('Missing required field: bucket_name');
    } else {
      if (typeof data.bucket_name !== 'string') {
        errors.push('Field bucket_name must be a string');
      }
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultArtifactListItem', errors.join('; '));
    }

    return data as ResultArtifactListItem;
  }

  safeValidate(data: any): { success: true; data: ResultArtifactListItem } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultArtifactListItem', String(error)) };
    }
  }
}

/**
 * Query parameters for listing result artifacts.
 */
export class ResultArtifactQueryValidator extends BaseValidator<ResultArtifactQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Query parameters for listing result artifacts.",
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Id"
    },
    "content_type": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Content Type"
    }
  },
  "title": "ResultArtifactQuery",
  "type": "object",
  "x-model-name": "ResultArtifactQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultArtifactQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultArtifactQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_id
    if ('result_id' in data && data.result_id !== undefined && data.result_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: content_type
    if ('content_type' in data && data.content_type !== undefined && data.content_type !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultArtifactQuery', errors.join('; '));
    }

    return data as ResultArtifactQuery;
  }

  safeValidate(data: any): { success: true; data: ResultArtifactQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultArtifactQuery', String(error)) };
    }
  }
}

/**
 * Validator for CourseMemberGitLabConfig
 */
export class CourseMemberGitLabConfigValidator extends BaseValidator<CourseMemberGitLabConfig> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "settings": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "title": "Settings"
    },
    "url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Url"
    },
    "full_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Full Path"
    },
    "directory": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Directory"
    },
    "registry": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Registry"
    },
    "parent": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Parent"
    },
    "group_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Group Id"
    },
    "parent_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Parent Id"
    },
    "namespace_id": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Namespace Id"
    },
    "namespace_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Namespace Path"
    },
    "web_url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Web Url"
    },
    "visibility": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Visibility"
    },
    "last_synced_at": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Synced At"
    },
    "full_path_submission": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Full Path Submission"
    }
  },
  "title": "CourseMemberGitLabConfig",
  "type": "object",
  "x-model-name": "CourseMemberGitLabConfig"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CourseMemberGitLabConfig {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CourseMemberGitLabConfig', 'Expected an object');
    }

    // Optional field: settings
    if ('settings' in data && data.settings !== undefined && data.settings !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: url
    if ('url' in data && data.url !== undefined && data.url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: full_path
    if ('full_path' in data && data.full_path !== undefined && data.full_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: directory
    if ('directory' in data && data.directory !== undefined && data.directory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: registry
    if ('registry' in data && data.registry !== undefined && data.registry !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: parent
    if ('parent' in data && data.parent !== undefined && data.parent !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: group_id
    if ('group_id' in data && data.group_id !== undefined && data.group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: parent_id
    if ('parent_id' in data && data.parent_id !== undefined && data.parent_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: namespace_id
    if ('namespace_id' in data && data.namespace_id !== undefined && data.namespace_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: namespace_path
    if ('namespace_path' in data && data.namespace_path !== undefined && data.namespace_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: web_url
    if ('web_url' in data && data.web_url !== undefined && data.web_url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: visibility
    if ('visibility' in data && data.visibility !== undefined && data.visibility !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: last_synced_at
    if ('last_synced_at' in data && data.last_synced_at !== undefined && data.last_synced_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: full_path_submission
    if ('full_path_submission' in data && data.full_path_submission !== undefined && data.full_path_submission !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CourseMemberGitLabConfig', errors.join('; '));
    }

    return data as CourseMemberGitLabConfig;
  }

  safeValidate(data: any): { success: true; data: CourseMemberGitLabConfig } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CourseMemberGitLabConfig', String(error)) };
    }
  }
}

/**
 * Validator for LanguageCreate
 */
export class LanguageCreateValidator extends BaseValidator<LanguageCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "example": {
    "code": "de",
    "name": "German",
    "native_name": "Deutsch"
  },
  "properties": {
    "code": {
      "description": "ISO 639-1 language code (2 lowercase letters)",
      "maxLength": 2,
      "minLength": 2,
      "title": "Code",
      "type": "string"
    },
    "name": {
      "description": "Language name in English",
      "maxLength": 255,
      "minLength": 1,
      "title": "Name",
      "type": "string"
    },
    "native_name": {
      "anyOf": [
        {
          "maxLength": 255,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Language name in native script",
      "title": "Native Name"
    }
  },
  "required": [
    "code",
    "name"
  ],
  "title": "LanguageCreate",
  "type": "object",
  "x-model-name": "LanguageCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LanguageCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LanguageCreate', 'Expected an object');
    }

    // Required field: code
    if (!('code' in data)) {
      errors.push('Missing required field: code');
    } else {
      if (typeof data.code !== 'string') {
        errors.push('Field code must be a string');
      }
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: native_name
    if ('native_name' in data && data.native_name !== undefined && data.native_name !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('LanguageCreate', errors.join('; '));
    }

    return data as LanguageCreate;
  }

  safeValidate(data: any): { success: true; data: LanguageCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LanguageCreate', String(error)) };
    }
  }
}

/**
 * Validator for LanguageGet
 */
export class LanguageGetValidator extends BaseValidator<LanguageGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "code": {
      "description": "ISO 639-1 language code",
      "title": "Code",
      "type": "string"
    },
    "name": {
      "description": "Language name in English",
      "title": "Name",
      "type": "string"
    },
    "native_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Language name in native script",
      "title": "Native Name"
    }
  },
  "required": [
    "code",
    "name"
  ],
  "title": "LanguageGet",
  "type": "object",
  "x-model-name": "LanguageGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LanguageGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LanguageGet', 'Expected an object');
    }

    // Required field: code
    if (!('code' in data)) {
      errors.push('Missing required field: code');
    } else {
      if (typeof data.code !== 'string') {
        errors.push('Field code must be a string');
      }
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: native_name
    if ('native_name' in data && data.native_name !== undefined && data.native_name !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('LanguageGet', errors.join('; '));
    }

    return data as LanguageGet;
  }

  safeValidate(data: any): { success: true; data: LanguageGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LanguageGet', String(error)) };
    }
  }
}

/**
 * Validator for LanguageList
 */
export class LanguageListValidator extends BaseValidator<LanguageList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "code": {
      "description": "ISO 639-1 language code",
      "title": "Code",
      "type": "string"
    },
    "name": {
      "description": "Language name in English",
      "title": "Name",
      "type": "string"
    },
    "native_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Language name in native script",
      "title": "Native Name"
    }
  },
  "required": [
    "code",
    "name"
  ],
  "title": "LanguageList",
  "type": "object",
  "x-model-name": "LanguageList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LanguageList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LanguageList', 'Expected an object');
    }

    // Required field: code
    if (!('code' in data)) {
      errors.push('Missing required field: code');
    } else {
      if (typeof data.code !== 'string') {
        errors.push('Field code must be a string');
      }
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: native_name
    if ('native_name' in data && data.native_name !== undefined && data.native_name !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('LanguageList', errors.join('; '));
    }

    return data as LanguageList;
  }

  safeValidate(data: any): { success: true; data: LanguageList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LanguageList', String(error)) };
    }
  }
}

/**
 * Validator for LanguageUpdate
 */
export class LanguageUpdateValidator extends BaseValidator<LanguageUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "name": {
      "anyOf": [
        {
          "maxLength": 255,
          "minLength": 1,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Language name in English",
      "title": "Name"
    },
    "native_name": {
      "anyOf": [
        {
          "maxLength": 255,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Language name in native script",
      "title": "Native Name"
    }
  },
  "title": "LanguageUpdate",
  "type": "object",
  "x-model-name": "LanguageUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LanguageUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LanguageUpdate', 'Expected an object');
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: native_name
    if ('native_name' in data && data.native_name !== undefined && data.native_name !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('LanguageUpdate', errors.join('; '));
    }

    return data as LanguageUpdate;
  }

  safeValidate(data: any): { success: true; data: LanguageUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LanguageUpdate', String(error)) };
    }
  }
}

/**
 * Validator for LanguageQuery
 */
export class LanguageQueryValidator extends BaseValidator<LanguageQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "code": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by language code",
      "title": "Code"
    },
    "name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by language name",
      "title": "Name"
    },
    "native_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by native language name",
      "title": "Native Name"
    }
  },
  "title": "LanguageQuery",
  "type": "object",
  "x-model-name": "LanguageQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): LanguageQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('LanguageQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: code
    if ('code' in data && data.code !== undefined && data.code !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: name
    if ('name' in data && data.name !== undefined && data.name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: native_name
    if ('native_name' in data && data.native_name !== undefined && data.native_name !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('LanguageQuery', errors.join('; '));
    }

    return data as LanguageQuery;
  }

  safeValidate(data: any): { success: true; data: LanguageQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('LanguageQuery', String(error)) };
    }
  }
}

/**
 * Metadata stored with deployments.
 */
export class DeploymentMetadataValidator extends BaseValidator<DeploymentMetadata> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "additionalProperties": true,
  "description": "Metadata stored with deployments.",
  "properties": {
    "workflow_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Temporal workflow ID",
      "title": "Workflow Id"
    },
    "files_deployed": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "List of files deployed",
      "title": "Files Deployed"
    },
    "git_commit": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Git commit hash",
      "title": "Git Commit"
    },
    "error_details": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Error details if deployment failed",
      "title": "Error Details"
    },
    "migrated_properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Properties migrated from old schema",
      "title": "Migrated Properties"
    }
  },
  "title": "DeploymentMetadata",
  "type": "object",
  "x-model-name": "DeploymentMetadata"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): DeploymentMetadata {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('DeploymentMetadata', 'Expected an object');
    }

    // Optional field: workflow_id
    if ('workflow_id' in data && data.workflow_id !== undefined && data.workflow_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: files_deployed
    if ('files_deployed' in data && data.files_deployed !== undefined && data.files_deployed !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: git_commit
    if ('git_commit' in data && data.git_commit !== undefined && data.git_commit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: error_details
    if ('error_details' in data && data.error_details !== undefined && data.error_details !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: migrated_properties
    if ('migrated_properties' in data && data.migrated_properties !== undefined && data.migrated_properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('DeploymentMetadata', errors.join('; '));
    }

    return data as DeploymentMetadata;
  }

  safeValidate(data: any): { success: true; data: DeploymentMetadata } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('DeploymentMetadata', String(error)) };
    }
  }
}

/**
 * Create a new deployment (typically done automatically).
 */
export class CourseContentDeploymentCreateValidator extends BaseValidator<CourseContentDeploymentCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "DeploymentMetadata": {
      "additionalProperties": true,
      "description": "Metadata stored with deployments.",
      "properties": {
        "workflow_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Temporal workflow ID",
          "title": "Workflow Id"
        },
        "files_deployed": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "List of files deployed",
          "title": "Files Deployed"
        },
        "git_commit": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Git commit hash",
          "title": "Git Commit"
        },
        "error_details": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Error details if deployment failed",
          "title": "Error Details"
        },
        "migrated_properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Properties migrated from old schema",
          "title": "Migrated Properties"
        }
      },
      "title": "DeploymentMetadata",
      "type": "object"
    }
  },
  "description": "Create a new deployment (typically done automatically).",
  "properties": {
    "course_content_id": {
      "description": "Course content to deploy to",
      "title": "Course Content Id",
      "type": "string"
    },
    "example_version_id": {
      "description": "Example version to deploy",
      "title": "Example Version Id",
      "type": "string"
    },
    "deployment_status": {
      "default": "pending",
      "description": "Initial deployment status",
      "enum": [
        "pending",
        "deploying",
        "deployed",
        "failed",
        "unassigned"
      ],
      "title": "Deployment Status",
      "type": "string"
    },
    "deployment_message": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Optional message",
      "title": "Deployment Message"
    },
    "deployment_metadata": {
      "anyOf": [
        {
          "$ref": "#/$defs/DeploymentMetadata"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional metadata"
    }
  },
  "required": [
    "course_content_id",
    "example_version_id"
  ],
  "title": "CourseContentDeploymentCreate",
  "type": "object",
  "x-model-name": "CourseContentDeploymentCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CourseContentDeploymentCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CourseContentDeploymentCreate', 'Expected an object');
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: example_version_id
    if (!('example_version_id' in data)) {
      errors.push('Missing required field: example_version_id');
    } else {
      if (typeof data.example_version_id !== 'string') {
        errors.push('Field example_version_id must be a string');
      }
    }

    // Optional field: deployment_status
    if ('deployment_status' in data && data.deployment_status !== undefined && data.deployment_status !== null) {
      if (typeof data.deployment_status !== 'string') {
        errors.push('Field deployment_status must be a string');
      }
    }

    // Optional field: deployment_message
    if ('deployment_message' in data && data.deployment_message !== undefined && data.deployment_message !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: deployment_metadata
    if ('deployment_metadata' in data && data.deployment_metadata !== undefined && data.deployment_metadata !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CourseContentDeploymentCreate', errors.join('; '));
    }

    return data as CourseContentDeploymentCreate;
  }

  safeValidate(data: any): { success: true; data: CourseContentDeploymentCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CourseContentDeploymentCreate', String(error)) };
    }
  }
}

/**
 * Update deployment status.
 */
export class CourseContentDeploymentUpdateValidator extends BaseValidator<CourseContentDeploymentUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "DeploymentMetadata": {
      "additionalProperties": true,
      "description": "Metadata stored with deployments.",
      "properties": {
        "workflow_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Temporal workflow ID",
          "title": "Workflow Id"
        },
        "files_deployed": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "List of files deployed",
          "title": "Files Deployed"
        },
        "git_commit": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Git commit hash",
          "title": "Git Commit"
        },
        "error_details": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Error details if deployment failed",
          "title": "Error Details"
        },
        "migrated_properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Properties migrated from old schema",
          "title": "Migrated Properties"
        }
      },
      "title": "DeploymentMetadata",
      "type": "object"
    }
  },
  "description": "Update deployment status.",
  "properties": {
    "deployment_status": {
      "anyOf": [
        {
          "enum": [
            "pending",
            "deploying",
            "deployed",
            "failed",
            "unassigned"
          ],
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployment Status"
    },
    "deployment_message": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployment Message"
    },
    "deployed_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployed At"
    },
    "last_attempt_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Attempt At"
    },
    "deployment_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployment Path"
    },
    "deployment_metadata": {
      "anyOf": [
        {
          "$ref": "#/$defs/DeploymentMetadata"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "example_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Identifier"
    },
    "version_tag": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Tag"
    }
  },
  "title": "CourseContentDeploymentUpdate",
  "type": "object",
  "x-model-name": "CourseContentDeploymentUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CourseContentDeploymentUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CourseContentDeploymentUpdate', 'Expected an object');
    }

    // Optional field: deployment_status
    if ('deployment_status' in data && data.deployment_status !== undefined && data.deployment_status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: deployment_message
    if ('deployment_message' in data && data.deployment_message !== undefined && data.deployment_message !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: deployed_at
    if ('deployed_at' in data && data.deployed_at !== undefined && data.deployed_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: last_attempt_at
    if ('last_attempt_at' in data && data.last_attempt_at !== undefined && data.last_attempt_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: deployment_path
    if ('deployment_path' in data && data.deployment_path !== undefined && data.deployment_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: deployment_metadata
    if ('deployment_metadata' in data && data.deployment_metadata !== undefined && data.deployment_metadata !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_identifier
    if ('example_identifier' in data && data.example_identifier !== undefined && data.example_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version_tag
    if ('version_tag' in data && data.version_tag !== undefined && data.version_tag !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CourseContentDeploymentUpdate', errors.join('; '));
    }

    return data as CourseContentDeploymentUpdate;
  }

  safeValidate(data: any): { success: true; data: CourseContentDeploymentUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CourseContentDeploymentUpdate', String(error)) };
    }
  }
}

/**
 * List view of deployments.
 */
export class CourseContentDeploymentListValidator extends BaseValidator<CourseContentDeploymentList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ExampleVersionList": {
      "description": "List view of example versions.",
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "version_tag": {
          "title": "Version Tag",
          "type": "string"
        },
        "version_number": {
          "title": "Version Number",
          "type": "integer"
        },
        "created_at": {
          "format": "date-time",
          "title": "Created At",
          "type": "string"
        }
      },
      "required": [
        "id",
        "version_tag",
        "version_number",
        "created_at"
      ],
      "title": "ExampleVersionList",
      "type": "object"
    }
  },
  "description": "List view of deployments.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "example_version_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "title": "Example Version Id"
    },
    "example_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Identifier"
    },
    "version_tag": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Tag"
    },
    "deployment_status": {
      "title": "Deployment Status",
      "type": "string"
    },
    "assigned_at": {
      "format": "date-time",
      "title": "Assigned At",
      "type": "string"
    },
    "deployed_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "title": "Deployed At"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "title": "Version Identifier"
    },
    "example_version": {
      "anyOf": [
        {
          "$ref": "#/$defs/ExampleVersionList"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "id",
    "course_content_id",
    "example_version_id",
    "deployment_status",
    "assigned_at",
    "deployed_at",
    "version_identifier"
  ],
  "title": "CourseContentDeploymentList",
  "type": "object",
  "x-model-name": "CourseContentDeploymentList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CourseContentDeploymentList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CourseContentDeploymentList', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: example_version_id
    if (!('example_version_id' in data)) {
      errors.push('Missing required field: example_version_id');
    } else {
      // Union type - skipping detailed validation
    }

    // Optional field: example_identifier
    if ('example_identifier' in data && data.example_identifier !== undefined && data.example_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version_tag
    if ('version_tag' in data && data.version_tag !== undefined && data.version_tag !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: deployment_status
    if (!('deployment_status' in data)) {
      errors.push('Missing required field: deployment_status');
    } else {
      if (typeof data.deployment_status !== 'string') {
        errors.push('Field deployment_status must be a string');
      }
    }

    // Required field: assigned_at
    if (!('assigned_at' in data)) {
      errors.push('Missing required field: assigned_at');
    } else {
      if (typeof data.assigned_at !== 'string') {
        errors.push('Field assigned_at must be a string');
      }
    }

    // Required field: deployed_at
    if (!('deployed_at' in data)) {
      errors.push('Missing required field: deployed_at');
    } else {
      // Union type - skipping detailed validation
    }

    // Required field: version_identifier
    if (!('version_identifier' in data)) {
      errors.push('Missing required field: version_identifier');
    } else {
      // Union type - skipping detailed validation
    }

    // Optional field: example_version
    if ('example_version' in data && data.example_version !== undefined && data.example_version !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CourseContentDeploymentList', errors.join('; '));
    }

    return data as CourseContentDeploymentList;
  }

  safeValidate(data: any): { success: true; data: CourseContentDeploymentList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CourseContentDeploymentList', String(error)) };
    }
  }
}

/**
 * Query parameters for deployments.
 */
export class CourseContentDeploymentQueryValidator extends BaseValidator<CourseContentDeploymentQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Query parameters for deployments.",
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "course_content_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Id"
    },
    "example_version_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Version Id"
    },
    "deployment_status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployment Status"
    },
    "deployed": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployed"
    },
    "failed": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Failed"
    }
  },
  "title": "CourseContentDeploymentQuery",
  "type": "object",
  "x-model-name": "CourseContentDeploymentQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): CourseContentDeploymentQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('CourseContentDeploymentQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_id
    if ('course_content_id' in data && data.course_content_id !== undefined && data.course_content_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_version_id
    if ('example_version_id' in data && data.example_version_id !== undefined && data.example_version_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: deployment_status
    if ('deployment_status' in data && data.deployment_status !== undefined && data.deployment_status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: deployed
    if ('deployed' in data && data.deployed !== undefined && data.deployed !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: failed
    if ('failed' in data && data.failed !== undefined && data.failed !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('CourseContentDeploymentQuery', errors.join('; '));
    }

    return data as CourseContentDeploymentQuery;
  }

  safeValidate(data: any): { success: true; data: CourseContentDeploymentQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('CourseContentDeploymentQuery', String(error)) };
    }
  }
}

/**
 * Create a deployment history entry.
 */
export class DeploymentHistoryCreateValidator extends BaseValidator<DeploymentHistoryCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Create a deployment history entry.",
  "properties": {
    "deployment_id": {
      "title": "Deployment Id",
      "type": "string"
    },
    "action": {
      "enum": [
        "assigned",
        "reassigned",
        "deploying",
        "deployed",
        "failed",
        "unassigned",
        "updated",
        "migrated"
      ],
      "title": "Action",
      "type": "string"
    },
    "example_version_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Version Id"
    },
    "example_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Identifier"
    },
    "version_tag": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Tag"
    },
    "previous_example_version_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Previous Example Version Id"
    },
    "workflow_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Workflow Id"
    }
  },
  "required": [
    "deployment_id",
    "action"
  ],
  "title": "DeploymentHistoryCreate",
  "type": "object",
  "x-model-name": "DeploymentHistoryCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): DeploymentHistoryCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('DeploymentHistoryCreate', 'Expected an object');
    }

    // Required field: deployment_id
    if (!('deployment_id' in data)) {
      errors.push('Missing required field: deployment_id');
    } else {
      if (typeof data.deployment_id !== 'string') {
        errors.push('Field deployment_id must be a string');
      }
    }

    // Required field: action
    if (!('action' in data)) {
      errors.push('Missing required field: action');
    } else {
      if (typeof data.action !== 'string') {
        errors.push('Field action must be a string');
      }
    }

    // Optional field: example_version_id
    if ('example_version_id' in data && data.example_version_id !== undefined && data.example_version_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_identifier
    if ('example_identifier' in data && data.example_identifier !== undefined && data.example_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version_tag
    if ('version_tag' in data && data.version_tag !== undefined && data.version_tag !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: previous_example_version_id
    if ('previous_example_version_id' in data && data.previous_example_version_id !== undefined && data.previous_example_version_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: workflow_id
    if ('workflow_id' in data && data.workflow_id !== undefined && data.workflow_id !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('DeploymentHistoryCreate', errors.join('; '));
    }

    return data as DeploymentHistoryCreate;
  }

  safeValidate(data: any): { success: true; data: DeploymentHistoryCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('DeploymentHistoryCreate', String(error)) };
    }
  }
}

/**
 * List view of deployment history.
 */
export class DeploymentHistoryListValidator extends BaseValidator<DeploymentHistoryList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "List view of deployment history.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "deployment_id": {
      "title": "Deployment Id",
      "type": "string"
    },
    "action": {
      "title": "Action",
      "type": "string"
    },
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "workflow_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "title": "Workflow Id"
    }
  },
  "required": [
    "id",
    "deployment_id",
    "action",
    "created_at",
    "workflow_id"
  ],
  "title": "DeploymentHistoryList",
  "type": "object",
  "x-model-name": "DeploymentHistoryList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): DeploymentHistoryList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('DeploymentHistoryList', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: deployment_id
    if (!('deployment_id' in data)) {
      errors.push('Missing required field: deployment_id');
    } else {
      if (typeof data.deployment_id !== 'string') {
        errors.push('Field deployment_id must be a string');
      }
    }

    // Required field: action
    if (!('action' in data)) {
      errors.push('Missing required field: action');
    } else {
      if (typeof data.action !== 'string') {
        errors.push('Field action must be a string');
      }
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: workflow_id
    if (!('workflow_id' in data)) {
      errors.push('Missing required field: workflow_id');
    } else {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('DeploymentHistoryList', errors.join('; '));
    }

    return data as DeploymentHistoryList;
  }

  safeValidate(data: any): { success: true; data: DeploymentHistoryList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('DeploymentHistoryList', String(error)) };
    }
  }
}

/**
 * Summary of deployments for a course.
 */
export class DeploymentSummaryValidator extends BaseValidator<DeploymentSummary> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Summary of deployments for a course.",
  "properties": {
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "total_content": {
      "description": "Total course content items",
      "title": "Total Content",
      "type": "integer"
    },
    "submittable_content": {
      "description": "Total submittable content (assignments)",
      "title": "Submittable Content",
      "type": "integer"
    },
    "deployments_total": {
      "description": "Total deployments",
      "title": "Deployments Total",
      "type": "integer"
    },
    "deployments_pending": {
      "description": "Deployments pending",
      "title": "Deployments Pending",
      "type": "integer"
    },
    "deployments_deployed": {
      "description": "Successfully deployed",
      "title": "Deployments Deployed",
      "type": "integer"
    },
    "deployments_failed": {
      "description": "Failed deployments",
      "title": "Deployments Failed",
      "type": "integer"
    },
    "last_deployment_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Most recent deployment",
      "title": "Last Deployment At"
    }
  },
  "required": [
    "course_id",
    "total_content",
    "submittable_content",
    "deployments_total",
    "deployments_pending",
    "deployments_deployed",
    "deployments_failed"
  ],
  "title": "DeploymentSummary",
  "type": "object",
  "x-model-name": "DeploymentSummary"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): DeploymentSummary {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('DeploymentSummary', 'Expected an object');
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: total_content
    if (!('total_content' in data)) {
      errors.push('Missing required field: total_content');
    } else {
      if (typeof data.total_content !== 'number') {
        errors.push('Field total_content must be a number');
      }
    }

    // Required field: submittable_content
    if (!('submittable_content' in data)) {
      errors.push('Missing required field: submittable_content');
    } else {
      if (typeof data.submittable_content !== 'number') {
        errors.push('Field submittable_content must be a number');
      }
    }

    // Required field: deployments_total
    if (!('deployments_total' in data)) {
      errors.push('Missing required field: deployments_total');
    } else {
      if (typeof data.deployments_total !== 'number') {
        errors.push('Field deployments_total must be a number');
      }
    }

    // Required field: deployments_pending
    if (!('deployments_pending' in data)) {
      errors.push('Missing required field: deployments_pending');
    } else {
      if (typeof data.deployments_pending !== 'number') {
        errors.push('Field deployments_pending must be a number');
      }
    }

    // Required field: deployments_deployed
    if (!('deployments_deployed' in data)) {
      errors.push('Missing required field: deployments_deployed');
    } else {
      if (typeof data.deployments_deployed !== 'number') {
        errors.push('Field deployments_deployed must be a number');
      }
    }

    // Required field: deployments_failed
    if (!('deployments_failed' in data)) {
      errors.push('Missing required field: deployments_failed');
    } else {
      if (typeof data.deployments_failed !== 'number') {
        errors.push('Field deployments_failed must be a number');
      }
    }

    // Optional field: last_deployment_at
    if ('last_deployment_at' in data && data.last_deployment_at !== undefined && data.last_deployment_at !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('DeploymentSummary', errors.join('; '));
    }

    return data as DeploymentSummary;
  }

  safeValidate(data: any): { success: true; data: DeploymentSummary } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('DeploymentSummary', String(error)) };
    }
  }
}

/**
 * DTO for creating a student.
 */
export class StudentCreateValidator extends BaseValidator<StudentCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfigGet": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        }
      },
      "title": "GitLabConfigGet",
      "type": "object"
    },
    "OrganizationGet": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "description": "Organization unique identifier",
          "title": "Id",
          "type": "string"
        },
        "path": {
          "description": "Hierarchical path",
          "title": "Path",
          "type": "string"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization title",
          "title": "Title"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization description",
          "title": "Description"
        },
        "organization_type": {
          "$ref": "#/$defs/OrganizationType",
          "description": "Type of organization"
        },
        "user_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Associated user ID",
          "title": "User Id"
        },
        "properties": {
          "anyOf": [
            {
              "$ref": "#/$defs/OrganizationPropertiesGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Additional properties"
        },
        "number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization number",
          "title": "Number"
        },
        "email": {
          "anyOf": [
            {
              "format": "email",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Contact email",
          "title": "Email"
        },
        "telephone": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Phone number",
          "title": "Telephone"
        },
        "fax_number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Fax number",
          "title": "Fax Number"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Website URL",
          "title": "Url"
        },
        "postal_code": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Postal code",
          "title": "Postal Code"
        },
        "street_address": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Street address",
          "title": "Street Address"
        },
        "locality": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "City/locality",
          "title": "Locality"
        },
        "region": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "State/region",
          "title": "Region"
        },
        "country": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Country",
          "title": "Country"
        }
      },
      "required": [
        "id",
        "path",
        "organization_type"
      ],
      "title": "OrganizationGet",
      "type": "object"
    },
    "OrganizationPropertiesGet": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfigGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "OrganizationPropertiesGet",
      "type": "object"
    },
    "OrganizationType": {
      "enum": [
        "user",
        "community",
        "organization"
      ],
      "title": "OrganizationType",
      "type": "string"
    },
    "ProfileGet": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "description": "Profile unique identifier",
          "title": "Id",
          "type": "string"
        },
        "user_id": {
          "description": "Associated user ID",
          "title": "User Id",
          "type": "string"
        },
        "avatar_color": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Avatar color as RGB integer",
          "title": "Avatar Color"
        },
        "avatar_image": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Avatar image URL",
          "title": "Avatar Image"
        },
        "nickname": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Unique nickname",
          "title": "Nickname"
        },
        "bio": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User biography",
          "title": "Bio"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User website URL",
          "title": "Url"
        },
        "language_code": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ISO 639-1 language code",
          "title": "Language Code"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Additional properties",
          "title": "Properties"
        }
      },
      "required": [
        "id",
        "user_id"
      ],
      "title": "ProfileGet",
      "type": "object"
    },
    "StudentProfileGet": {
      "properties": {
        "student_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Student Id"
        },
        "student_email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Student Email"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "organization_id": {
          "title": "Organization Id",
          "type": "string"
        },
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "title": "Id",
          "type": "string"
        },
        "organization": {
          "anyOf": [
            {
              "$ref": "#/$defs/OrganizationGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "user_id",
        "organization_id",
        "id"
      ],
      "title": "StudentProfileGet",
      "type": "object"
    },
    "UserGet": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "description": "User unique identifier",
          "title": "Id",
          "type": "string"
        },
        "given_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's family name",
          "title": "Family Name"
        },
        "email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's email address",
          "title": "Email"
        },
        "number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User number/identifier",
          "title": "Number"
        },
        "user_type": {
          "anyOf": [
            {
              "$ref": "#/$defs/UserTypeEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Type of user account"
        },
        "username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Unique username",
          "title": "Username"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Additional user properties",
          "title": "Properties"
        },
        "archived_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Timestamp when user was archived",
          "title": "Archived At"
        },
        "student_profiles": {
          "default": [],
          "description": "Associated student profiles",
          "items": {
            "$ref": "#/$defs/StudentProfileGet"
          },
          "title": "Student Profiles",
          "type": "array"
        },
        "profile": {
          "anyOf": [
            {
              "$ref": "#/$defs/ProfileGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User profile"
        }
      },
      "required": [
        "id"
      ],
      "title": "UserGet",
      "type": "object"
    },
    "UserTypeEnum": {
      "enum": [
        "user",
        "token"
      ],
      "title": "UserTypeEnum",
      "type": "string"
    }
  },
  "description": "DTO for creating a student.",
  "properties": {
    "user_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "User Id"
    },
    "user": {
      "anyOf": [
        {
          "$ref": "#/$defs/UserGet"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "course_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Group Id"
    },
    "course_group_title": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Group Title"
    },
    "role": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Role"
    }
  },
  "title": "StudentCreate",
  "type": "object",
  "x-model-name": "StudentCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StudentCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StudentCreate', 'Expected an object');
    }

    // Optional field: user_id
    if ('user_id' in data && data.user_id !== undefined && data.user_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: user
    if ('user' in data && data.user !== undefined && data.user !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_group_id
    if ('course_group_id' in data && data.course_group_id !== undefined && data.course_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_group_title
    if ('course_group_title' in data && data.course_group_title !== undefined && data.course_group_title !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: role
    if ('role' in data && data.role !== undefined && data.role !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StudentCreate', errors.join('; '));
    }

    return data as StudentCreate;
  }

  safeValidate(data: any): { success: true; data: StudentCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StudentCreate', String(error)) };
    }
  }
}

/**
 * DTO for releasing multiple students.
 */
export class ReleaseStudentsCreateValidator extends BaseValidator<ReleaseStudentsCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfigGet": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        }
      },
      "title": "GitLabConfigGet",
      "type": "object"
    },
    "OrganizationGet": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "description": "Organization unique identifier",
          "title": "Id",
          "type": "string"
        },
        "path": {
          "description": "Hierarchical path",
          "title": "Path",
          "type": "string"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization title",
          "title": "Title"
        },
        "description": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization description",
          "title": "Description"
        },
        "organization_type": {
          "$ref": "#/$defs/OrganizationType",
          "description": "Type of organization"
        },
        "user_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Associated user ID",
          "title": "User Id"
        },
        "properties": {
          "anyOf": [
            {
              "$ref": "#/$defs/OrganizationPropertiesGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Additional properties"
        },
        "number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Organization number",
          "title": "Number"
        },
        "email": {
          "anyOf": [
            {
              "format": "email",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Contact email",
          "title": "Email"
        },
        "telephone": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Phone number",
          "title": "Telephone"
        },
        "fax_number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Fax number",
          "title": "Fax Number"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Website URL",
          "title": "Url"
        },
        "postal_code": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Postal code",
          "title": "Postal Code"
        },
        "street_address": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Street address",
          "title": "Street Address"
        },
        "locality": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "City/locality",
          "title": "Locality"
        },
        "region": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "State/region",
          "title": "Region"
        },
        "country": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Country",
          "title": "Country"
        }
      },
      "required": [
        "id",
        "path",
        "organization_type"
      ],
      "title": "OrganizationGet",
      "type": "object"
    },
    "OrganizationPropertiesGet": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfigGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "OrganizationPropertiesGet",
      "type": "object"
    },
    "OrganizationType": {
      "enum": [
        "user",
        "community",
        "organization"
      ],
      "title": "OrganizationType",
      "type": "string"
    },
    "ProfileGet": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "description": "Profile unique identifier",
          "title": "Id",
          "type": "string"
        },
        "user_id": {
          "description": "Associated user ID",
          "title": "User Id",
          "type": "string"
        },
        "avatar_color": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Avatar color as RGB integer",
          "title": "Avatar Color"
        },
        "avatar_image": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Avatar image URL",
          "title": "Avatar Image"
        },
        "nickname": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Unique nickname",
          "title": "Nickname"
        },
        "bio": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User biography",
          "title": "Bio"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User website URL",
          "title": "Url"
        },
        "language_code": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "ISO 639-1 language code",
          "title": "Language Code"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Additional properties",
          "title": "Properties"
        }
      },
      "required": [
        "id",
        "user_id"
      ],
      "title": "ProfileGet",
      "type": "object"
    },
    "StudentCreate": {
      "description": "DTO for creating a student.",
      "properties": {
        "user_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "User Id"
        },
        "user": {
          "anyOf": [
            {
              "$ref": "#/$defs/UserGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "course_group_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Course Group Id"
        },
        "course_group_title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Course Group Title"
        },
        "role": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Role"
        }
      },
      "title": "StudentCreate",
      "type": "object"
    },
    "StudentProfileGet": {
      "properties": {
        "student_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Student Id"
        },
        "student_email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Student Email"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "organization_id": {
          "title": "Organization Id",
          "type": "string"
        },
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "title": "Id",
          "type": "string"
        },
        "organization": {
          "anyOf": [
            {
              "$ref": "#/$defs/OrganizationGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "user_id",
        "organization_id",
        "id"
      ],
      "title": "StudentProfileGet",
      "type": "object"
    },
    "UserGet": {
      "properties": {
        "created_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Creation timestamp",
          "title": "Created At"
        },
        "updated_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Update timestamp",
          "title": "Updated At"
        },
        "created_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Created By"
        },
        "updated_by": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Updated By"
        },
        "id": {
          "description": "User unique identifier",
          "title": "Id",
          "type": "string"
        },
        "given_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's family name",
          "title": "Family Name"
        },
        "email": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User's email address",
          "title": "Email"
        },
        "number": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User number/identifier",
          "title": "Number"
        },
        "user_type": {
          "anyOf": [
            {
              "$ref": "#/$defs/UserTypeEnum"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Type of user account"
        },
        "username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Unique username",
          "title": "Username"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Additional user properties",
          "title": "Properties"
        },
        "archived_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Timestamp when user was archived",
          "title": "Archived At"
        },
        "student_profiles": {
          "default": [],
          "description": "Associated student profiles",
          "items": {
            "$ref": "#/$defs/StudentProfileGet"
          },
          "title": "Student Profiles",
          "type": "array"
        },
        "profile": {
          "anyOf": [
            {
              "$ref": "#/$defs/ProfileGet"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "User profile"
        }
      },
      "required": [
        "id"
      ],
      "title": "UserGet",
      "type": "object"
    },
    "UserTypeEnum": {
      "enum": [
        "user",
        "token"
      ],
      "title": "UserTypeEnum",
      "type": "string"
    }
  },
  "description": "DTO for releasing multiple students.",
  "properties": {
    "students": {
      "default": [],
      "items": {
        "$ref": "#/$defs/StudentCreate"
      },
      "title": "Students",
      "type": "array"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    }
  },
  "required": [
    "course_id"
  ],
  "title": "ReleaseStudentsCreate",
  "type": "object",
  "x-model-name": "ReleaseStudentsCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ReleaseStudentsCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ReleaseStudentsCreate', 'Expected an object');
    }

    // Optional field: students
    if ('students' in data && data.students !== undefined && data.students !== null) {
      if (!Array.isArray(data.students)) {
        errors.push('Field students must be an array');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ReleaseStudentsCreate', errors.join('; '));
    }

    return data as ReleaseStudentsCreate;
  }

  safeValidate(data: any): { success: true; data: ReleaseStudentsCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ReleaseStudentsCreate', String(error)) };
    }
  }
}

/**
 * DTO for TUG student export data.
 */
export class TUGStudentExportValidator extends BaseValidator<TUGStudentExport> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for TUG student export data.",
  "properties": {
    "course_group_title": {
      "title": "Course Group Title",
      "type": "string"
    },
    "family_name": {
      "title": "Family Name",
      "type": "string"
    },
    "given_name": {
      "title": "Given Name",
      "type": "string"
    },
    "matriculation_number": {
      "title": "Matriculation Number",
      "type": "string"
    },
    "created_at": {
      "title": "Created At",
      "type": "string"
    }
  },
  "required": [
    "course_group_title",
    "family_name",
    "given_name",
    "matriculation_number",
    "created_at"
  ],
  "title": "TUGStudentExport",
  "type": "object",
  "x-model-name": "TUGStudentExport"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TUGStudentExport {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TUGStudentExport', 'Expected an object');
    }

    // Required field: course_group_title
    if (!('course_group_title' in data)) {
      errors.push('Missing required field: course_group_title');
    } else {
      if (typeof data.course_group_title !== 'string') {
        errors.push('Field course_group_title must be a string');
      }
    }

    // Required field: family_name
    if (!('family_name' in data)) {
      errors.push('Missing required field: family_name');
    } else {
      if (typeof data.family_name !== 'string') {
        errors.push('Field family_name must be a string');
      }
    }

    // Required field: given_name
    if (!('given_name' in data)) {
      errors.push('Missing required field: given_name');
    } else {
      if (typeof data.given_name !== 'string') {
        errors.push('Field given_name must be a string');
      }
    }

    // Required field: matriculation_number
    if (!('matriculation_number' in data)) {
      errors.push('Missing required field: matriculation_number');
    } else {
      if (typeof data.matriculation_number !== 'string') {
        errors.push('Field matriculation_number must be a string');
      }
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('TUGStudentExport', errors.join('; '));
    }

    return data as TUGStudentExport;
  }

  safeValidate(data: any): { success: true; data: TUGStudentExport } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TUGStudentExport', String(error)) };
    }
  }
}

/**
 * DTO for status query parameters.
 */
export class StatusQueryValidator extends BaseValidator<StatusQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "DTO for status query parameters.",
  "properties": {
    "course_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Id"
    }
  },
  "title": "StatusQuery",
  "type": "object",
  "x-model-name": "StatusQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): StatusQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('StatusQuery', 'Expected an object');
    }

    // Optional field: course_id
    if ('course_id' in data && data.course_id !== undefined && data.course_id !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('StatusQuery', errors.join('; '));
    }

    return data as StatusQuery;
  }

  safeValidate(data: any): { success: true; data: StatusQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('StatusQuery', String(error)) };
    }
  }
}

/**
 * GitLab connection credentials.
 */
export class GitLabCredentialsValidator extends BaseValidator<GitLabCredentials> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "GitLab connection credentials.",
  "properties": {
    "gitlab_url": {
      "title": "Gitlab Url",
      "type": "string"
    },
    "gitlab_token": {
      "title": "Gitlab Token",
      "type": "string"
    }
  },
  "required": [
    "gitlab_url",
    "gitlab_token"
  ],
  "title": "GitLabCredentials",
  "type": "object",
  "x-model-name": "GitLabCredentials"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GitLabCredentials {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GitLabCredentials', 'Expected an object');
    }

    // Required field: gitlab_url
    if (!('gitlab_url' in data)) {
      errors.push('Missing required field: gitlab_url');
    } else {
      if (typeof data.gitlab_url !== 'string') {
        errors.push('Field gitlab_url must be a string');
      }
    }

    // Required field: gitlab_token
    if (!('gitlab_token' in data)) {
      errors.push('Missing required field: gitlab_token');
    } else {
      if (typeof data.gitlab_token !== 'string') {
        errors.push('Field gitlab_token must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('GitLabCredentials', errors.join('; '));
    }

    return data as GitLabCredentials;
  }

  safeValidate(data: any): { success: true; data: GitLabCredentials } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GitLabCredentials', String(error)) };
    }
  }
}

/**
 * Represents a pending change for template generation.
 */
export class PendingChangeValidator extends BaseValidator<PendingChange> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Represents a pending change for template generation.",
  "properties": {
    "type": {
      "description": "new, update, remove",
      "title": "Type",
      "type": "string"
    },
    "content_id": {
      "title": "Content Id",
      "type": "string"
    },
    "path": {
      "title": "Path",
      "type": "string"
    },
    "title": {
      "title": "Title",
      "type": "string"
    }
  },
  "required": [
    "type",
    "content_id",
    "path",
    "title"
  ],
  "title": "PendingChange",
  "type": "object",
  "x-model-name": "PendingChange"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): PendingChange {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('PendingChange', 'Expected an object');
    }

    // Required field: type
    if (!('type' in data)) {
      errors.push('Missing required field: type');
    } else {
      if (typeof data.type !== 'string') {
        errors.push('Field type must be a string');
      }
    }

    // Required field: content_id
    if (!('content_id' in data)) {
      errors.push('Missing required field: content_id');
    } else {
      if (typeof data.content_id !== 'string') {
        errors.push('Field content_id must be a string');
      }
    }

    // Required field: path
    if (!('path' in data)) {
      errors.push('Missing required field: path');
    } else {
      if (typeof data.path !== 'string') {
        errors.push('Field path must be a string');
      }
    }

    // Required field: title
    if (!('title' in data)) {
      errors.push('Missing required field: title');
    } else {
      if (typeof data.title !== 'string') {
        errors.push('Field title must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('PendingChange', errors.join('; '));
    }

    return data as PendingChange;
  }

  safeValidate(data: any): { success: true; data: PendingChange } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('PendingChange', String(error)) };
    }
  }
}

/**
 * Response for pending changes check.
 */
export class PendingChangesResponseValidator extends BaseValidator<PendingChangesResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "PendingChange": {
      "description": "Represents a pending change for template generation.",
      "properties": {
        "type": {
          "description": "new, update, remove",
          "title": "Type",
          "type": "string"
        },
        "content_id": {
          "title": "Content Id",
          "type": "string"
        },
        "path": {
          "title": "Path",
          "type": "string"
        },
        "title": {
          "title": "Title",
          "type": "string"
        }
      },
      "required": [
        "type",
        "content_id",
        "path",
        "title"
      ],
      "title": "PendingChange",
      "type": "object"
    }
  },
  "description": "Response for pending changes check.",
  "properties": {
    "total_changes": {
      "title": "Total Changes",
      "type": "integer"
    },
    "changes": {
      "items": {
        "$ref": "#/$defs/PendingChange"
      },
      "title": "Changes",
      "type": "array"
    },
    "last_release": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Last Release"
    }
  },
  "required": [
    "total_changes",
    "changes"
  ],
  "title": "PendingChangesResponse",
  "type": "object",
  "x-model-name": "PendingChangesResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): PendingChangesResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('PendingChangesResponse', 'Expected an object');
    }

    // Required field: total_changes
    if (!('total_changes' in data)) {
      errors.push('Missing required field: total_changes');
    } else {
      if (typeof data.total_changes !== 'number') {
        errors.push('Field total_changes must be a number');
      }
    }

    // Required field: changes
    if (!('changes' in data)) {
      errors.push('Missing required field: changes');
    } else {
      if (!Array.isArray(data.changes)) {
        errors.push('Field changes must be an array');
      }
    }

    // Optional field: last_release
    if ('last_release' in data && data.last_release !== undefined && data.last_release !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('PendingChangesResponse', errors.join('; '));
    }

    return data as PendingChangesResponse;
  }

  safeValidate(data: any): { success: true; data: PendingChangesResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('PendingChangesResponse', String(error)) };
    }
  }
}

/**
 * Per-item override for release commit selection.
 */
export class ReleaseOverrideValidator extends BaseValidator<ReleaseOverride> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Per-item override for release commit selection.",
  "properties": {
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "version_identifier": {
      "description": "Commit SHA to use for this content",
      "title": "Version Identifier",
      "type": "string"
    }
  },
  "required": [
    "course_content_id",
    "version_identifier"
  ],
  "title": "ReleaseOverride",
  "type": "object",
  "x-model-name": "ReleaseOverride"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ReleaseOverride {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ReleaseOverride', 'Expected an object');
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: version_identifier
    if (!('version_identifier' in data)) {
      errors.push('Missing required field: version_identifier');
    } else {
      if (typeof data.version_identifier !== 'string') {
        errors.push('Field version_identifier must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ReleaseOverride', errors.join('; '));
    }

    return data as ReleaseOverride;
  }

  safeValidate(data: any): { success: true; data: ReleaseOverride } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ReleaseOverride', String(error)) };
    }
  }
}

/**
 * Selection of contents and commits for a release.
 */
export class ReleaseSelectionValidator extends BaseValidator<ReleaseSelection> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ReleaseOverride": {
      "description": "Per-item override for release commit selection.",
      "properties": {
        "course_content_id": {
          "title": "Course Content Id",
          "type": "string"
        },
        "version_identifier": {
          "description": "Commit SHA to use for this content",
          "title": "Version Identifier",
          "type": "string"
        }
      },
      "required": [
        "course_content_id",
        "version_identifier"
      ],
      "title": "ReleaseOverride",
      "type": "object"
    }
  },
  "description": "Selection of contents and commits for a release.",
  "properties": {
    "course_content_ids": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Explicit list of course content IDs to release",
      "title": "Course Content Ids"
    },
    "parent_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Parent content ID; combined with include_descendants",
      "title": "Parent Id"
    },
    "include_descendants": {
      "default": true,
      "description": "Whether to include descendants of parent_id",
      "title": "Include Descendants",
      "type": "boolean"
    },
    "all": {
      "default": false,
      "description": "Select all contents in the course",
      "title": "All",
      "type": "boolean"
    },
    "global_commit": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Commit SHA to apply to all selected contents (overridden by per-item overrides)",
      "title": "Global Commit"
    },
    "overrides": {
      "anyOf": [
        {
          "items": {
            "$ref": "#/$defs/ReleaseOverride"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Per-content commit overrides",
      "title": "Overrides"
    }
  },
  "title": "ReleaseSelection",
  "type": "object",
  "x-model-name": "ReleaseSelection"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ReleaseSelection {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ReleaseSelection', 'Expected an object');
    }

    // Optional field: course_content_ids
    if ('course_content_ids' in data && data.course_content_ids !== undefined && data.course_content_ids !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: parent_id
    if ('parent_id' in data && data.parent_id !== undefined && data.parent_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: include_descendants
    if ('include_descendants' in data && data.include_descendants !== undefined && data.include_descendants !== null) {
      if (typeof data.include_descendants !== 'boolean') {
        errors.push('Field include_descendants must be a boolean');
      }
    }

    // Optional field: all
    if ('all' in data && data.all !== undefined && data.all !== null) {
      if (typeof data.all !== 'boolean') {
        errors.push('Field all must be a boolean');
      }
    }

    // Optional field: global_commit
    if ('global_commit' in data && data.global_commit !== undefined && data.global_commit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: overrides
    if ('overrides' in data && data.overrides !== undefined && data.overrides !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ReleaseSelection', errors.join('; '));
    }

    return data as ReleaseSelection;
  }

  safeValidate(data: any): { success: true; data: ReleaseSelection } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ReleaseSelection', String(error)) };
    }
  }
}

/**
 * Request to generate student template.
 */
export class GenerateTemplateRequestValidator extends BaseValidator<GenerateTemplateRequest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ReleaseOverride": {
      "description": "Per-item override for release commit selection.",
      "properties": {
        "course_content_id": {
          "title": "Course Content Id",
          "type": "string"
        },
        "version_identifier": {
          "description": "Commit SHA to use for this content",
          "title": "Version Identifier",
          "type": "string"
        }
      },
      "required": [
        "course_content_id",
        "version_identifier"
      ],
      "title": "ReleaseOverride",
      "type": "object"
    },
    "ReleaseSelection": {
      "description": "Selection of contents and commits for a release.",
      "properties": {
        "course_content_ids": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Explicit list of course content IDs to release",
          "title": "Course Content Ids"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Parent content ID; combined with include_descendants",
          "title": "Parent Id"
        },
        "include_descendants": {
          "default": true,
          "description": "Whether to include descendants of parent_id",
          "title": "Include Descendants",
          "type": "boolean"
        },
        "all": {
          "default": false,
          "description": "Select all contents in the course",
          "title": "All",
          "type": "boolean"
        },
        "global_commit": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Commit SHA to apply to all selected contents (overridden by per-item overrides)",
          "title": "Global Commit"
        },
        "overrides": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/ReleaseOverride"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Per-content commit overrides",
          "title": "Overrides"
        }
      },
      "title": "ReleaseSelection",
      "type": "object"
    }
  },
  "description": "Request to generate student template.",
  "properties": {
    "commit_message": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Custom commit message (optional)",
      "title": "Commit Message"
    },
    "force_redeploy": {
      "default": false,
      "description": "Force redeployment of already deployed content",
      "title": "Force Redeploy",
      "type": "boolean"
    },
    "release": {
      "anyOf": [
        {
          "$ref": "#/$defs/ReleaseSelection"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Selection of contents and commits to release"
    }
  },
  "title": "GenerateTemplateRequest",
  "type": "object",
  "x-model-name": "GenerateTemplateRequest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GenerateTemplateRequest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GenerateTemplateRequest', 'Expected an object');
    }

    // Optional field: commit_message
    if ('commit_message' in data && data.commit_message !== undefined && data.commit_message !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: force_redeploy
    if ('force_redeploy' in data && data.force_redeploy !== undefined && data.force_redeploy !== null) {
      if (typeof data.force_redeploy !== 'boolean') {
        errors.push('Field force_redeploy must be a boolean');
      }
    }

    // Optional field: release
    if ('release' in data && data.release !== undefined && data.release !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GenerateTemplateRequest', errors.join('; '));
    }

    return data as GenerateTemplateRequest;
  }

  safeValidate(data: any): { success: true; data: GenerateTemplateRequest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GenerateTemplateRequest', String(error)) };
    }
  }
}

/**
 * Response for template generation request.
 */
export class GenerateTemplateResponseValidator extends BaseValidator<GenerateTemplateResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Response for template generation request.",
  "properties": {
    "workflow_id": {
      "title": "Workflow Id",
      "type": "string"
    },
    "status": {
      "default": "started",
      "title": "Status",
      "type": "string"
    },
    "contents_to_process": {
      "title": "Contents To Process",
      "type": "integer"
    }
  },
  "required": [
    "workflow_id",
    "contents_to_process"
  ],
  "title": "GenerateTemplateResponse",
  "type": "object",
  "x-model-name": "GenerateTemplateResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GenerateTemplateResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GenerateTemplateResponse', 'Expected an object');
    }

    // Required field: workflow_id
    if (!('workflow_id' in data)) {
      errors.push('Missing required field: workflow_id');
    } else {
      if (typeof data.workflow_id !== 'string') {
        errors.push('Field workflow_id must be a string');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      if (typeof data.status !== 'string') {
        errors.push('Field status must be a string');
      }
    }

    // Required field: contents_to_process
    if (!('contents_to_process' in data)) {
      errors.push('Missing required field: contents_to_process');
    } else {
      if (typeof data.contents_to_process !== 'number') {
        errors.push('Field contents_to_process must be a number');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('GenerateTemplateResponse', errors.join('; '));
    }

    return data as GenerateTemplateResponse;
  }

  safeValidate(data: any): { success: true; data: GenerateTemplateResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GenerateTemplateResponse', String(error)) };
    }
  }
}

/**
 * Request to generate the assignments repository from Example Library.
 */
export class GenerateAssignmentsRequestValidator extends BaseValidator<GenerateAssignmentsRequest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Request to generate the assignments repository from Example Library.",
  "properties": {
    "assignments_url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Assignments Url"
    },
    "course_content_ids": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Ids"
    },
    "parent_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Parent Id"
    },
    "include_descendants": {
      "default": true,
      "title": "Include Descendants",
      "type": "boolean"
    },
    "all": {
      "default": false,
      "title": "All",
      "type": "boolean"
    },
    "overwrite_strategy": {
      "default": "skip_if_exists",
      "description": "skip_if_exists|force_update",
      "title": "Overwrite Strategy",
      "type": "string"
    },
    "commit_message": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Commit Message"
    }
  },
  "title": "GenerateAssignmentsRequest",
  "type": "object",
  "x-model-name": "GenerateAssignmentsRequest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GenerateAssignmentsRequest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GenerateAssignmentsRequest', 'Expected an object');
    }

    // Optional field: assignments_url
    if ('assignments_url' in data && data.assignments_url !== undefined && data.assignments_url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_ids
    if ('course_content_ids' in data && data.course_content_ids !== undefined && data.course_content_ids !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: parent_id
    if ('parent_id' in data && data.parent_id !== undefined && data.parent_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: include_descendants
    if ('include_descendants' in data && data.include_descendants !== undefined && data.include_descendants !== null) {
      if (typeof data.include_descendants !== 'boolean') {
        errors.push('Field include_descendants must be a boolean');
      }
    }

    // Optional field: all
    if ('all' in data && data.all !== undefined && data.all !== null) {
      if (typeof data.all !== 'boolean') {
        errors.push('Field all must be a boolean');
      }
    }

    // Optional field: overwrite_strategy
    if ('overwrite_strategy' in data && data.overwrite_strategy !== undefined && data.overwrite_strategy !== null) {
      if (typeof data.overwrite_strategy !== 'string') {
        errors.push('Field overwrite_strategy must be a string');
      }
    }

    // Optional field: commit_message
    if ('commit_message' in data && data.commit_message !== undefined && data.commit_message !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GenerateAssignmentsRequest', errors.join('; '));
    }

    return data as GenerateAssignmentsRequest;
  }

  safeValidate(data: any): { success: true; data: GenerateAssignmentsRequest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GenerateAssignmentsRequest', String(error)) };
    }
  }
}

/**
 * Validator for GenerateAssignmentsResponse
 */
export class GenerateAssignmentsResponseValidator extends BaseValidator<GenerateAssignmentsResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "workflow_id": {
      "title": "Workflow Id",
      "type": "string"
    },
    "status": {
      "default": "started",
      "title": "Status",
      "type": "string"
    },
    "contents_to_process": {
      "title": "Contents To Process",
      "type": "integer"
    }
  },
  "required": [
    "workflow_id",
    "contents_to_process"
  ],
  "title": "GenerateAssignmentsResponse",
  "type": "object",
  "x-model-name": "GenerateAssignmentsResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GenerateAssignmentsResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GenerateAssignmentsResponse', 'Expected an object');
    }

    // Required field: workflow_id
    if (!('workflow_id' in data)) {
      errors.push('Missing required field: workflow_id');
    } else {
      if (typeof data.workflow_id !== 'string') {
        errors.push('Field workflow_id must be a string');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      if (typeof data.status !== 'string') {
        errors.push('Field status must be a string');
      }
    }

    // Required field: contents_to_process
    if (!('contents_to_process' in data)) {
      errors.push('Missing required field: contents_to_process');
    } else {
      if (typeof data.contents_to_process !== 'number') {
        errors.push('Field contents_to_process must be a number');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('GenerateAssignmentsResponse', errors.join('; '));
    }

    return data as GenerateAssignmentsResponse;
  }

  safeValidate(data: any): { success: true; data: GenerateAssignmentsResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GenerateAssignmentsResponse', String(error)) };
    }
  }
}

/**
 * Validator for ResultCreate
 */
export class ResultCreateValidator extends BaseValidator<ResultCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "properties": {
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "submission_group_id": {
      "default": null,
      "title": "Submission Group Id",
      "type": "string"
    },
    "submission_artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Artifact Id"
    },
    "execution_backend_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Execution Backend Id"
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "result": {
      "title": "Result",
      "type": "number"
    },
    "grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grade"
    },
    "result_json": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Json"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "version_identifier": {
      "title": "Version Identifier",
      "type": "string"
    },
    "reference_version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Reference Version Identifier"
    },
    "status": {
      "$ref": "#/$defs/TaskStatus"
    }
  },
  "required": [
    "course_member_id",
    "course_content_id",
    "result",
    "version_identifier",
    "status"
  ],
  "title": "ResultCreate",
  "type": "object",
  "x-model-name": "ResultCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultCreate', 'Expected an object');
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Optional field: submission_artifact_id
    if ('submission_artifact_id' in data && data.submission_artifact_id !== undefined && data.submission_artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: execution_backend_id
    if ('execution_backend_id' in data && data.execution_backend_id !== undefined && data.execution_backend_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: result
    if (!('result' in data)) {
      errors.push('Missing required field: result');
    } else {
      if (typeof data.result !== 'number') {
        errors.push('Field result must be a number');
      }
    }

    // Optional field: grade
    if ('grade' in data && data.grade !== undefined && data.grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_json
    if ('result_json' in data && data.result_json !== undefined && data.result_json !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: version_identifier
    if (!('version_identifier' in data)) {
      errors.push('Missing required field: version_identifier');
    } else {
      if (typeof data.version_identifier !== 'string') {
        errors.push('Field version_identifier must be a string');
      }
    }

    // Optional field: reference_version_identifier
    if ('reference_version_identifier' in data && data.reference_version_identifier !== undefined && data.reference_version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultCreate', errors.join('; '));
    }

    return data as ResultCreate;
  }

  safeValidate(data: any): { success: true; data: ResultCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultCreate', String(error)) };
    }
  }
}

/**
 * Validator for ResultGet
 */
export class ResultGetValidator extends BaseValidator<ResultGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "course_content_type_id": {
      "title": "Course Content Type Id",
      "type": "string"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "submission_artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Artifact Id"
    },
    "execution_backend_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Execution Backend Id"
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "result": {
      "title": "Result",
      "type": "number"
    },
    "grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grade"
    },
    "result_json": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Json"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "version_identifier": {
      "title": "Version Identifier",
      "type": "string"
    },
    "reference_version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Reference Version Identifier"
    },
    "status": {
      "$ref": "#/$defs/TaskStatus"
    },
    "grading_ids": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Grading Ids"
    }
  },
  "required": [
    "id",
    "course_member_id",
    "course_content_id",
    "course_content_type_id",
    "result",
    "version_identifier",
    "status"
  ],
  "title": "ResultGet",
  "type": "object",
  "x-model-name": "ResultGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultGet', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: course_content_type_id
    if (!('course_content_type_id' in data)) {
      errors.push('Missing required field: course_content_type_id');
    } else {
      if (typeof data.course_content_type_id !== 'string') {
        errors.push('Field course_content_type_id must be a string');
      }
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_artifact_id
    if ('submission_artifact_id' in data && data.submission_artifact_id !== undefined && data.submission_artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: execution_backend_id
    if ('execution_backend_id' in data && data.execution_backend_id !== undefined && data.execution_backend_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: result
    if (!('result' in data)) {
      errors.push('Missing required field: result');
    } else {
      if (typeof data.result !== 'number') {
        errors.push('Field result must be a number');
      }
    }

    // Optional field: grade
    if ('grade' in data && data.grade !== undefined && data.grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_json
    if ('result_json' in data && data.result_json !== undefined && data.result_json !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: version_identifier
    if (!('version_identifier' in data)) {
      errors.push('Missing required field: version_identifier');
    } else {
      if (typeof data.version_identifier !== 'string') {
        errors.push('Field version_identifier must be a string');
      }
    }

    // Optional field: reference_version_identifier
    if ('reference_version_identifier' in data && data.reference_version_identifier !== undefined && data.reference_version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: grading_ids
    if ('grading_ids' in data && data.grading_ids !== undefined && data.grading_ids !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultGet', errors.join('; '));
    }

    return data as ResultGet;
  }

  safeValidate(data: any): { success: true; data: ResultGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultGet', String(error)) };
    }
  }
}

/**
 * Validator for ResultList
 */
export class ResultListValidator extends BaseValidator<ResultList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "course_content_type_id": {
      "title": "Course Content Type Id",
      "type": "string"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "submission_artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Artifact Id"
    },
    "execution_backend_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Execution Backend Id"
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "result": {
      "title": "Result",
      "type": "number"
    },
    "grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grade"
    },
    "version_identifier": {
      "title": "Version Identifier",
      "type": "string"
    },
    "reference_version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Reference Version Identifier"
    },
    "status": {
      "$ref": "#/$defs/TaskStatus"
    }
  },
  "required": [
    "id",
    "course_member_id",
    "course_content_id",
    "course_content_type_id",
    "result",
    "version_identifier",
    "status"
  ],
  "title": "ResultList",
  "type": "object",
  "x-model-name": "ResultList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultList', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: course_content_type_id
    if (!('course_content_type_id' in data)) {
      errors.push('Missing required field: course_content_type_id');
    } else {
      if (typeof data.course_content_type_id !== 'string') {
        errors.push('Field course_content_type_id must be a string');
      }
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_artifact_id
    if ('submission_artifact_id' in data && data.submission_artifact_id !== undefined && data.submission_artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: execution_backend_id
    if ('execution_backend_id' in data && data.execution_backend_id !== undefined && data.execution_backend_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: result
    if (!('result' in data)) {
      errors.push('Missing required field: result');
    } else {
      if (typeof data.result !== 'number') {
        errors.push('Field result must be a number');
      }
    }

    // Optional field: grade
    if ('grade' in data && data.grade !== undefined && data.grade !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: version_identifier
    if (!('version_identifier' in data)) {
      errors.push('Missing required field: version_identifier');
    } else {
      if (typeof data.version_identifier !== 'string') {
        errors.push('Field version_identifier must be a string');
      }
    }

    // Optional field: reference_version_identifier
    if ('reference_version_identifier' in data && data.reference_version_identifier !== undefined && data.reference_version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultList', errors.join('; '));
    }

    return data as ResultList;
  }

  safeValidate(data: any): { success: true; data: ResultList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultList', String(error)) };
    }
  }
}

/**
 * Validator for ResultUpdate
 */
export class ResultUpdateValidator extends BaseValidator<ResultUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "properties": {
    "result": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result"
    },
    "grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grade"
    },
    "result_json": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Json"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/TaskStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    }
  },
  "title": "ResultUpdate",
  "type": "object",
  "x-model-name": "ResultUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultUpdate', 'Expected an object');
    }

    // Optional field: result
    if ('result' in data && data.result !== undefined && data.result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grade
    if ('grade' in data && data.grade !== undefined && data.grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_json
    if ('result_json' in data && data.result_json !== undefined && data.result_json !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultUpdate', errors.join('; '));
    }

    return data as ResultUpdate;
  }

  safeValidate(data: any): { success: true; data: ResultUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultUpdate', String(error)) };
    }
  }
}

/**
 * Validator for ResultQuery
 */
export class ResultQueryValidator extends BaseValidator<ResultQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "submitter_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submitter Id"
    },
    "course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Member Id"
    },
    "course_content_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Id"
    },
    "course_content_type_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Type Id"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "submission_artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Artifact Id"
    },
    "execution_backend_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Execution Backend Id"
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Identifier"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/TaskStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "latest": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": false,
      "title": "Latest"
    },
    "result": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result"
    },
    "grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grade"
    },
    "result_json": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Json"
    }
  },
  "title": "ResultQuery",
  "type": "object",
  "x-model-name": "ResultQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submitter_id
    if ('submitter_id' in data && data.submitter_id !== undefined && data.submitter_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_member_id
    if ('course_member_id' in data && data.course_member_id !== undefined && data.course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_id
    if ('course_content_id' in data && data.course_content_id !== undefined && data.course_content_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_type_id
    if ('course_content_type_id' in data && data.course_content_type_id !== undefined && data.course_content_type_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_artifact_id
    if ('submission_artifact_id' in data && data.submission_artifact_id !== undefined && data.submission_artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: execution_backend_id
    if ('execution_backend_id' in data && data.execution_backend_id !== undefined && data.execution_backend_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version_identifier
    if ('version_identifier' in data && data.version_identifier !== undefined && data.version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: latest
    if ('latest' in data && data.latest !== undefined && data.latest !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result
    if ('result' in data && data.result !== undefined && data.result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grade
    if ('grade' in data && data.grade !== undefined && data.grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_json
    if ('result_json' in data && data.result_json !== undefined && data.result_json !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultQuery', errors.join('; '));
    }

    return data as ResultQuery;
  }

  safeValidate(data: any): { success: true; data: ResultQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultQuery', String(error)) };
    }
  }
}

/**
 * Result with associated grading information.
 */
export class ResultWithGradingValidator extends BaseValidator<ResultWithGrading> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "description": "Result with associated grading information.",
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "course_content_type_id": {
      "title": "Course Content Type Id",
      "type": "string"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "submission_artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Artifact Id"
    },
    "execution_backend_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Execution Backend Id"
    },
    "test_system_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Test System Id"
    },
    "result": {
      "title": "Result",
      "type": "number"
    },
    "grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grade"
    },
    "result_json": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Json"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Properties"
    },
    "version_identifier": {
      "title": "Version Identifier",
      "type": "string"
    },
    "reference_version_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Reference Version Identifier"
    },
    "status": {
      "$ref": "#/$defs/TaskStatus"
    },
    "grading_ids": {
      "anyOf": [
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "type": "null"
        }
      ],
      "default": [],
      "title": "Grading Ids"
    },
    "latest_grading": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Latest Grading"
    },
    "grading_count": {
      "default": 0,
      "title": "Grading Count",
      "type": "integer"
    }
  },
  "required": [
    "id",
    "course_member_id",
    "course_content_id",
    "course_content_type_id",
    "result",
    "version_identifier",
    "status"
  ],
  "title": "ResultWithGrading",
  "type": "object",
  "x-model-name": "ResultWithGrading"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ResultWithGrading {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ResultWithGrading', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: course_content_type_id
    if (!('course_content_type_id' in data)) {
      errors.push('Missing required field: course_content_type_id');
    } else {
      if (typeof data.course_content_type_id !== 'string') {
        errors.push('Field course_content_type_id must be a string');
      }
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_artifact_id
    if ('submission_artifact_id' in data && data.submission_artifact_id !== undefined && data.submission_artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: execution_backend_id
    if ('execution_backend_id' in data && data.execution_backend_id !== undefined && data.execution_backend_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: test_system_id
    if ('test_system_id' in data && data.test_system_id !== undefined && data.test_system_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: result
    if (!('result' in data)) {
      errors.push('Missing required field: result');
    } else {
      if (typeof data.result !== 'number') {
        errors.push('Field result must be a number');
      }
    }

    // Optional field: grade
    if ('grade' in data && data.grade !== undefined && data.grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_json
    if ('result_json' in data && data.result_json !== undefined && data.result_json !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: version_identifier
    if (!('version_identifier' in data)) {
      errors.push('Missing required field: version_identifier');
    } else {
      if (typeof data.version_identifier !== 'string') {
        errors.push('Field version_identifier must be a string');
      }
    }

    // Optional field: reference_version_identifier
    if ('reference_version_identifier' in data && data.reference_version_identifier !== undefined && data.reference_version_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: grading_ids
    if ('grading_ids' in data && data.grading_ids !== undefined && data.grading_ids !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: latest_grading
    if ('latest_grading' in data && data.latest_grading !== undefined && data.latest_grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grading_count
    if ('grading_count' in data && data.grading_count !== undefined && data.grading_count !== null) {
      if (typeof data.grading_count !== 'number') {
        errors.push('Field grading_count must be a number');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ResultWithGrading', errors.join('; '));
    }

    return data as ResultWithGrading;
  }

  safeValidate(data: any): { success: true; data: ResultWithGrading } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ResultWithGrading', String(error)) };
    }
  }
}

/**
 * Create a new grading for a submission group.
 */
export class SubmissionGroupGradingCreateValidator extends BaseValidator<SubmissionGroupGradingCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradedByCourseMember": {
      "properties": {
        "course_role_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Course Role Id"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "user": {
          "anyOf": [
            {
              "$ref": "#/$defs/GradingAuthor"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "user_id"
      ],
      "title": "GradedByCourseMember",
      "type": "object"
    },
    "GradingAuthor": {
      "properties": {
        "given_name": {
          "anyOf": [
            {
              "maxLength": 255,
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Author's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "maxLength": 255,
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Author's family name",
          "title": "Family Name"
        }
      },
      "title": "GradingAuthor",
      "type": "object"
    },
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "Create a new grading for a submission group.",
  "properties": {
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "graded_by_course_member_id": {
      "title": "Graded By Course Member Id",
      "type": "string"
    },
    "result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Id"
    },
    "grading": {
      "maximum": 1.0,
      "minimum": 0.0,
      "title": "Grading",
      "type": "number"
    },
    "status": {
      "$ref": "#/$defs/GradingStatus",
      "default": 0
    },
    "feedback": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Feedback"
    },
    "graded_by_course_member": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradedByCourseMember"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "submission_group_id",
    "graded_by_course_member_id",
    "grading"
  ],
  "title": "SubmissionGroupGradingCreate",
  "type": "object",
  "x-model-name": "SubmissionGroupGradingCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupGradingCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupGradingCreate', 'Expected an object');
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Required field: graded_by_course_member_id
    if (!('graded_by_course_member_id' in data)) {
      errors.push('Missing required field: graded_by_course_member_id');
    } else {
      if (typeof data.graded_by_course_member_id !== 'string') {
        errors.push('Field graded_by_course_member_id must be a string');
      }
    }

    // Optional field: result_id
    if ('result_id' in data && data.result_id !== undefined && data.result_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: grading
    if (!('grading' in data)) {
      errors.push('Missing required field: grading');
    } else {
      if (typeof data.grading !== 'number') {
        errors.push('Field grading must be a number');
      }
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: feedback
    if ('feedback' in data && data.feedback !== undefined && data.feedback !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: graded_by_course_member
    if ('graded_by_course_member' in data && data.graded_by_course_member !== undefined && data.graded_by_course_member !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupGradingCreate', errors.join('; '));
    }

    return data as SubmissionGroupGradingCreate;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupGradingCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupGradingCreate', String(error)) };
    }
  }
}

/**
 * Full grading information.
 */
export class SubmissionGroupGradingGetValidator extends BaseValidator<SubmissionGroupGradingGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradedByCourseMember": {
      "properties": {
        "course_role_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Course Role Id"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "user": {
          "anyOf": [
            {
              "$ref": "#/$defs/GradingAuthor"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "user_id"
      ],
      "title": "GradedByCourseMember",
      "type": "object"
    },
    "GradingAuthor": {
      "properties": {
        "given_name": {
          "anyOf": [
            {
              "maxLength": 255,
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Author's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "maxLength": 255,
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Author's family name",
          "title": "Family Name"
        }
      },
      "title": "GradingAuthor",
      "type": "object"
    },
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "Full grading information.",
  "properties": {
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "format": "date-time",
      "title": "Updated At",
      "type": "string"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "graded_by_course_member_id": {
      "title": "Graded By Course Member Id",
      "type": "string"
    },
    "result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Id"
    },
    "grading": {
      "title": "Grading",
      "type": "number"
    },
    "status": {
      "$ref": "#/$defs/GradingStatus"
    },
    "feedback": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Feedback"
    },
    "graded_by_course_member": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradedByCourseMember"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "created_at",
    "updated_at",
    "id",
    "submission_group_id",
    "graded_by_course_member_id",
    "grading",
    "status"
  ],
  "title": "SubmissionGroupGradingGet",
  "type": "object",
  "x-model-name": "SubmissionGroupGradingGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupGradingGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupGradingGet', 'Expected an object');
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: updated_at
    if (!('updated_at' in data)) {
      errors.push('Missing required field: updated_at');
    } else {
      if (typeof data.updated_at !== 'string') {
        errors.push('Field updated_at must be a string');
      }
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Required field: graded_by_course_member_id
    if (!('graded_by_course_member_id' in data)) {
      errors.push('Missing required field: graded_by_course_member_id');
    } else {
      if (typeof data.graded_by_course_member_id !== 'string') {
        errors.push('Field graded_by_course_member_id must be a string');
      }
    }

    // Optional field: result_id
    if ('result_id' in data && data.result_id !== undefined && data.result_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: grading
    if (!('grading' in data)) {
      errors.push('Missing required field: grading');
    } else {
      if (typeof data.grading !== 'number') {
        errors.push('Field grading must be a number');
      }
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: feedback
    if ('feedback' in data && data.feedback !== undefined && data.feedback !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: graded_by_course_member
    if ('graded_by_course_member' in data && data.graded_by_course_member !== undefined && data.graded_by_course_member !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupGradingGet', errors.join('; '));
    }

    return data as SubmissionGroupGradingGet;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupGradingGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupGradingGet', String(error)) };
    }
  }
}

/**
 * List view of grading.
 */
export class SubmissionGroupGradingListValidator extends BaseValidator<SubmissionGroupGradingList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradedByCourseMember": {
      "properties": {
        "course_role_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Course Role Id"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "user": {
          "anyOf": [
            {
              "$ref": "#/$defs/GradingAuthor"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "user_id"
      ],
      "title": "GradedByCourseMember",
      "type": "object"
    },
    "GradingAuthor": {
      "properties": {
        "given_name": {
          "anyOf": [
            {
              "maxLength": 255,
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Author's given name",
          "title": "Given Name"
        },
        "family_name": {
          "anyOf": [
            {
              "maxLength": 255,
              "minLength": 1,
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Author's family name",
          "title": "Family Name"
        }
      },
      "title": "GradingAuthor",
      "type": "object"
    },
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "List view of grading.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "graded_by_course_member_id": {
      "title": "Graded By Course Member Id",
      "type": "string"
    },
    "result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Id"
    },
    "grading": {
      "title": "Grading",
      "type": "number"
    },
    "status": {
      "$ref": "#/$defs/GradingStatus"
    },
    "feedback": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Feedback"
    },
    "created_at": {
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "graded_by_course_member": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradedByCourseMember"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "id",
    "submission_group_id",
    "graded_by_course_member_id",
    "grading",
    "status",
    "created_at"
  ],
  "title": "SubmissionGroupGradingList",
  "type": "object",
  "x-model-name": "SubmissionGroupGradingList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupGradingList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupGradingList', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Required field: graded_by_course_member_id
    if (!('graded_by_course_member_id' in data)) {
      errors.push('Missing required field: graded_by_course_member_id');
    } else {
      if (typeof data.graded_by_course_member_id !== 'string') {
        errors.push('Field graded_by_course_member_id must be a string');
      }
    }

    // Optional field: result_id
    if ('result_id' in data && data.result_id !== undefined && data.result_id !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: grading
    if (!('grading' in data)) {
      errors.push('Missing required field: grading');
    } else {
      if (typeof data.grading !== 'number') {
        errors.push('Field grading must be a number');
      }
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: feedback
    if ('feedback' in data && data.feedback !== undefined && data.feedback !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Optional field: graded_by_course_member
    if ('graded_by_course_member' in data && data.graded_by_course_member !== undefined && data.graded_by_course_member !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupGradingList', errors.join('; '));
    }

    return data as SubmissionGroupGradingList;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupGradingList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupGradingList', String(error)) };
    }
  }
}

/**
 * Update grading information.
 */
export class SubmissionGroupGradingUpdateValidator extends BaseValidator<SubmissionGroupGradingUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "Update grading information.",
  "properties": {
    "grading": {
      "anyOf": [
        {
          "maximum": 1.0,
          "minimum": 0.0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grading"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradingStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "feedback": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Feedback"
    },
    "result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Id"
    }
  },
  "title": "SubmissionGroupGradingUpdate",
  "type": "object",
  "x-model-name": "SubmissionGroupGradingUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupGradingUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupGradingUpdate', 'Expected an object');
    }

    // Optional field: grading
    if ('grading' in data && data.grading !== undefined && data.grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: feedback
    if ('feedback' in data && data.feedback !== undefined && data.feedback !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_id
    if ('result_id' in data && data.result_id !== undefined && data.result_id !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupGradingUpdate', errors.join('; '));
    }

    return data as SubmissionGroupGradingUpdate;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupGradingUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupGradingUpdate', String(error)) };
    }
  }
}

/**
 * Query parameters for searching gradings.
 */
export class SubmissionGroupGradingQueryValidator extends BaseValidator<SubmissionGroupGradingQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "Query parameters for searching gradings.",
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "graded_by_course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Graded By Course Member Id"
    },
    "result_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Result Id"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradingStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "min_grade": {
      "anyOf": [
        {
          "maximum": 1.0,
          "minimum": 0.0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Min Grade"
    },
    "max_grade": {
      "anyOf": [
        {
          "maximum": 1.0,
          "minimum": 0.0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Grade"
    },
    "has_feedback": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Has Feedback"
    }
  },
  "title": "SubmissionGroupGradingQuery",
  "type": "object",
  "x-model-name": "SubmissionGroupGradingQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupGradingQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupGradingQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: graded_by_course_member_id
    if ('graded_by_course_member_id' in data && data.graded_by_course_member_id !== undefined && data.graded_by_course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: result_id
    if ('result_id' in data && data.result_id !== undefined && data.result_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: min_grade
    if ('min_grade' in data && data.min_grade !== undefined && data.min_grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: max_grade
    if ('max_grade' in data && data.max_grade !== undefined && data.max_grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: has_feedback
    if ('has_feedback' in data && data.has_feedback !== undefined && data.has_feedback !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupGradingQuery', errors.join('; '));
    }

    return data as SubmissionGroupGradingQuery;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupGradingQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupGradingQuery', String(error)) };
    }
  }
}

/**
 * Simplified grading view for students.
 */
export class GradingStudentViewValidator extends BaseValidator<GradingStudentView> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "Simplified grading view for students.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "grading": {
      "title": "Grading",
      "type": "number"
    },
    "status": {
      "$ref": "#/$defs/GradingStatus"
    },
    "feedback": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Feedback"
    },
    "graded_by_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Graded By Name"
    },
    "graded_at": {
      "format": "date-time",
      "title": "Graded At",
      "type": "string"
    }
  },
  "required": [
    "id",
    "grading",
    "status",
    "graded_at"
  ],
  "title": "GradingStudentView",
  "type": "object",
  "x-model-name": "GradingStudentView"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GradingStudentView {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GradingStudentView', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: grading
    if (!('grading' in data)) {
      errors.push('Missing required field: grading');
    } else {
      if (typeof data.grading !== 'number') {
        errors.push('Field grading must be a number');
      }
    }

    // Required field: status
    if (!('status' in data)) {
      errors.push('Missing required field: status');
    } else {
      // Reference field - basic object check
      if (typeof data.status !== 'object') {
        errors.push('Field status must be an object');
      }
    }

    // Optional field: feedback
    if ('feedback' in data && data.feedback !== undefined && data.feedback !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: graded_by_name
    if ('graded_by_name' in data && data.graded_by_name !== undefined && data.graded_by_name !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: graded_at
    if (!('graded_at' in data)) {
      errors.push('Missing required field: graded_at');
    } else {
      if (typeof data.graded_at !== 'string') {
        errors.push('Field graded_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('GradingStudentView', errors.join('; '));
    }

    return data as GradingStudentView;
  }

  safeValidate(data: any): { success: true; data: GradingStudentView } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GradingStudentView', String(error)) };
    }
  }
}

/**
 * Summary of gradings for a course content.
 */
export class GradingSummaryValidator extends BaseValidator<GradingSummary> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Summary of gradings for a course content.",
  "properties": {
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "total_submissions": {
      "title": "Total Submissions",
      "type": "integer"
    },
    "graded_count": {
      "title": "Graded Count",
      "type": "integer"
    },
    "ungraded_count": {
      "title": "Ungraded Count",
      "type": "integer"
    },
    "corrected_count": {
      "title": "Corrected Count",
      "type": "integer"
    },
    "correction_necessary_count": {
      "title": "Correction Necessary Count",
      "type": "integer"
    },
    "improvement_possible_count": {
      "title": "Improvement Possible Count",
      "type": "integer"
    },
    "average_grade": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Average Grade"
    }
  },
  "required": [
    "course_content_id",
    "total_submissions",
    "graded_count",
    "ungraded_count",
    "corrected_count",
    "correction_necessary_count",
    "improvement_possible_count"
  ],
  "title": "GradingSummary",
  "type": "object",
  "x-model-name": "GradingSummary"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GradingSummary {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GradingSummary', 'Expected an object');
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: total_submissions
    if (!('total_submissions' in data)) {
      errors.push('Missing required field: total_submissions');
    } else {
      if (typeof data.total_submissions !== 'number') {
        errors.push('Field total_submissions must be a number');
      }
    }

    // Required field: graded_count
    if (!('graded_count' in data)) {
      errors.push('Missing required field: graded_count');
    } else {
      if (typeof data.graded_count !== 'number') {
        errors.push('Field graded_count must be a number');
      }
    }

    // Required field: ungraded_count
    if (!('ungraded_count' in data)) {
      errors.push('Missing required field: ungraded_count');
    } else {
      if (typeof data.ungraded_count !== 'number') {
        errors.push('Field ungraded_count must be a number');
      }
    }

    // Required field: corrected_count
    if (!('corrected_count' in data)) {
      errors.push('Missing required field: corrected_count');
    } else {
      if (typeof data.corrected_count !== 'number') {
        errors.push('Field corrected_count must be a number');
      }
    }

    // Required field: correction_necessary_count
    if (!('correction_necessary_count' in data)) {
      errors.push('Missing required field: correction_necessary_count');
    } else {
      if (typeof data.correction_necessary_count !== 'number') {
        errors.push('Field correction_necessary_count must be a number');
      }
    }

    // Required field: improvement_possible_count
    if (!('improvement_possible_count' in data)) {
      errors.push('Missing required field: improvement_possible_count');
    } else {
      if (typeof data.improvement_possible_count !== 'number') {
        errors.push('Field improvement_possible_count must be a number');
      }
    }

    // Optional field: average_grade
    if ('average_grade' in data && data.average_grade !== undefined && data.average_grade !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GradingSummary', errors.join('; '));
    }

    return data as GradingSummary;
  }

  safeValidate(data: any): { success: true; data: GradingSummary } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GradingSummary', String(error)) };
    }
  }
}

/**
 * Validator for GitCommit
 */
export class GitCommitValidator extends BaseValidator<GitCommit> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "hash": {
      "title": "Hash",
      "type": "string"
    },
    "date": {
      "title": "Date",
      "type": "string"
    },
    "message": {
      "title": "Message",
      "type": "string"
    },
    "author": {
      "title": "Author",
      "type": "string"
    }
  },
  "required": [
    "hash",
    "date",
    "message",
    "author"
  ],
  "title": "GitCommit",
  "type": "object",
  "x-model-name": "GitCommit"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GitCommit {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GitCommit', 'Expected an object');
    }

    // Required field: hash
    if (!('hash' in data)) {
      errors.push('Missing required field: hash');
    } else {
      if (typeof data.hash !== 'string') {
        errors.push('Field hash must be a string');
      }
    }

    // Required field: date
    if (!('date' in data)) {
      errors.push('Missing required field: date');
    } else {
      if (typeof data.date !== 'string') {
        errors.push('Field date must be a string');
      }
    }

    // Required field: message
    if (!('message' in data)) {
      errors.push('Missing required field: message');
    } else {
      if (typeof data.message !== 'string') {
        errors.push('Field message must be a string');
      }
    }

    // Required field: author
    if (!('author' in data)) {
      errors.push('Missing required field: author');
    } else {
      if (typeof data.author !== 'string') {
        errors.push('Field author must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('GitCommit', errors.join('; '));
    }

    return data as GitCommit;
  }

  safeValidate(data: any): { success: true; data: GitCommit } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GitCommit', String(error)) };
    }
  }
}

/**
 * Validator for ProfileCreate
 */
export class ProfileCreateValidator extends BaseValidator<ProfileCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "user_id": {
      "description": "Associated user ID",
      "title": "User Id",
      "type": "string"
    },
    "avatar_color": {
      "anyOf": [
        {
          "maximum": 16777215,
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Avatar color as RGB integer (0-16777215)",
      "title": "Avatar Color"
    },
    "avatar_image": {
      "anyOf": [
        {
          "maxLength": 2048,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Avatar image URL",
      "title": "Avatar Image"
    },
    "nickname": {
      "anyOf": [
        {
          "maxLength": 255,
          "minLength": 2,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Unique nickname",
      "title": "Nickname"
    },
    "bio": {
      "anyOf": [
        {
          "maxLength": 16384,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User biography",
      "title": "Bio"
    },
    "url": {
      "anyOf": [
        {
          "maxLength": 2048,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User website URL",
      "title": "Url"
    },
    "language_code": {
      "anyOf": [
        {
          "maxLength": 2,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "ISO 639-1 language code",
      "title": "Language Code"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional profile properties",
      "title": "Properties"
    }
  },
  "required": [
    "user_id"
  ],
  "title": "ProfileCreate",
  "type": "object",
  "x-model-name": "ProfileCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ProfileCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ProfileCreate', 'Expected an object');
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Optional field: avatar_color
    if ('avatar_color' in data && data.avatar_color !== undefined && data.avatar_color !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: avatar_image
    if ('avatar_image' in data && data.avatar_image !== undefined && data.avatar_image !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: nickname
    if ('nickname' in data && data.nickname !== undefined && data.nickname !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: bio
    if ('bio' in data && data.bio !== undefined && data.bio !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: url
    if ('url' in data && data.url !== undefined && data.url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: language_code
    if ('language_code' in data && data.language_code !== undefined && data.language_code !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ProfileCreate', errors.join('; '));
    }

    return data as ProfileCreate;
  }

  safeValidate(data: any): { success: true; data: ProfileCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ProfileCreate', String(error)) };
    }
  }
}

/**
 * Validator for ProfileGet
 */
export class ProfileGetValidator extends BaseValidator<ProfileGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "description": "Profile unique identifier",
      "title": "Id",
      "type": "string"
    },
    "user_id": {
      "description": "Associated user ID",
      "title": "User Id",
      "type": "string"
    },
    "avatar_color": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Avatar color as RGB integer",
      "title": "Avatar Color"
    },
    "avatar_image": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Avatar image URL",
      "title": "Avatar Image"
    },
    "nickname": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Unique nickname",
      "title": "Nickname"
    },
    "bio": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User biography",
      "title": "Bio"
    },
    "url": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User website URL",
      "title": "Url"
    },
    "language_code": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "ISO 639-1 language code",
      "title": "Language Code"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional properties",
      "title": "Properties"
    }
  },
  "required": [
    "id",
    "user_id"
  ],
  "title": "ProfileGet",
  "type": "object",
  "x-model-name": "ProfileGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ProfileGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ProfileGet', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Optional field: avatar_color
    if ('avatar_color' in data && data.avatar_color !== undefined && data.avatar_color !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: avatar_image
    if ('avatar_image' in data && data.avatar_image !== undefined && data.avatar_image !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: nickname
    if ('nickname' in data && data.nickname !== undefined && data.nickname !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: bio
    if ('bio' in data && data.bio !== undefined && data.bio !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: url
    if ('url' in data && data.url !== undefined && data.url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: language_code
    if ('language_code' in data && data.language_code !== undefined && data.language_code !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ProfileGet', errors.join('; '));
    }

    return data as ProfileGet;
  }

  safeValidate(data: any): { success: true; data: ProfileGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ProfileGet', String(error)) };
    }
  }
}

/**
 * Validator for ProfileList
 */
export class ProfileListValidator extends BaseValidator<ProfileList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "id": {
      "description": "Profile unique identifier",
      "title": "Id",
      "type": "string"
    },
    "user_id": {
      "description": "Associated user ID",
      "title": "User Id",
      "type": "string"
    },
    "nickname": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Unique nickname",
      "title": "Nickname"
    },
    "avatar_image": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Avatar image URL",
      "title": "Avatar Image"
    },
    "avatar_color": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Avatar color",
      "title": "Avatar Color"
    },
    "language_code": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "ISO 639-1 language code",
      "title": "Language Code"
    }
  },
  "required": [
    "id",
    "user_id"
  ],
  "title": "ProfileList",
  "type": "object",
  "x-model-name": "ProfileList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ProfileList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ProfileList', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: user_id
    if (!('user_id' in data)) {
      errors.push('Missing required field: user_id');
    } else {
      if (typeof data.user_id !== 'string') {
        errors.push('Field user_id must be a string');
      }
    }

    // Optional field: nickname
    if ('nickname' in data && data.nickname !== undefined && data.nickname !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: avatar_image
    if ('avatar_image' in data && data.avatar_image !== undefined && data.avatar_image !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: avatar_color
    if ('avatar_color' in data && data.avatar_color !== undefined && data.avatar_color !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: language_code
    if ('language_code' in data && data.language_code !== undefined && data.language_code !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ProfileList', errors.join('; '));
    }

    return data as ProfileList;
  }

  safeValidate(data: any): { success: true; data: ProfileList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ProfileList', String(error)) };
    }
  }
}

/**
 * Validator for ProfileUpdate
 */
export class ProfileUpdateValidator extends BaseValidator<ProfileUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "avatar_color": {
      "anyOf": [
        {
          "maximum": 16777215,
          "minimum": 0,
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Avatar color as RGB integer",
      "title": "Avatar Color"
    },
    "avatar_image": {
      "anyOf": [
        {
          "maxLength": 2048,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Avatar image URL",
      "title": "Avatar Image"
    },
    "nickname": {
      "anyOf": [
        {
          "maxLength": 255,
          "minLength": 2,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Unique nickname",
      "title": "Nickname"
    },
    "bio": {
      "anyOf": [
        {
          "maxLength": 16384,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User biography",
      "title": "Bio"
    },
    "url": {
      "anyOf": [
        {
          "maxLength": 2048,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "User website URL",
      "title": "Url"
    },
    "language_code": {
      "anyOf": [
        {
          "maxLength": 2,
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "ISO 639-1 language code",
      "title": "Language Code"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional properties",
      "title": "Properties"
    }
  },
  "title": "ProfileUpdate",
  "type": "object",
  "x-model-name": "ProfileUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ProfileUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ProfileUpdate', 'Expected an object');
    }

    // Optional field: avatar_color
    if ('avatar_color' in data && data.avatar_color !== undefined && data.avatar_color !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: avatar_image
    if ('avatar_image' in data && data.avatar_image !== undefined && data.avatar_image !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: nickname
    if ('nickname' in data && data.nickname !== undefined && data.nickname !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: bio
    if ('bio' in data && data.bio !== undefined && data.bio !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: url
    if ('url' in data && data.url !== undefined && data.url !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: language_code
    if ('language_code' in data && data.language_code !== undefined && data.language_code !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ProfileUpdate', errors.join('; '));
    }

    return data as ProfileUpdate;
  }

  safeValidate(data: any): { success: true; data: ProfileUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ProfileUpdate', String(error)) };
    }
  }
}

/**
 * Validator for ProfileQuery
 */
export class ProfileQueryValidator extends BaseValidator<ProfileQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by profile ID",
      "title": "Id"
    },
    "user_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by user ID",
      "title": "User Id"
    },
    "nickname": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Filter by nickname",
      "title": "Nickname"
    }
  },
  "title": "ProfileQuery",
  "type": "object",
  "x-model-name": "ProfileQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ProfileQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ProfileQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: user_id
    if ('user_id' in data && data.user_id !== undefined && data.user_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: nickname
    if ('nickname' in data && data.nickname !== undefined && data.nickname !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ProfileQuery', errors.join('; '));
    }

    return data as ProfileQuery;
  }

  safeValidate(data: any): { success: true; data: ProfileQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ProfileQuery', String(error)) };
    }
  }
}

/**
 * DTO for creating a grade through the tutor endpoint.

    This is used when a tutor grades a student's submission for a specific course content.
    The endpoint will automatically find the latest artifact for the submission group.
 */
export class TutorGradeCreateValidator extends BaseValidator<TutorGradeCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GradingStatus": {
      "description": "Enumeration for grading status values.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "title": "GradingStatus",
      "type": "integer"
    }
  },
  "description": "DTO for creating a grade through the tutor endpoint.\\n\\n    This is used when a tutor grades a student's submission for a specific course content.\\n    The endpoint will automatically find the latest artifact for the submission group.",
  "properties": {
    "artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Artifact Id"
    },
    "grade": {
      "anyOf": [
        {
          "maximum": 1.0,
          "minimum": 0.0,
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Grade between 0.0 and 1.0",
      "title": "Grade"
    },
    "status": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradingStatus"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Grading status"
    },
    "feedback": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Feedback/comment for the student",
      "title": "Feedback"
    }
  },
  "title": "TutorGradeCreate",
  "type": "object",
  "x-model-name": "TutorGradeCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TutorGradeCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TutorGradeCreate', 'Expected an object');
    }

    // Optional field: artifact_id
    if ('artifact_id' in data && data.artifact_id !== undefined && data.artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grade
    if ('grade' in data && data.grade !== undefined && data.grade !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: feedback
    if ('feedback' in data && data.feedback !== undefined && data.feedback !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TutorGradeCreate', errors.join('; '));
    }

    return data as TutorGradeCreate;
  }

  safeValidate(data: any): { success: true; data: TutorGradeCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TutorGradeCreate', String(error)) };
    }
  }
}

/**
 * Information about the artifact that was graded.

    This provides context about which specific artifact received the grade,
    useful for tracking grading history and artifact metadata.
 */
export class GradedArtifactInfoValidator extends BaseValidator<GradedArtifactInfo> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Information about the artifact that was graded.\\n\\n    This provides context about which specific artifact received the grade,\\n    useful for tracking grading history and artifact metadata.",
  "properties": {
    "id": {
      "description": "The artifact ID that was graded",
      "title": "Id",
      "type": "string"
    },
    "created_at": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "When the artifact was created (ISO format)",
      "title": "Created At"
    },
    "properties": {
      "anyOf": [
        {
          "additionalProperties": true,
          "type": "object"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Additional artifact properties (e.g., GitLab info)",
      "title": "Properties"
    }
  },
  "required": [
    "id"
  ],
  "title": "GradedArtifactInfo",
  "type": "object",
  "x-model-name": "GradedArtifactInfo"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): GradedArtifactInfo {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('GradedArtifactInfo', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('GradedArtifactInfo', errors.join('; '));
    }

    return data as GradedArtifactInfo;
  }

  safeValidate(data: any): { success: true; data: GradedArtifactInfo } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('GradedArtifactInfo', String(error)) };
    }
  }
}

/**
 * Response after creating a grade through the tutor endpoint.

    Returns the updated course content information with the new grade applied.
    We extend CourseContentStudentList to maintain backward compatibility.
 */
export class TutorGradeResponseValidator extends BaseValidator<TutorGradeResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "CourseContentDeploymentList": {
      "description": "List view of deployments.",
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "course_content_id": {
          "title": "Course Content Id",
          "type": "string"
        },
        "example_version_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "title": "Example Version Id"
        },
        "example_identifier": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Example Identifier"
        },
        "version_tag": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Version Tag"
        },
        "deployment_status": {
          "title": "Deployment Status",
          "type": "string"
        },
        "assigned_at": {
          "format": "date-time",
          "title": "Assigned At",
          "type": "string"
        },
        "deployed_at": {
          "anyOf": [
            {
              "format": "date-time",
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "title": "Deployed At"
        },
        "version_identifier": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "title": "Version Identifier"
        },
        "example_version": {
          "anyOf": [
            {
              "$ref": "#/$defs/ExampleVersionList"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "id",
        "course_content_id",
        "example_version_id",
        "deployment_status",
        "assigned_at",
        "deployed_at",
        "version_identifier"
      ],
      "title": "CourseContentDeploymentList",
      "type": "object"
    },
    "CourseContentKindList": {
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Title"
        },
        "has_ascendants": {
          "title": "Has Ascendants",
          "type": "boolean"
        },
        "has_descendants": {
          "title": "Has Descendants",
          "type": "boolean"
        },
        "submittable": {
          "title": "Submittable",
          "type": "boolean"
        }
      },
      "required": [
        "id",
        "has_ascendants",
        "has_descendants",
        "submittable"
      ],
      "title": "CourseContentKindList",
      "type": "object"
    },
    "CourseContentTypeList": {
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "slug": {
          "title": "Slug",
          "type": "string"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Title"
        },
        "color": {
          "title": "Color",
          "type": "string"
        },
        "course_id": {
          "title": "Course Id",
          "type": "string"
        },
        "course_content_kind_id": {
          "title": "Course Content Kind Id",
          "type": "string"
        },
        "course_content_kind": {
          "anyOf": [
            {
              "$ref": "#/$defs/CourseContentKindList"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "required": [
        "id",
        "slug",
        "color",
        "course_id",
        "course_content_kind_id"
      ],
      "title": "CourseContentTypeList",
      "type": "object"
    },
    "ExampleVersionList": {
      "description": "List view of example versions.",
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "version_tag": {
          "title": "Version Tag",
          "type": "string"
        },
        "version_number": {
          "title": "Version Number",
          "type": "integer"
        },
        "created_at": {
          "format": "date-time",
          "title": "Created At",
          "type": "string"
        }
      },
      "required": [
        "id",
        "version_tag",
        "version_number",
        "created_at"
      ],
      "title": "ExampleVersionList",
      "type": "object"
    },
    "GradedArtifactInfo": {
      "description": "Information about the artifact that was graded.\\n\\nThis provides context about which specific artifact received the grade,\\nuseful for tracking grading history and artifact metadata.",
      "properties": {
        "id": {
          "description": "The artifact ID that was graded",
          "title": "Id",
          "type": "string"
        },
        "created_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "When the artifact was created (ISO format)",
          "title": "Created At"
        },
        "properties": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Additional artifact properties (e.g., GitLab info)",
          "title": "Properties"
        }
      },
      "required": [
        "id"
      ],
      "title": "GradedArtifactInfo",
      "type": "object"
    },
    "ResultStudentList": {
      "properties": {
        "execution_backend_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Execution Backend Id"
        },
        "test_system_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Test System Id"
        },
        "version_identifier": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Version Identifier"
        },
        "status": {
          "anyOf": [
            {
              "$ref": "#/$defs/TaskStatus"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "result": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Result"
        },
        "result_json": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Result Json"
        },
        "submit": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Submit"
        }
      },
      "title": "ResultStudentList",
      "type": "object"
    },
    "SubmissionGroupMemberBasic": {
      "description": "Basic member information",
      "properties": {
        "id": {
          "title": "Id",
          "type": "string"
        },
        "user_id": {
          "title": "User Id",
          "type": "string"
        },
        "course_member_id": {
          "title": "Course Member Id",
          "type": "string"
        },
        "username": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Username"
        },
        "full_name": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Name"
        }
      },
      "required": [
        "id",
        "user_id",
        "course_member_id"
      ],
      "title": "SubmissionGroupMemberBasic",
      "type": "object"
    },
    "SubmissionGroupRepository": {
      "description": "Repository information for a submission group",
      "properties": {
        "provider": {
          "default": "gitlab",
          "title": "Provider",
          "type": "string"
        },
        "url": {
          "title": "Url",
          "type": "string"
        },
        "full_path": {
          "title": "Full Path",
          "type": "string"
        },
        "clone_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Clone Url"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        }
      },
      "required": [
        "url",
        "full_path"
      ],
      "title": "SubmissionGroupRepository",
      "type": "object"
    },
    "SubmissionGroupStudentList": {
      "description": "Submission group data for course contents (list view).",
      "properties": {
        "id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Id"
        },
        "course_content_title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Course Content Title"
        },
        "course_content_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Course Content Path"
        },
        "example_identifier": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Example Identifier"
        },
        "max_group_size": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Max Group Size"
        },
        "current_group_size": {
          "default": 1,
          "title": "Current Group Size",
          "type": "integer"
        },
        "members": {
          "default": [],
          "items": {
            "$ref": "#/$defs/SubmissionGroupMemberBasic"
          },
          "title": "Members",
          "type": "array"
        },
        "repository": {
          "anyOf": [
            {
              "$ref": "#/$defs/SubmissionGroupRepository"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        },
        "status": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Status"
        },
        "grading": {
          "anyOf": [
            {
              "type": "number"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Grading"
        },
        "count": {
          "default": 0,
          "title": "Count",
          "type": "integer"
        },
        "max_submissions": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Max Submissions"
        },
        "unread_message_count": {
          "default": 0,
          "title": "Unread Message Count",
          "type": "integer"
        }
      },
      "title": "SubmissionGroupStudentList",
      "type": "object"
    },
    "TaskStatus": {
      "description": "Task execution status enumeration.",
      "enum": [
        "queued",
        "started",
        "finished",
        "failed",
        "deferred",
        "cancelled"
      ],
      "title": "TaskStatus",
      "type": "string"
    }
  },
  "description": "Response after creating a grade through the tutor endpoint.\\n\\n    Returns the updated course content information with the new grade applied.\\n    We extend CourseContentStudentList to maintain backward compatibility.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "title": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Title"
    },
    "path": {
      "title": "Path",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "course_content_type_id": {
      "title": "Course Content Type Id",
      "type": "string"
    },
    "course_content_kind_id": {
      "title": "Course Content Kind Id",
      "type": "string"
    },
    "position": {
      "title": "Position",
      "type": "number"
    },
    "max_group_size": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Group Size"
    },
    "submitted": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submitted"
    },
    "course_content_type": {
      "$ref": "#/$defs/CourseContentTypeList"
    },
    "result_count": {
      "title": "Result Count",
      "type": "integer"
    },
    "submission_count": {
      "title": "Submission Count",
      "type": "integer"
    },
    "max_test_runs": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Max Test Runs"
    },
    "directory": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Directory"
    },
    "color": {
      "title": "Color",
      "type": "string"
    },
    "result": {
      "anyOf": [
        {
          "$ref": "#/$defs/ResultStudentList"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "submission_group": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupStudentList"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "unread_message_count": {
      "default": 0,
      "title": "Unread Message Count",
      "type": "integer"
    },
    "deployment": {
      "anyOf": [
        {
          "$ref": "#/$defs/CourseContentDeploymentList"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    },
    "has_deployment": {
      "anyOf": [
        {
          "type": "boolean"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Has Deployment"
    },
    "graded_artifact_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Graded Artifact Id"
    },
    "graded_artifact_info": {
      "anyOf": [
        {
          "$ref": "#/$defs/GradedArtifactInfo"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "id",
    "path",
    "course_id",
    "course_content_type_id",
    "course_content_kind_id",
    "position",
    "course_content_type",
    "result_count",
    "submission_count",
    "color"
  ],
  "title": "TutorGradeResponse",
  "type": "object",
  "x-model-name": "TutorGradeResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): TutorGradeResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('TutorGradeResponse', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Optional field: title
    if ('title' in data && data.title !== undefined && data.title !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: path
    if (!('path' in data)) {
      errors.push('Missing required field: path');
    } else {
      if (typeof data.path !== 'string') {
        errors.push('Field path must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: course_content_type_id
    if (!('course_content_type_id' in data)) {
      errors.push('Missing required field: course_content_type_id');
    } else {
      if (typeof data.course_content_type_id !== 'string') {
        errors.push('Field course_content_type_id must be a string');
      }
    }

    // Required field: course_content_kind_id
    if (!('course_content_kind_id' in data)) {
      errors.push('Missing required field: course_content_kind_id');
    } else {
      if (typeof data.course_content_kind_id !== 'string') {
        errors.push('Field course_content_kind_id must be a string');
      }
    }

    // Required field: position
    if (!('position' in data)) {
      errors.push('Missing required field: position');
    } else {
      if (typeof data.position !== 'number') {
        errors.push('Field position must be a number');
      }
    }

    // Optional field: max_group_size
    if ('max_group_size' in data && data.max_group_size !== undefined && data.max_group_size !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submitted
    if ('submitted' in data && data.submitted !== undefined && data.submitted !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: course_content_type
    if (!('course_content_type' in data)) {
      errors.push('Missing required field: course_content_type');
    } else {
      // Reference field - basic object check
      if (typeof data.course_content_type !== 'object') {
        errors.push('Field course_content_type must be an object');
      }
    }

    // Required field: result_count
    if (!('result_count' in data)) {
      errors.push('Missing required field: result_count');
    } else {
      if (typeof data.result_count !== 'number') {
        errors.push('Field result_count must be a number');
      }
    }

    // Required field: submission_count
    if (!('submission_count' in data)) {
      errors.push('Missing required field: submission_count');
    } else {
      if (typeof data.submission_count !== 'number') {
        errors.push('Field submission_count must be a number');
      }
    }

    // Optional field: max_test_runs
    if ('max_test_runs' in data && data.max_test_runs !== undefined && data.max_test_runs !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: directory
    if ('directory' in data && data.directory !== undefined && data.directory !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: color
    if (!('color' in data)) {
      errors.push('Missing required field: color');
    } else {
      if (typeof data.color !== 'string') {
        errors.push('Field color must be a string');
      }
    }

    // Optional field: result
    if ('result' in data && data.result !== undefined && data.result !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_group
    if ('submission_group' in data && data.submission_group !== undefined && data.submission_group !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: unread_message_count
    if ('unread_message_count' in data && data.unread_message_count !== undefined && data.unread_message_count !== null) {
      if (typeof data.unread_message_count !== 'number') {
        errors.push('Field unread_message_count must be a number');
      }
    }

    // Optional field: deployment
    if ('deployment' in data && data.deployment !== undefined && data.deployment !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: has_deployment
    if ('has_deployment' in data && data.has_deployment !== undefined && data.has_deployment !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: graded_artifact_id
    if ('graded_artifact_id' in data && data.graded_artifact_id !== undefined && data.graded_artifact_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: graded_artifact_info
    if ('graded_artifact_info' in data && data.graded_artifact_info !== undefined && data.graded_artifact_info !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('TutorGradeResponse', errors.join('; '));
    }

    return data as TutorGradeResponse;
  }

  safeValidate(data: any): { success: true; data: TutorGradeResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('TutorGradeResponse', String(error)) };
    }
  }
}

/**
 * Single content item to validate.
 */
export class ContentValidationItemValidator extends BaseValidator<ContentValidationItem> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Single content item to validate.",
  "properties": {
    "content_id": {
      "description": "UUID of course content",
      "title": "Content Id",
      "type": "string"
    },
    "example_identifier": {
      "description": "Example identifier/slug from meta.yaml",
      "title": "Example Identifier",
      "type": "string"
    },
    "version_tag": {
      "description": "Version tag from meta.yaml (e.g., '1.0.0')",
      "title": "Version Tag",
      "type": "string"
    }
  },
  "required": [
    "content_id",
    "example_identifier",
    "version_tag"
  ],
  "title": "ContentValidationItem",
  "type": "object",
  "x-model-name": "ContentValidationItem"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ContentValidationItem {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ContentValidationItem', 'Expected an object');
    }

    // Required field: content_id
    if (!('content_id' in data)) {
      errors.push('Missing required field: content_id');
    } else {
      if (typeof data.content_id !== 'string') {
        errors.push('Field content_id must be a string');
      }
    }

    // Required field: example_identifier
    if (!('example_identifier' in data)) {
      errors.push('Missing required field: example_identifier');
    } else {
      if (typeof data.example_identifier !== 'string') {
        errors.push('Field example_identifier must be a string');
      }
    }

    // Required field: version_tag
    if (!('version_tag' in data)) {
      errors.push('Missing required field: version_tag');
    } else {
      if (typeof data.version_tag !== 'string') {
        errors.push('Field version_tag must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ContentValidationItem', errors.join('; '));
    }

    return data as ContentValidationItem;
  }

  safeValidate(data: any): { success: true; data: ContentValidationItem } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ContentValidationItem', String(error)) };
    }
  }
}

/**
 * Validation result for version existence.
 */
export class VersionValidationResultValidator extends BaseValidator<VersionValidationResult> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Validation result for version existence.",
  "properties": {
    "version_tag": {
      "description": "Version tag that was checked",
      "title": "Version Tag",
      "type": "string"
    },
    "exists": {
      "description": "Whether the version exists",
      "title": "Exists",
      "type": "boolean"
    },
    "version_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Version ID if exists",
      "title": "Version Id"
    },
    "message": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Error message if not exists",
      "title": "Message"
    }
  },
  "required": [
    "version_tag",
    "exists"
  ],
  "title": "VersionValidationResult",
  "type": "object",
  "x-model-name": "VersionValidationResult"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): VersionValidationResult {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('VersionValidationResult', 'Expected an object');
    }

    // Required field: version_tag
    if (!('version_tag' in data)) {
      errors.push('Missing required field: version_tag');
    } else {
      if (typeof data.version_tag !== 'string') {
        errors.push('Field version_tag must be a string');
      }
    }

    // Required field: exists
    if (!('exists' in data)) {
      errors.push('Missing required field: exists');
    } else {
      if (typeof data.exists !== 'boolean') {
        errors.push('Field exists must be a boolean');
      }
    }

    // Optional field: version_id
    if ('version_id' in data && data.version_id !== undefined && data.version_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: message
    if ('message' in data && data.message !== undefined && data.message !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('VersionValidationResult', errors.join('; '));
    }

    return data as VersionValidationResult;
  }

  safeValidate(data: any): { success: true; data: VersionValidationResult } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('VersionValidationResult', String(error)) };
    }
  }
}

/**
 * Validation result for a single content item.
 */
export class ContentValidationResultValidator extends BaseValidator<ContentValidationResult> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ExampleValidationResult": {
      "description": "Validation result for example existence.",
      "properties": {
        "identifier": {
          "description": "Example identifier that was checked",
          "title": "Identifier",
          "type": "string"
        },
        "exists": {
          "description": "Whether the example exists",
          "title": "Exists",
          "type": "boolean"
        },
        "example_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Example ID if exists",
          "title": "Example Id"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Error message if not exists",
          "title": "Message"
        }
      },
      "required": [
        "identifier",
        "exists"
      ],
      "title": "ExampleValidationResult",
      "type": "object"
    },
    "VersionValidationResult": {
      "description": "Validation result for version existence.",
      "properties": {
        "version_tag": {
          "description": "Version tag that was checked",
          "title": "Version Tag",
          "type": "string"
        },
        "exists": {
          "description": "Whether the version exists",
          "title": "Exists",
          "type": "boolean"
        },
        "version_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Version ID if exists",
          "title": "Version Id"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Error message if not exists",
          "title": "Message"
        }
      },
      "required": [
        "version_tag",
        "exists"
      ],
      "title": "VersionValidationResult",
      "type": "object"
    }
  },
  "description": "Validation result for a single content item.",
  "properties": {
    "content_id": {
      "title": "Content Id",
      "type": "string"
    },
    "valid": {
      "description": "Whether this content is valid overall",
      "title": "Valid",
      "type": "boolean"
    },
    "example_validation": {
      "$ref": "#/$defs/ExampleValidationResult"
    },
    "version_validation": {
      "$ref": "#/$defs/VersionValidationResult"
    },
    "validation_message": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Overall validation message for this content",
      "title": "Validation Message"
    }
  },
  "required": [
    "content_id",
    "valid",
    "example_validation",
    "version_validation"
  ],
  "title": "ContentValidationResult",
  "type": "object",
  "x-model-name": "ContentValidationResult"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ContentValidationResult {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ContentValidationResult', 'Expected an object');
    }

    // Required field: content_id
    if (!('content_id' in data)) {
      errors.push('Missing required field: content_id');
    } else {
      if (typeof data.content_id !== 'string') {
        errors.push('Field content_id must be a string');
      }
    }

    // Required field: valid
    if (!('valid' in data)) {
      errors.push('Missing required field: valid');
    } else {
      if (typeof data.valid !== 'boolean') {
        errors.push('Field valid must be a boolean');
      }
    }

    // Required field: example_validation
    if (!('example_validation' in data)) {
      errors.push('Missing required field: example_validation');
    } else {
      // Reference field - basic object check
      if (typeof data.example_validation !== 'object') {
        errors.push('Field example_validation must be an object');
      }
    }

    // Required field: version_validation
    if (!('version_validation' in data)) {
      errors.push('Missing required field: version_validation');
    } else {
      // Reference field - basic object check
      if (typeof data.version_validation !== 'object') {
        errors.push('Field version_validation must be an object');
      }
    }

    // Optional field: validation_message
    if ('validation_message' in data && data.validation_message !== undefined && data.validation_message !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ContentValidationResult', errors.join('; '));
    }

    return data as ContentValidationResult;
  }

  safeValidate(data: any): { success: true; data: ContentValidationResult } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ContentValidationResult', String(error)) };
    }
  }
}

/**
 * Request to validate multiple course contents - batch validation.
 */
export class ContentValidationCreateValidator extends BaseValidator<ContentValidationCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ContentValidationItem": {
      "description": "Single content item to validate.",
      "properties": {
        "content_id": {
          "description": "UUID of course content",
          "title": "Content Id",
          "type": "string"
        },
        "example_identifier": {
          "description": "Example identifier/slug from meta.yaml",
          "title": "Example Identifier",
          "type": "string"
        },
        "version_tag": {
          "description": "Version tag from meta.yaml (e.g., '1.0.0')",
          "title": "Version Tag",
          "type": "string"
        }
      },
      "required": [
        "content_id",
        "example_identifier",
        "version_tag"
      ],
      "title": "ContentValidationItem",
      "type": "object"
    }
  },
  "description": "Request to validate multiple course contents - batch validation.",
  "properties": {
    "content_validations": {
      "description": "List of course content to validate",
      "items": {
        "$ref": "#/$defs/ContentValidationItem"
      },
      "title": "Content Validations",
      "type": "array"
    }
  },
  "required": [
    "content_validations"
  ],
  "title": "ContentValidationCreate",
  "type": "object",
  "x-model-name": "ContentValidationCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ContentValidationCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ContentValidationCreate', 'Expected an object');
    }

    // Required field: content_validations
    if (!('content_validations' in data)) {
      errors.push('Missing required field: content_validations');
    } else {
      if (!Array.isArray(data.content_validations)) {
        errors.push('Field content_validations must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ContentValidationCreate', errors.join('; '));
    }

    return data as ContentValidationCreate;
  }

  safeValidate(data: any): { success: true; data: ContentValidationCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ContentValidationCreate', String(error)) };
    }
  }
}

/**
 * Response from batch validation.
 */
export class ContentValidationGetValidator extends BaseValidator<ContentValidationGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ContentValidationResult": {
      "description": "Validation result for a single content item.",
      "properties": {
        "content_id": {
          "title": "Content Id",
          "type": "string"
        },
        "valid": {
          "description": "Whether this content is valid overall",
          "title": "Valid",
          "type": "boolean"
        },
        "example_validation": {
          "$ref": "#/$defs/ExampleValidationResult"
        },
        "version_validation": {
          "$ref": "#/$defs/VersionValidationResult"
        },
        "validation_message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Overall validation message for this content",
          "title": "Validation Message"
        }
      },
      "required": [
        "content_id",
        "valid",
        "example_validation",
        "version_validation"
      ],
      "title": "ContentValidationResult",
      "type": "object"
    },
    "ExampleValidationResult": {
      "description": "Validation result for example existence.",
      "properties": {
        "identifier": {
          "description": "Example identifier that was checked",
          "title": "Identifier",
          "type": "string"
        },
        "exists": {
          "description": "Whether the example exists",
          "title": "Exists",
          "type": "boolean"
        },
        "example_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Example ID if exists",
          "title": "Example Id"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Error message if not exists",
          "title": "Message"
        }
      },
      "required": [
        "identifier",
        "exists"
      ],
      "title": "ExampleValidationResult",
      "type": "object"
    },
    "VersionValidationResult": {
      "description": "Validation result for version existence.",
      "properties": {
        "version_tag": {
          "description": "Version tag that was checked",
          "title": "Version Tag",
          "type": "string"
        },
        "exists": {
          "description": "Whether the version exists",
          "title": "Exists",
          "type": "boolean"
        },
        "version_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Version ID if exists",
          "title": "Version Id"
        },
        "message": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "Error message if not exists",
          "title": "Message"
        }
      },
      "required": [
        "version_tag",
        "exists"
      ],
      "title": "VersionValidationResult",
      "type": "object"
    }
  },
  "description": "Response from batch validation.",
  "properties": {
    "valid": {
      "description": "Overall validation status",
      "title": "Valid",
      "type": "boolean"
    },
    "total_validated": {
      "description": "Total items validated",
      "title": "Total Validated",
      "type": "integer"
    },
    "total_issues": {
      "description": "Number of issues found",
      "title": "Total Issues",
      "type": "integer"
    },
    "validation_results": {
      "description": "Validation results for each content item",
      "items": {
        "$ref": "#/$defs/ContentValidationResult"
      },
      "title": "Validation Results",
      "type": "array"
    }
  },
  "required": [
    "valid",
    "total_validated",
    "total_issues",
    "validation_results"
  ],
  "title": "ContentValidationGet",
  "type": "object",
  "x-model-name": "ContentValidationGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ContentValidationGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ContentValidationGet', 'Expected an object');
    }

    // Required field: valid
    if (!('valid' in data)) {
      errors.push('Missing required field: valid');
    } else {
      if (typeof data.valid !== 'boolean') {
        errors.push('Field valid must be a boolean');
      }
    }

    // Required field: total_validated
    if (!('total_validated' in data)) {
      errors.push('Missing required field: total_validated');
    } else {
      if (typeof data.total_validated !== 'number') {
        errors.push('Field total_validated must be a number');
      }
    }

    // Required field: total_issues
    if (!('total_issues' in data)) {
      errors.push('Missing required field: total_issues');
    } else {
      if (typeof data.total_issues !== 'number') {
        errors.push('Field total_issues must be a number');
      }
    }

    // Required field: validation_results
    if (!('validation_results' in data)) {
      errors.push('Missing required field: validation_results');
    } else {
      if (!Array.isArray(data.validation_results)) {
        errors.push('Field validation_results must be an array');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ContentValidationGet', errors.join('; '));
    }

    return data as ContentValidationGet;
  }

  safeValidate(data: any): { success: true; data: ContentValidationGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ContentValidationGet', String(error)) };
    }
  }
}

/**
 * Metadata extracted from a VSIX manifest.
 */
export class VsixMetadataValidator extends BaseValidator<VsixMetadata> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Metadata extracted from a VSIX manifest.",
  "properties": {
    "publisher": {
      "description": "Publisher identifier from manifest",
      "title": "Publisher",
      "type": "string"
    },
    "name": {
      "description": "Extension name/ID from manifest",
      "title": "Name",
      "type": "string"
    },
    "version": {
      "description": "Semantic version from manifest",
      "title": "Version",
      "type": "string"
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Display name from manifest",
      "title": "Display Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Description from manifest",
      "title": "Description"
    },
    "engine_range": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "VS Code engine compatibility range",
      "title": "Engine Range"
    }
  },
  "required": [
    "publisher",
    "name",
    "version"
  ],
  "title": "VsixMetadata",
  "type": "object",
  "x-model-name": "VsixMetadata"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): VsixMetadata {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('VsixMetadata', 'Expected an object');
    }

    // Required field: publisher
    if (!('publisher' in data)) {
      errors.push('Missing required field: publisher');
    } else {
      if (typeof data.publisher !== 'string') {
        errors.push('Field publisher must be a string');
      }
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Required field: version
    if (!('version' in data)) {
      errors.push('Missing required field: version');
    } else {
      if (typeof data.version !== 'string') {
        errors.push('Field version must be a string');
      }
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: engine_range
    if ('engine_range' in data && data.engine_range !== undefined && data.engine_range !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('VsixMetadata', errors.join('; '));
    }

    return data as VsixMetadata;
  }

  safeValidate(data: any): { success: true; data: VsixMetadata } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('VsixMetadata', String(error)) };
    }
  }
}

/**
 * Form metadata submitted when publishing a new extension version.
 */
export class ExtensionPublishRequestValidator extends BaseValidator<ExtensionPublishRequest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Form metadata submitted when publishing a new extension version.",
  "properties": {
    "version": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Semantic version override (defaults to manifest value)",
      "title": "Version"
    },
    "engine_range": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "VS Code engine compatibility override",
      "title": "Engine Range"
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Friendly display name for the extension",
      "title": "Display Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Optional extension description",
      "title": "Description"
    }
  },
  "title": "ExtensionPublishRequest",
  "type": "object",
  "x-model-name": "ExtensionPublishRequest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionPublishRequest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionPublishRequest', 'Expected an object');
    }

    // Optional field: version
    if ('version' in data && data.version !== undefined && data.version !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: engine_range
    if ('engine_range' in data && data.engine_range !== undefined && data.engine_range !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionPublishRequest', errors.join('; '));
    }

    return data as ExtensionPublishRequest;
  }

  safeValidate(data: any): { success: true; data: ExtensionPublishRequest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionPublishRequest', String(error)) };
    }
  }
}

/**
 * Common fields describing an extension version.
 */
export class ExtensionVersionBaseValidator extends BaseValidator<ExtensionVersionBase> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Common fields describing an extension version.",
  "properties": {
    "version": {
      "description": "Semantic version identifier",
      "title": "Version",
      "type": "string"
    },
    "version_number": {
      "description": "Sequential version number for ordering",
      "title": "Version Number",
      "type": "integer"
    },
    "engine_range": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "VS Code engine compatibility constraint",
      "title": "Engine Range"
    },
    "yanked": {
      "default": false,
      "description": "Whether the version is yanked",
      "title": "Yanked",
      "type": "boolean"
    },
    "size": {
      "description": "Package size in bytes",
      "title": "Size",
      "type": "integer"
    },
    "sha256": {
      "description": "SHA256 checksum of the VSIX contents",
      "title": "Sha256",
      "type": "string"
    },
    "content_type": {
      "description": "Stored content type of the VSIX",
      "title": "Content Type",
      "type": "string"
    },
    "created_at": {
      "description": "Creation timestamp",
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "published_at": {
      "description": "Publish timestamp",
      "format": "date-time",
      "title": "Published At",
      "type": "string"
    }
  },
  "required": [
    "version",
    "version_number",
    "size",
    "sha256",
    "content_type",
    "created_at",
    "published_at"
  ],
  "title": "ExtensionVersionBase",
  "type": "object",
  "x-model-name": "ExtensionVersionBase"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionVersionBase {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionVersionBase', 'Expected an object');
    }

    // Required field: version
    if (!('version' in data)) {
      errors.push('Missing required field: version');
    } else {
      if (typeof data.version !== 'string') {
        errors.push('Field version must be a string');
      }
    }

    // Required field: version_number
    if (!('version_number' in data)) {
      errors.push('Missing required field: version_number');
    } else {
      if (typeof data.version_number !== 'number') {
        errors.push('Field version_number must be a number');
      }
    }

    // Optional field: engine_range
    if ('engine_range' in data && data.engine_range !== undefined && data.engine_range !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: yanked
    if ('yanked' in data && data.yanked !== undefined && data.yanked !== null) {
      if (typeof data.yanked !== 'boolean') {
        errors.push('Field yanked must be a boolean');
      }
    }

    // Required field: size
    if (!('size' in data)) {
      errors.push('Missing required field: size');
    } else {
      if (typeof data.size !== 'number') {
        errors.push('Field size must be a number');
      }
    }

    // Required field: sha256
    if (!('sha256' in data)) {
      errors.push('Missing required field: sha256');
    } else {
      if (typeof data.sha256 !== 'string') {
        errors.push('Field sha256 must be a string');
      }
    }

    // Required field: content_type
    if (!('content_type' in data)) {
      errors.push('Missing required field: content_type');
    } else {
      if (typeof data.content_type !== 'string') {
        errors.push('Field content_type must be a string');
      }
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: published_at
    if (!('published_at' in data)) {
      errors.push('Missing required field: published_at');
    } else {
      if (typeof data.published_at !== 'string') {
        errors.push('Field published_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionVersionBase', errors.join('; '));
    }

    return data as ExtensionVersionBase;
  }

  safeValidate(data: any): { success: true; data: ExtensionVersionBase } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionVersionBase', String(error)) };
    }
  }
}

/**
 * List view of extension versions.
 */
export class ExtensionVersionListItemValidator extends BaseValidator<ExtensionVersionListItem> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "List view of extension versions.",
  "properties": {
    "version": {
      "description": "Semantic version identifier",
      "title": "Version",
      "type": "string"
    },
    "version_number": {
      "description": "Sequential version number for ordering",
      "title": "Version Number",
      "type": "integer"
    },
    "engine_range": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "VS Code engine compatibility constraint",
      "title": "Engine Range"
    },
    "yanked": {
      "default": false,
      "description": "Whether the version is yanked",
      "title": "Yanked",
      "type": "boolean"
    },
    "size": {
      "description": "Package size in bytes",
      "title": "Size",
      "type": "integer"
    },
    "sha256": {
      "description": "SHA256 checksum of the VSIX contents",
      "title": "Sha256",
      "type": "string"
    },
    "content_type": {
      "description": "Stored content type of the VSIX",
      "title": "Content Type",
      "type": "string"
    },
    "created_at": {
      "description": "Creation timestamp",
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "published_at": {
      "description": "Publish timestamp",
      "format": "date-time",
      "title": "Published At",
      "type": "string"
    }
  },
  "required": [
    "version",
    "version_number",
    "size",
    "sha256",
    "content_type",
    "created_at",
    "published_at"
  ],
  "title": "ExtensionVersionListItem",
  "type": "object",
  "x-model-name": "ExtensionVersionListItem"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionVersionListItem {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionVersionListItem', 'Expected an object');
    }

    // Required field: version
    if (!('version' in data)) {
      errors.push('Missing required field: version');
    } else {
      if (typeof data.version !== 'string') {
        errors.push('Field version must be a string');
      }
    }

    // Required field: version_number
    if (!('version_number' in data)) {
      errors.push('Missing required field: version_number');
    } else {
      if (typeof data.version_number !== 'number') {
        errors.push('Field version_number must be a number');
      }
    }

    // Optional field: engine_range
    if ('engine_range' in data && data.engine_range !== undefined && data.engine_range !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: yanked
    if ('yanked' in data && data.yanked !== undefined && data.yanked !== null) {
      if (typeof data.yanked !== 'boolean') {
        errors.push('Field yanked must be a boolean');
      }
    }

    // Required field: size
    if (!('size' in data)) {
      errors.push('Missing required field: size');
    } else {
      if (typeof data.size !== 'number') {
        errors.push('Field size must be a number');
      }
    }

    // Required field: sha256
    if (!('sha256' in data)) {
      errors.push('Missing required field: sha256');
    } else {
      if (typeof data.sha256 !== 'string') {
        errors.push('Field sha256 must be a string');
      }
    }

    // Required field: content_type
    if (!('content_type' in data)) {
      errors.push('Missing required field: content_type');
    } else {
      if (typeof data.content_type !== 'string') {
        errors.push('Field content_type must be a string');
      }
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: published_at
    if (!('published_at' in data)) {
      errors.push('Missing required field: published_at');
    } else {
      if (typeof data.published_at !== 'string') {
        errors.push('Field published_at must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionVersionListItem', errors.join('; '));
    }

    return data as ExtensionVersionListItem;
  }

  safeValidate(data: any): { success: true; data: ExtensionVersionListItem } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionVersionListItem', String(error)) };
    }
  }
}

/**
 * Detailed view of an extension version.
 */
export class ExtensionVersionDetailValidator extends BaseValidator<ExtensionVersionDetail> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Detailed view of an extension version.",
  "properties": {
    "version": {
      "description": "Semantic version identifier",
      "title": "Version",
      "type": "string"
    },
    "version_number": {
      "description": "Sequential version number for ordering",
      "title": "Version Number",
      "type": "integer"
    },
    "engine_range": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "VS Code engine compatibility constraint",
      "title": "Engine Range"
    },
    "yanked": {
      "default": false,
      "description": "Whether the version is yanked",
      "title": "Yanked",
      "type": "boolean"
    },
    "size": {
      "description": "Package size in bytes",
      "title": "Size",
      "type": "integer"
    },
    "sha256": {
      "description": "SHA256 checksum of the VSIX contents",
      "title": "Sha256",
      "type": "string"
    },
    "content_type": {
      "description": "Stored content type of the VSIX",
      "title": "Content Type",
      "type": "string"
    },
    "created_at": {
      "description": "Creation timestamp",
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "published_at": {
      "description": "Publish timestamp",
      "format": "date-time",
      "title": "Published At",
      "type": "string"
    },
    "object_key": {
      "description": "Object storage key for the VSIX",
      "title": "Object Key",
      "type": "string"
    }
  },
  "required": [
    "version",
    "version_number",
    "size",
    "sha256",
    "content_type",
    "created_at",
    "published_at",
    "object_key"
  ],
  "title": "ExtensionVersionDetail",
  "type": "object",
  "x-model-name": "ExtensionVersionDetail"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionVersionDetail {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionVersionDetail', 'Expected an object');
    }

    // Required field: version
    if (!('version' in data)) {
      errors.push('Missing required field: version');
    } else {
      if (typeof data.version !== 'string') {
        errors.push('Field version must be a string');
      }
    }

    // Required field: version_number
    if (!('version_number' in data)) {
      errors.push('Missing required field: version_number');
    } else {
      if (typeof data.version_number !== 'number') {
        errors.push('Field version_number must be a number');
      }
    }

    // Optional field: engine_range
    if ('engine_range' in data && data.engine_range !== undefined && data.engine_range !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: yanked
    if ('yanked' in data && data.yanked !== undefined && data.yanked !== null) {
      if (typeof data.yanked !== 'boolean') {
        errors.push('Field yanked must be a boolean');
      }
    }

    // Required field: size
    if (!('size' in data)) {
      errors.push('Missing required field: size');
    } else {
      if (typeof data.size !== 'number') {
        errors.push('Field size must be a number');
      }
    }

    // Required field: sha256
    if (!('sha256' in data)) {
      errors.push('Missing required field: sha256');
    } else {
      if (typeof data.sha256 !== 'string') {
        errors.push('Field sha256 must be a string');
      }
    }

    // Required field: content_type
    if (!('content_type' in data)) {
      errors.push('Missing required field: content_type');
    } else {
      if (typeof data.content_type !== 'string') {
        errors.push('Field content_type must be a string');
      }
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: published_at
    if (!('published_at' in data)) {
      errors.push('Missing required field: published_at');
    } else {
      if (typeof data.published_at !== 'string') {
        errors.push('Field published_at must be a string');
      }
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionVersionDetail', errors.join('; '));
    }

    return data as ExtensionVersionDetail;
  }

  safeValidate(data: any): { success: true; data: ExtensionVersionDetail } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionVersionDetail', String(error)) };
    }
  }
}

/**
 * Response payload for version listing.
 */
export class ExtensionVersionListResponseValidator extends BaseValidator<ExtensionVersionListResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ExtensionVersionListItem": {
      "description": "List view of extension versions.",
      "properties": {
        "version": {
          "description": "Semantic version identifier",
          "title": "Version",
          "type": "string"
        },
        "version_number": {
          "description": "Sequential version number for ordering",
          "title": "Version Number",
          "type": "integer"
        },
        "engine_range": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "VS Code engine compatibility constraint",
          "title": "Engine Range"
        },
        "yanked": {
          "default": false,
          "description": "Whether the version is yanked",
          "title": "Yanked",
          "type": "boolean"
        },
        "size": {
          "description": "Package size in bytes",
          "title": "Size",
          "type": "integer"
        },
        "sha256": {
          "description": "SHA256 checksum of the VSIX contents",
          "title": "Sha256",
          "type": "string"
        },
        "content_type": {
          "description": "Stored content type of the VSIX",
          "title": "Content Type",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "date-time",
          "title": "Created At",
          "type": "string"
        },
        "published_at": {
          "description": "Publish timestamp",
          "format": "date-time",
          "title": "Published At",
          "type": "string"
        }
      },
      "required": [
        "version",
        "version_number",
        "size",
        "sha256",
        "content_type",
        "created_at",
        "published_at"
      ],
      "title": "ExtensionVersionListItem",
      "type": "object"
    }
  },
  "description": "Response payload for version listing.",
  "properties": {
    "items": {
      "items": {
        "$ref": "#/$defs/ExtensionVersionListItem"
      },
      "title": "Items",
      "type": "array"
    },
    "next_cursor": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Pagination cursor for the next page, if available",
      "title": "Next Cursor"
    }
  },
  "title": "ExtensionVersionListResponse",
  "type": "object",
  "x-model-name": "ExtensionVersionListResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionVersionListResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionVersionListResponse', 'Expected an object');
    }

    // Optional field: items
    if ('items' in data && data.items !== undefined && data.items !== null) {
      if (!Array.isArray(data.items)) {
        errors.push('Field items must be an array');
      }
    }

    // Optional field: next_cursor
    if ('next_cursor' in data && data.next_cursor !== undefined && data.next_cursor !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionVersionListResponse', errors.join('; '));
    }

    return data as ExtensionVersionListResponse;
  }

  safeValidate(data: any): { success: true; data: ExtensionVersionListResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionVersionListResponse', String(error)) };
    }
  }
}

/**
 * Extension-level metadata including latest version information.
 */
export class ExtensionMetadataValidator extends BaseValidator<ExtensionMetadata> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ExtensionVersionListItem": {
      "description": "List view of extension versions.",
      "properties": {
        "version": {
          "description": "Semantic version identifier",
          "title": "Version",
          "type": "string"
        },
        "version_number": {
          "description": "Sequential version number for ordering",
          "title": "Version Number",
          "type": "integer"
        },
        "engine_range": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "description": "VS Code engine compatibility constraint",
          "title": "Engine Range"
        },
        "yanked": {
          "default": false,
          "description": "Whether the version is yanked",
          "title": "Yanked",
          "type": "boolean"
        },
        "size": {
          "description": "Package size in bytes",
          "title": "Size",
          "type": "integer"
        },
        "sha256": {
          "description": "SHA256 checksum of the VSIX contents",
          "title": "Sha256",
          "type": "string"
        },
        "content_type": {
          "description": "Stored content type of the VSIX",
          "title": "Content Type",
          "type": "string"
        },
        "created_at": {
          "description": "Creation timestamp",
          "format": "date-time",
          "title": "Created At",
          "type": "string"
        },
        "published_at": {
          "description": "Publish timestamp",
          "format": "date-time",
          "title": "Published At",
          "type": "string"
        }
      },
      "required": [
        "version",
        "version_number",
        "size",
        "sha256",
        "content_type",
        "created_at",
        "published_at"
      ],
      "title": "ExtensionVersionListItem",
      "type": "object"
    }
  },
  "description": "Extension-level metadata including latest version information.",
  "properties": {
    "publisher": {
      "description": "Publisher identifier",
      "title": "Publisher",
      "type": "string"
    },
    "name": {
      "description": "Extension name",
      "title": "Name",
      "type": "string"
    },
    "display_name": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Friendly display name for the extension",
      "title": "Display Name"
    },
    "description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Extension description",
      "title": "Description"
    },
    "id": {
      "description": "Database identifier for the extension",
      "title": "Id",
      "type": "string"
    },
    "created_at": {
      "description": "Creation timestamp",
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "updated_at": {
      "description": "Last update timestamp",
      "format": "date-time",
      "title": "Updated At",
      "type": "string"
    },
    "version_count": {
      "description": "Number of stored versions",
      "title": "Version Count",
      "type": "integer"
    },
    "latest_version": {
      "anyOf": [
        {
          "$ref": "#/$defs/ExtensionVersionListItem"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Metadata for the latest available version"
    }
  },
  "required": [
    "publisher",
    "name",
    "id",
    "created_at",
    "updated_at",
    "version_count"
  ],
  "title": "ExtensionMetadata",
  "type": "object",
  "x-model-name": "ExtensionMetadata"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionMetadata {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionMetadata', 'Expected an object');
    }

    // Required field: publisher
    if (!('publisher' in data)) {
      errors.push('Missing required field: publisher');
    } else {
      if (typeof data.publisher !== 'string') {
        errors.push('Field publisher must be a string');
      }
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    // Optional field: display_name
    if ('display_name' in data && data.display_name !== undefined && data.display_name !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: description
    if ('description' in data && data.description !== undefined && data.description !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: updated_at
    if (!('updated_at' in data)) {
      errors.push('Missing required field: updated_at');
    } else {
      if (typeof data.updated_at !== 'string') {
        errors.push('Field updated_at must be a string');
      }
    }

    // Required field: version_count
    if (!('version_count' in data)) {
      errors.push('Missing required field: version_count');
    } else {
      if (typeof data.version_count !== 'number') {
        errors.push('Field version_count must be a number');
      }
    }

    // Optional field: latest_version
    if ('latest_version' in data && data.latest_version !== undefined && data.latest_version !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionMetadata', errors.join('; '));
    }

    return data as ExtensionMetadata;
  }

  safeValidate(data: any): { success: true; data: ExtensionMetadata } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionMetadata', String(error)) };
    }
  }
}

/**
 * Request payload to (un)yank a specific version.
 */
export class ExtensionVersionYankRequestValidator extends BaseValidator<ExtensionVersionYankRequest> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Request payload to (un)yank a specific version.",
  "properties": {
    "yanked": {
      "description": "Target yank state for the version",
      "title": "Yanked",
      "type": "boolean"
    }
  },
  "required": [
    "yanked"
  ],
  "title": "ExtensionVersionYankRequest",
  "type": "object",
  "x-model-name": "ExtensionVersionYankRequest"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionVersionYankRequest {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionVersionYankRequest', 'Expected an object');
    }

    // Required field: yanked
    if (!('yanked' in data)) {
      errors.push('Missing required field: yanked');
    } else {
      if (typeof data.yanked !== 'boolean') {
        errors.push('Field yanked must be a boolean');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionVersionYankRequest', errors.join('; '));
    }

    return data as ExtensionVersionYankRequest;
  }

  safeValidate(data: any): { success: true; data: ExtensionVersionYankRequest } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionVersionYankRequest', String(error)) };
    }
  }
}

/**
 * Response payload returned after publishing a version.
 */
export class ExtensionPublishResponseValidator extends BaseValidator<ExtensionPublishResponse> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Response payload returned after publishing a version.",
  "properties": {
    "version": {
      "description": "Semantic version identifier",
      "title": "Version",
      "type": "string"
    },
    "version_number": {
      "description": "Sequential version number for ordering",
      "title": "Version Number",
      "type": "integer"
    },
    "engine_range": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "VS Code engine compatibility constraint",
      "title": "Engine Range"
    },
    "yanked": {
      "default": false,
      "description": "Whether the version is yanked",
      "title": "Yanked",
      "type": "boolean"
    },
    "size": {
      "description": "Package size in bytes",
      "title": "Size",
      "type": "integer"
    },
    "sha256": {
      "description": "SHA256 checksum of the VSIX contents",
      "title": "Sha256",
      "type": "string"
    },
    "content_type": {
      "description": "Stored content type of the VSIX",
      "title": "Content Type",
      "type": "string"
    },
    "created_at": {
      "description": "Creation timestamp",
      "format": "date-time",
      "title": "Created At",
      "type": "string"
    },
    "published_at": {
      "description": "Publish timestamp",
      "format": "date-time",
      "title": "Published At",
      "type": "string"
    },
    "object_key": {
      "description": "Object storage key for the VSIX",
      "title": "Object Key",
      "type": "string"
    },
    "publisher": {
      "description": "Publisher identifier",
      "title": "Publisher",
      "type": "string"
    },
    "name": {
      "description": "Extension name",
      "title": "Name",
      "type": "string"
    }
  },
  "required": [
    "version",
    "version_number",
    "size",
    "sha256",
    "content_type",
    "created_at",
    "published_at",
    "object_key",
    "publisher",
    "name"
  ],
  "title": "ExtensionPublishResponse",
  "type": "object",
  "x-model-name": "ExtensionPublishResponse"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ExtensionPublishResponse {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ExtensionPublishResponse', 'Expected an object');
    }

    // Required field: version
    if (!('version' in data)) {
      errors.push('Missing required field: version');
    } else {
      if (typeof data.version !== 'string') {
        errors.push('Field version must be a string');
      }
    }

    // Required field: version_number
    if (!('version_number' in data)) {
      errors.push('Missing required field: version_number');
    } else {
      if (typeof data.version_number !== 'number') {
        errors.push('Field version_number must be a number');
      }
    }

    // Optional field: engine_range
    if ('engine_range' in data && data.engine_range !== undefined && data.engine_range !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: yanked
    if ('yanked' in data && data.yanked !== undefined && data.yanked !== null) {
      if (typeof data.yanked !== 'boolean') {
        errors.push('Field yanked must be a boolean');
      }
    }

    // Required field: size
    if (!('size' in data)) {
      errors.push('Missing required field: size');
    } else {
      if (typeof data.size !== 'number') {
        errors.push('Field size must be a number');
      }
    }

    // Required field: sha256
    if (!('sha256' in data)) {
      errors.push('Missing required field: sha256');
    } else {
      if (typeof data.sha256 !== 'string') {
        errors.push('Field sha256 must be a string');
      }
    }

    // Required field: content_type
    if (!('content_type' in data)) {
      errors.push('Missing required field: content_type');
    } else {
      if (typeof data.content_type !== 'string') {
        errors.push('Field content_type must be a string');
      }
    }

    // Required field: created_at
    if (!('created_at' in data)) {
      errors.push('Missing required field: created_at');
    } else {
      if (typeof data.created_at !== 'string') {
        errors.push('Field created_at must be a string');
      }
    }

    // Required field: published_at
    if (!('published_at' in data)) {
      errors.push('Missing required field: published_at');
    } else {
      if (typeof data.published_at !== 'string') {
        errors.push('Field published_at must be a string');
      }
    }

    // Required field: object_key
    if (!('object_key' in data)) {
      errors.push('Missing required field: object_key');
    } else {
      if (typeof data.object_key !== 'string') {
        errors.push('Field object_key must be a string');
      }
    }

    // Required field: publisher
    if (!('publisher' in data)) {
      errors.push('Missing required field: publisher');
    } else {
      if (typeof data.publisher !== 'string') {
        errors.push('Field publisher must be a string');
      }
    }

    // Required field: name
    if (!('name' in data)) {
      errors.push('Missing required field: name');
    } else {
      if (typeof data.name !== 'string') {
        errors.push('Field name must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ExtensionPublishResponse', errors.join('; '));
    }

    return data as ExtensionPublishResponse;
  }

  safeValidate(data: any): { success: true; data: ExtensionPublishResponse } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ExtensionPublishResponse', String(error)) };
    }
  }
}

/**
 * Detailed deployment information for a course content.
 */
export class DeploymentGetValidator extends BaseValidator<DeploymentGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Detailed deployment information for a course content.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "example_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Id"
    },
    "example_version_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Version Id"
    },
    "example_identifier": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Identifier"
    },
    "version_tag": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Tag"
    },
    "deployment_status": {
      "title": "Deployment Status",
      "type": "string"
    },
    "deployment_message": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployment Message"
    },
    "assigned_at": {
      "format": "date-time",
      "title": "Assigned At",
      "type": "string"
    },
    "deployed_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployed At"
    },
    "deployment_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployment Path"
    },
    "example_title": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Title"
    },
    "example_directory": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Directory"
    },
    "example_description": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Example Description"
    },
    "course_content_title": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Title"
    },
    "course_content_path": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Path"
    }
  },
  "required": [
    "id",
    "course_content_id",
    "deployment_status",
    "assigned_at"
  ],
  "title": "DeploymentGet",
  "type": "object",
  "x-model-name": "DeploymentGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): DeploymentGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('DeploymentGet', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Optional field: example_id
    if ('example_id' in data && data.example_id !== undefined && data.example_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_version_id
    if ('example_version_id' in data && data.example_version_id !== undefined && data.example_version_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_identifier
    if ('example_identifier' in data && data.example_identifier !== undefined && data.example_identifier !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: version_tag
    if ('version_tag' in data && data.version_tag !== undefined && data.version_tag !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: deployment_status
    if (!('deployment_status' in data)) {
      errors.push('Missing required field: deployment_status');
    } else {
      if (typeof data.deployment_status !== 'string') {
        errors.push('Field deployment_status must be a string');
      }
    }

    // Optional field: deployment_message
    if ('deployment_message' in data && data.deployment_message !== undefined && data.deployment_message !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: assigned_at
    if (!('assigned_at' in data)) {
      errors.push('Missing required field: assigned_at');
    } else {
      if (typeof data.assigned_at !== 'string') {
        errors.push('Field assigned_at must be a string');
      }
    }

    // Optional field: deployed_at
    if ('deployed_at' in data && data.deployed_at !== undefined && data.deployed_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: deployment_path
    if ('deployment_path' in data && data.deployment_path !== undefined && data.deployment_path !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_title
    if ('example_title' in data && data.example_title !== undefined && data.example_title !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_directory
    if ('example_directory' in data && data.example_directory !== undefined && data.example_directory !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: example_description
    if ('example_description' in data && data.example_description !== undefined && data.example_description !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_title
    if ('course_content_title' in data && data.course_content_title !== undefined && data.course_content_title !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_path
    if ('course_content_path' in data && data.course_content_path !== undefined && data.course_content_path !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('DeploymentGet', errors.join('; '));
    }

    return data as DeploymentGet;
  }

  safeValidate(data: any): { success: true; data: DeploymentGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('DeploymentGet', String(error)) };
    }
  }
}

/**
 * Minimal deployment info for list views.
 */
export class DeploymentListValidator extends BaseValidator<DeploymentList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Minimal deployment info for list views.",
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "deployment_status": {
      "title": "Deployment Status",
      "type": "string"
    },
    "version_tag": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Version Tag"
    },
    "assigned_at": {
      "format": "date-time",
      "title": "Assigned At",
      "type": "string"
    },
    "deployed_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Deployed At"
    }
  },
  "required": [
    "id",
    "course_content_id",
    "deployment_status",
    "assigned_at"
  ],
  "title": "DeploymentList",
  "type": "object",
  "x-model-name": "DeploymentList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): DeploymentList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('DeploymentList', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: deployment_status
    if (!('deployment_status' in data)) {
      errors.push('Missing required field: deployment_status');
    } else {
      if (typeof data.deployment_status !== 'string') {
        errors.push('Field deployment_status must be a string');
      }
    }

    // Optional field: version_tag
    if ('version_tag' in data && data.version_tag !== undefined && data.version_tag !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: assigned_at
    if (!('assigned_at' in data)) {
      errors.push('Missing required field: assigned_at');
    } else {
      if (typeof data.assigned_at !== 'string') {
        errors.push('Field assigned_at must be a string');
      }
    }

    // Optional field: deployed_at
    if ('deployed_at' in data && data.deployed_at !== undefined && data.deployed_at !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('DeploymentList', errors.join('; '));
    }

    return data as DeploymentList;
  }

  safeValidate(data: any): { success: true; data: DeploymentList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('DeploymentList', String(error)) };
    }
  }
}

/**
 * Single validation error for release validation.
 */
export class ValidationErrorValidator extends BaseValidator<ValidationError> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "description": "Single validation error for release validation.",
  "properties": {
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "title": {
      "title": "Title",
      "type": "string"
    },
    "path": {
      "title": "Path",
      "type": "string"
    },
    "issue": {
      "title": "Issue",
      "type": "string"
    }
  },
  "required": [
    "course_content_id",
    "title",
    "path",
    "issue"
  ],
  "title": "ValidationError",
  "type": "object",
  "x-model-name": "ValidationError"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ValidationError {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ValidationError', 'Expected an object');
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: title
    if (!('title' in data)) {
      errors.push('Missing required field: title');
    } else {
      if (typeof data.title !== 'string') {
        errors.push('Field title must be a string');
      }
    }

    // Required field: path
    if (!('path' in data)) {
      errors.push('Missing required field: path');
    } else {
      if (typeof data.path !== 'string') {
        errors.push('Field path must be a string');
      }
    }

    // Required field: issue
    if (!('issue' in data)) {
      errors.push('Missing required field: issue');
    } else {
      if (typeof data.issue !== 'string') {
        errors.push('Field issue must be a string');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ValidationError', errors.join('; '));
    }

    return data as ValidationError;
  }

  safeValidate(data: any): { success: true; data: ValidationError } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ValidationError', String(error)) };
    }
  }
}

/**
 * Error response when release validation fails.
 */
export class ReleaseValidationErrorValidator extends BaseValidator<ReleaseValidationError> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "ValidationError": {
      "description": "Single validation error for release validation.",
      "properties": {
        "course_content_id": {
          "title": "Course Content Id",
          "type": "string"
        },
        "title": {
          "title": "Title",
          "type": "string"
        },
        "path": {
          "title": "Path",
          "type": "string"
        },
        "issue": {
          "title": "Issue",
          "type": "string"
        }
      },
      "required": [
        "course_content_id",
        "title",
        "path",
        "issue"
      ],
      "title": "ValidationError",
      "type": "object"
    }
  },
  "description": "Error response when release validation fails.",
  "properties": {
    "error": {
      "description": "Main error message",
      "title": "Error",
      "type": "string"
    },
    "validation_errors": {
      "description": "List of specific issues",
      "items": {
        "$ref": "#/$defs/ValidationError"
      },
      "title": "Validation Errors",
      "type": "array"
    },
    "total_issues": {
      "description": "Count of validation errors",
      "title": "Total Issues",
      "type": "integer"
    }
  },
  "required": [
    "error",
    "validation_errors",
    "total_issues"
  ],
  "title": "ReleaseValidationError",
  "type": "object",
  "x-model-name": "ReleaseValidationError"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): ReleaseValidationError {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('ReleaseValidationError', 'Expected an object');
    }

    // Required field: error
    if (!('error' in data)) {
      errors.push('Missing required field: error');
    } else {
      if (typeof data.error !== 'string') {
        errors.push('Field error must be a string');
      }
    }

    // Required field: validation_errors
    if (!('validation_errors' in data)) {
      errors.push('Missing required field: validation_errors');
    } else {
      if (!Array.isArray(data.validation_errors)) {
        errors.push('Field validation_errors must be an array');
      }
    }

    // Required field: total_issues
    if (!('total_issues' in data)) {
      errors.push('Missing required field: total_issues');
    } else {
      if (typeof data.total_issues !== 'number') {
        errors.push('Field total_issues must be a number');
      }
    }

    if (errors.length > 0) {
      throw new ValidationError('ReleaseValidationError', errors.join('; '));
    }

    return data as ReleaseValidationError;
  }

  safeValidate(data: any): { success: true; data: ReleaseValidationError } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('ReleaseValidationError', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupMemberProperties
 */
export class SubmissionGroupMemberPropertiesValidator extends BaseValidator<SubmissionGroupMemberProperties> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    }
  },
  "additionalProperties": true,
  "properties": {
    "gitlab": {
      "anyOf": [
        {
          "$ref": "#/$defs/GitLabConfig"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "title": "SubmissionGroupMemberProperties",
  "type": "object",
  "x-model-name": "SubmissionGroupMemberProperties"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupMemberProperties {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupMemberProperties', 'Expected an object');
    }

    // Optional field: gitlab
    if ('gitlab' in data && data.gitlab !== undefined && data.gitlab !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupMemberProperties', errors.join('; '));
    }

    return data as SubmissionGroupMemberProperties;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupMemberProperties } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupMemberProperties', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupMemberCreate
 */
export class SubmissionGroupMemberCreateValidator extends BaseValidator<SubmissionGroupMemberCreate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupMemberProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupMemberProperties",
      "type": "object"
    }
  },
  "properties": {
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "grading": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grading"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupMemberProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "course_member_id",
    "submission_group_id"
  ],
  "title": "SubmissionGroupMemberCreate",
  "type": "object",
  "x-model-name": "SubmissionGroupMemberCreate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupMemberCreate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupMemberCreate', 'Expected an object');
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Optional field: grading
    if ('grading' in data && data.grading !== undefined && data.grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupMemberCreate', errors.join('; '));
    }

    return data as SubmissionGroupMemberCreate;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupMemberCreate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupMemberCreate', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupMemberGet
 */
export class SubmissionGroupMemberGetValidator extends BaseValidator<SubmissionGroupMemberGet> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupMemberProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupMemberProperties",
      "type": "object"
    }
  },
  "properties": {
    "created_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Creation timestamp",
      "title": "Created At"
    },
    "updated_at": {
      "anyOf": [
        {
          "format": "date-time",
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "description": "Update timestamp",
      "title": "Updated At"
    },
    "created_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Created By"
    },
    "updated_by": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Updated By"
    },
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "grading": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grading"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupMemberProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "required": [
    "id",
    "course_id",
    "course_content_id",
    "course_member_id",
    "submission_group_id"
  ],
  "title": "SubmissionGroupMemberGet",
  "type": "object",
  "x-model-name": "SubmissionGroupMemberGet"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupMemberGet {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupMemberGet', 'Expected an object');
    }

    // Optional field: created_at
    if ('created_at' in data && data.created_at !== undefined && data.created_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_at
    if ('updated_at' in data && data.updated_at !== undefined && data.updated_at !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: created_by
    if ('created_by' in data && data.created_by !== undefined && data.created_by !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: updated_by
    if ('updated_by' in data && data.updated_by !== undefined && data.updated_by !== null) {
      // Union type - skipping detailed validation
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Optional field: grading
    if ('grading' in data && data.grading !== undefined && data.grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupMemberGet', errors.join('; '));
    }

    return data as SubmissionGroupMemberGet;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupMemberGet } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupMemberGet', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupMemberList
 */
export class SubmissionGroupMemberListValidator extends BaseValidator<SubmissionGroupMemberList> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "id": {
      "title": "Id",
      "type": "string"
    },
    "course_id": {
      "title": "Course Id",
      "type": "string"
    },
    "course_content_id": {
      "title": "Course Content Id",
      "type": "string"
    },
    "course_member_id": {
      "title": "Course Member Id",
      "type": "string"
    },
    "submission_group_id": {
      "title": "Submission Group Id",
      "type": "string"
    },
    "grading": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grading"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    }
  },
  "required": [
    "id",
    "course_id",
    "course_content_id",
    "course_member_id",
    "submission_group_id"
  ],
  "title": "SubmissionGroupMemberList",
  "type": "object",
  "x-model-name": "SubmissionGroupMemberList"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupMemberList {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupMemberList', 'Expected an object');
    }

    // Required field: id
    if (!('id' in data)) {
      errors.push('Missing required field: id');
    } else {
      if (typeof data.id !== 'string') {
        errors.push('Field id must be a string');
      }
    }

    // Required field: course_id
    if (!('course_id' in data)) {
      errors.push('Missing required field: course_id');
    } else {
      if (typeof data.course_id !== 'string') {
        errors.push('Field course_id must be a string');
      }
    }

    // Required field: course_content_id
    if (!('course_content_id' in data)) {
      errors.push('Missing required field: course_content_id');
    } else {
      if (typeof data.course_content_id !== 'string') {
        errors.push('Field course_content_id must be a string');
      }
    }

    // Required field: course_member_id
    if (!('course_member_id' in data)) {
      errors.push('Missing required field: course_member_id');
    } else {
      if (typeof data.course_member_id !== 'string') {
        errors.push('Field course_member_id must be a string');
      }
    }

    // Required field: submission_group_id
    if (!('submission_group_id' in data)) {
      errors.push('Missing required field: submission_group_id');
    } else {
      if (typeof data.submission_group_id !== 'string') {
        errors.push('Field submission_group_id must be a string');
      }
    }

    // Optional field: grading
    if ('grading' in data && data.grading !== undefined && data.grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupMemberList', errors.join('; '));
    }

    return data as SubmissionGroupMemberList;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupMemberList } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupMemberList', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupMemberUpdate
 */
export class SubmissionGroupMemberUpdateValidator extends BaseValidator<SubmissionGroupMemberUpdate> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "$defs": {
    "GitLabConfig": {
      "properties": {
        "settings": {
          "anyOf": [
            {
              "additionalProperties": true,
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Settings"
        },
        "url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Url"
        },
        "full_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Full Path"
        },
        "directory": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Directory"
        },
        "registry": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Registry"
        },
        "parent": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent"
        },
        "group_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Group Id"
        },
        "parent_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Parent Id"
        },
        "namespace_id": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Id"
        },
        "namespace_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Namespace Path"
        },
        "web_url": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Web Url"
        },
        "visibility": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Visibility"
        },
        "last_synced_at": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Last Synced At"
        },
        "token": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Token"
        }
      },
      "title": "GitLabConfig",
      "type": "object"
    },
    "SubmissionGroupMemberProperties": {
      "additionalProperties": true,
      "properties": {
        "gitlab": {
          "anyOf": [
            {
              "$ref": "#/$defs/GitLabConfig"
            },
            {
              "type": "null"
            }
          ],
          "default": null
        }
      },
      "title": "SubmissionGroupMemberProperties",
      "type": "object"
    }
  },
  "properties": {
    "course_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Id"
    },
    "grading": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grading"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    },
    "properties": {
      "anyOf": [
        {
          "$ref": "#/$defs/SubmissionGroupMemberProperties"
        },
        {
          "type": "null"
        }
      ],
      "default": null
    }
  },
  "title": "SubmissionGroupMemberUpdate",
  "type": "object",
  "x-model-name": "SubmissionGroupMemberUpdate"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupMemberUpdate {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupMemberUpdate', 'Expected an object');
    }

    // Optional field: course_id
    if ('course_id' in data && data.course_id !== undefined && data.course_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grading
    if ('grading' in data && data.grading !== undefined && data.grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: properties
    if ('properties' in data && data.properties !== undefined && data.properties !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupMemberUpdate', errors.join('; '));
    }

    return data as SubmissionGroupMemberUpdate;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupMemberUpdate } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupMemberUpdate', String(error)) };
    }
  }
}

/**
 * Validator for SubmissionGroupMemberQuery
 */
export class SubmissionGroupMemberQueryValidator extends BaseValidator<SubmissionGroupMemberQuery> {
  private static _schema: any = null;

  /**
   * Get JSON Schema for this model
   * Useful for form generation, validation, and documentation
   */
  static getSchema(): any {
    if (!this._schema) {
      this._schema = JSON.parse(`{
  "properties": {
    "skip": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 0,
      "title": "Skip"
    },
    "limit": {
      "anyOf": [
        {
          "type": "integer"
        },
        {
          "type": "null"
        }
      ],
      "default": 100,
      "title": "Limit"
    },
    "id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Id"
    },
    "course_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Id"
    },
    "course_content_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Content Id"
    },
    "course_member_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Course Member Id"
    },
    "submission_group_id": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Submission Group Id"
    },
    "grading": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Grading"
    },
    "status": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ],
      "default": null,
      "title": "Status"
    }
  },
  "title": "SubmissionGroupMemberQuery",
  "type": "object",
  "x-model-name": "SubmissionGroupMemberQuery"
}`);
    }
    return this._schema;
  }

  /**
   * Get schema for a specific field
   */
  static getFieldSchema(fieldName: string): any {
    return this.getSchema().properties?.[fieldName];
  }

  /**
   * Check if a field is required
   */
  static isFieldRequired(fieldName: string): boolean {
    return this.getSchema().required?.includes(fieldName) ?? false;
  }

  /**
   * Get all required field names
   */
  static getRequiredFields(): string[] {
    return this.getSchema().required ?? [];
  }

  /**
   * Get all field names
   */
  static getFields(): string[] {
    return Object.keys(this.getSchema().properties ?? {});
  }

  validate(data: any): SubmissionGroupMemberQuery {
    const errors: string[] = [];

    if (typeof data !== 'object' || data === null) {
      throw new ValidationError('SubmissionGroupMemberQuery', 'Expected an object');
    }

    // Optional field: skip
    if ('skip' in data && data.skip !== undefined && data.skip !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: limit
    if ('limit' in data && data.limit !== undefined && data.limit !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: id
    if ('id' in data && data.id !== undefined && data.id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_id
    if ('course_id' in data && data.course_id !== undefined && data.course_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_content_id
    if ('course_content_id' in data && data.course_content_id !== undefined && data.course_content_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: course_member_id
    if ('course_member_id' in data && data.course_member_id !== undefined && data.course_member_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: submission_group_id
    if ('submission_group_id' in data && data.submission_group_id !== undefined && data.submission_group_id !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: grading
    if ('grading' in data && data.grading !== undefined && data.grading !== null) {
      // Union type - skipping detailed validation
    }

    // Optional field: status
    if ('status' in data && data.status !== undefined && data.status !== null) {
      // Union type - skipping detailed validation
    }

    if (errors.length > 0) {
      throw new ValidationError('SubmissionGroupMemberQuery', errors.join('; '));
    }

    return data as SubmissionGroupMemberQuery;
  }

  safeValidate(data: any): { success: true; data: SubmissionGroupMemberQuery } | { success: false; error: ValidationError } {
    try {
      const validData = this.validate(data);
      return { success: true, data: validData };
    } catch (error) {
      if (error instanceof ValidationError) {
        return { success: false, error };
      }
      return { success: false, error: new ValidationError('SubmissionGroupMemberQuery', String(error)) };
    }
  }
}
